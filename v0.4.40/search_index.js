var documenterSearchIndex = {"docs":
[{"location":"explanation/glossary/#Glossary","page":"Glossary","title":"Glossary","text":"","category":"section"},{"location":"explanation/glossary/","page":"Glossary","title":"Glossary","text":"foldl(step, xf, input, init=...)\n#  |   |    |     |\n#  |   |    |     `-- reducible\n#  |   |    |\n#  |   |    `-- transducer\n#  |   |\n#  |   `-- \"bottom\" (inner most) reducing function\n#  |\n#  `-- transducible process","category":"page"},{"location":"explanation/glossary/#Reducing-step-function","page":"Glossary","title":"Reducing step function","text":"","category":"section"},{"location":"explanation/glossary/","page":"Glossary","title":"Glossary","text":"Reducing function or Reducing step (function): A reducing function combines result-so-far with the input.  It in a narrow sense is a \"callable\" op of the signature op(::X, ::Y) :: X (or op(::X, ::X) :: X in case for reduce) or schematically:","category":"page"},{"location":"explanation/glossary/","page":"Glossary","title":"Glossary","text":"(textresult-so-far textinput) mapsto textresult-so-far","category":"page"},{"location":"explanation/glossary/","page":"Glossary","title":"Glossary","text":"It is the function that can be passed to the classic (non-Transducers.jl) Base.foldl or Base.reduce.  It is sometimes referred to as a step or op.  In Transducers.jl, next(rf, ::X, ::Y) :: X is used instead of a \"bare\" callable.  Furthermore, a reducing function in a loose sense also includes other interfaces such as start(rf, ::X) and complete(rf, ::X).","category":"page"},{"location":"explanation/glossary/#glossary-transducer","page":"Glossary","title":"Transducer","text":"","category":"section"},{"location":"explanation/glossary/","page":"Glossary","title":"Glossary","text":"A transducer in Transducers.jl is a transformation xf that","category":"page"},{"location":"explanation/glossary/","page":"Glossary","title":"Glossary","text":"transforms an iterator with xf(itr) (iterator transformation)\ntransforms a reducing step function with xf'(rf) (reducing function transformation)","category":"page"},{"location":"explanation/glossary/","page":"Glossary","title":"Glossary","text":"Common variable names for transducers are xf and xform.","category":"page"},{"location":"explanation/glossary/","page":"Glossary","title":"Glossary","text":"The idea of generalizing the transducer as two kinds of transformation is due to Jan Weidner @jw3126.  See the discussion in JuliaFolds/Transducers.jl#67.","category":"page"},{"location":"explanation/glossary/#glossary-ixf","page":"Glossary","title":"Iterator transformation","text":"","category":"section"},{"location":"explanation/glossary/","page":"Glossary","title":"Glossary","text":"As of Transducers.jl 0.4.39, the call overload of Transducer is interpreted as an iterator transformation.  That is to say, the iterator transformation using Base.Iterators","category":"page"},{"location":"explanation/glossary/","page":"Glossary","title":"Glossary","text":"julia> ixf₁ = itr -> Iterators.filter(isodd, itr);","category":"page"},{"location":"explanation/glossary/","page":"Glossary","title":"Glossary","text":"and the iterator transformation in Transducers.jl","category":"page"},{"location":"explanation/glossary/","page":"Glossary","title":"Glossary","text":"julia> ixf₂ = Filter(isodd);","category":"page"},{"location":"explanation/glossary/","page":"Glossary","title":"Glossary","text":"behaves identically:","category":"page"},{"location":"explanation/glossary/","page":"Glossary","title":"Glossary","text":"julia> collect(ixf₁(1:10)) == collect(ixf₂(1:10))\ntrue","category":"page"},{"location":"explanation/glossary/","page":"Glossary","title":"Glossary","text":"Filter(isodd)(1:10) is an eduction.","category":"page"},{"location":"explanation/glossary/#glossary-rfxf","page":"Glossary","title":"Reducing function transformation","text":"","category":"section"},{"location":"explanation/glossary/","page":"Glossary","title":"Glossary","text":"Transducers.jl 0.4.39 also exposes reducing function (RF) transformation with xf'(rf) (adjoint):","category":"page"},{"location":"explanation/glossary/","page":"Glossary","title":"Glossary","text":"julia> rf = Filter(isodd)'(+);  # equivalent to (acc, x) -> isodd(x) ? acc + x : acc\n\njulia> rf(0, 2)  # `2` filtered out\n0\n\njulia> rf(0, 1)  # `1` not filtered out\n1","category":"page"},{"location":"explanation/glossary/#Transducer-in-the-narrow-sense-(Clojure)","page":"Glossary","title":"Transducer in the narrow sense (Clojure)","text":"","category":"section"},{"location":"explanation/glossary/","page":"Glossary","title":"Glossary","text":"The transducer as originally introduced by Rich Hickey is a transformation of reducing step function.  Thus, what is referred to as a transducer mathrmxf in Clojure and many other languages is the reducing function transformation xf' in Transducer.jl.","category":"page"},{"location":"explanation/glossary/","page":"Glossary","title":"Glossary","text":"Since a transducer in the narrow sense maps a reducing function to a reducing function, it can be composed with simple function composition .  When a composite transducer mathrmxf = mathrmxf_1 circ mathrmxf_2 circ  circ mathrmxf_n to a \"bottom\" reducing function mathrmrf_0, it is processed from right to left just like normal functions:","category":"page"},{"location":"explanation/glossary/","page":"Glossary","title":"Glossary","text":"mathrmrf =\nmathrmxf_1(mathrmxf_2((mathrmxf_n(mathrmrf_0))))","category":"page"},{"location":"explanation/glossary/","page":"Glossary","title":"Glossary","text":"which is equivalent to the following forms in Transducers.jl","category":"page"},{"location":"explanation/glossary/","page":"Glossary","title":"Glossary","text":"rf = xf₁'(xf₂'(...(xfₙ'(rf₀))))\nrf = (xf₁' ∘ xf₂' ∘ ... ∘ xfₙ')(rf₀)\nrf = (xfₙ ∘ ... ∘ xf₂ ∘ xf₁)'(rf₀)\nrf = (xf₁ ⨟ xf₂ ⨟ ... ⨟ xfₙ)(rf₀)","category":"page"},{"location":"explanation/glossary/#Inner-transducer","page":"Glossary","title":"Inner transducer","text":"","category":"section"},{"location":"explanation/glossary/","page":"Glossary","title":"Glossary","text":"Given a composition xf₁' ∘ xf₂', transducer xf₂ is said to be the inner transducer of xf₁' ∘ xf₂'.  Likewise, xf₂'(rf₀) is an inner reducing function of xf₁'(xf₂'(rf₀)).","category":"page"},{"location":"explanation/glossary/#Reducible-collection","page":"Glossary","title":"Reducible collection","text":"","category":"section"},{"location":"explanation/glossary/","page":"Glossary","title":"Glossary","text":"Reducible collection (or just Reducible): Any object that can be passed to foldl and alike is reducible.  A reducible collection knows how to apply reducing function to its elements.  Iterators are automatically reducible as this is the canonical fallback implementation.","category":"page"},{"location":"explanation/glossary/#Transducible-process","page":"Glossary","title":"Transducible process","text":"","category":"section"},{"location":"explanation/glossary/","page":"Glossary","title":"Glossary","text":"A function that can reduce reducible collections using transducers is a transducible process.  Examples are foldl and reduce.  Find more in Transducible processes.","category":"page"},{"location":"parallelism/#overview-parallel","page":"Parallelism","title":"Overview of parallel processing in Transducers.jl","text":"","category":"section"},{"location":"parallelism/","page":"Parallelism","title":"Parallelism","text":"Transducers.jl supports thread-based (reduce) and process-based (dreduce) parallelisms with the same composable API; i.e. transducers.  Having a uniform API to cover different parallelisms as well as sequential processing foldl is useful.  Using multiple cores or machines for your computation is as easy as replacing foldl with reduce or dreduce; you don't need to re-write your transducers or reducing functions.","category":"page"},{"location":"parallelism/","page":"Parallelism","title":"Parallelism","text":"See also:","category":"page"},{"location":"parallelism/","page":"Parallelism","title":"Parallelism","text":"Parallel processing tutorial in Transducers.jl manual.\nAPI documentation of reduce and dreduce.","category":"page"},{"location":"parallelism/#Thread-based-parallelism","page":"Parallelism","title":"Thread-based parallelism","text":"","category":"section"},{"location":"parallelism/","page":"Parallelism","title":"Parallelism","text":"note: Note\nTo use multiple threads, the julia process must be started with appropriate environment variable JULIA_NUM_THREADS.  See Julia manual for more information about how to enable and verify multi-threading in Julia:Multi-Threading (Experimental) · Parallel Computing · The Julia Language\nJULIA_NUM_THREADS · Environment Variables · The Julia Language","category":"page"},{"location":"parallelism/","page":"Parallelism","title":"Parallelism","text":"Transducers.jl supports thread-based parallelism for Julia ≥ 1.0.  You can use it by replacing foldl with reduce.  With Julia ≥ 1.3, Transducers.jl supports early termination to avoid unnecessary computation while guaranteeing the result to be deterministic; i.e., it does not depend on how computation tasks are scheduled.","category":"page"},{"location":"parallelism/#Process-based-parallelism","page":"Parallelism","title":"Process-based parallelism","text":"","category":"section"},{"location":"parallelism/","page":"Parallelism","title":"Parallelism","text":"Transducers.jl supports process-based parallelism using Distributed.jl. You can use it by replacing foldl with dreduce. It can be used for horizontally scaling the computation.  It is also useful for using external libraries that are not \"thread-safe.\"","category":"page"},{"location":"parallelism/","page":"Parallelism","title":"Parallelism","text":"Note that early termination is not supported in dreduce yet.","category":"page"},{"location":"howto/reducibles/","page":"Writing reducibles","title":"Writing reducibles","text":"EditURL = \"https://github.com/JuliaFolds/Transducers.jl/blob/master/examples/reducibles.jl\"","category":"page"},{"location":"howto/reducibles/#How-to-make-your-data-type-reducible","page":"Writing reducibles","title":"How to make your data type reducible","text":"","category":"section"},{"location":"howto/reducibles/","page":"Writing reducibles","title":"Writing reducibles","text":"Let's see how to make a vector-of-vector a reducible collection; i.e., a type that can be fed to foldl.","category":"page"},{"location":"howto/reducibles/","page":"Writing reducibles","title":"Writing reducibles","text":"struct VecOfVec{T}\n    vectors::Vector{Vector{T}}\nend","category":"page"},{"location":"howto/reducibles/","page":"Writing reducibles","title":"Writing reducibles","text":"We need @next and complete to invoke the reducing function rf.","category":"page"},{"location":"howto/reducibles/","page":"Writing reducibles","title":"Writing reducibles","text":"using Transducers\nusing Transducers: @next, complete","category":"page"},{"location":"howto/reducibles/","page":"Writing reducibles","title":"Writing reducibles","text":"Supporting foldl and similar only requires Transducers.__foldl__:","category":"page"},{"location":"howto/reducibles/","page":"Writing reducibles","title":"Writing reducibles","text":"function Transducers.__foldl__(rf, val, vov::VecOfVec)\n    for vector in vov.vectors\n        for x in vector\n            val = @next(rf, val, x)\n        end\n    end\n    return complete(rf, val)\nend","category":"page"},{"location":"howto/reducibles/","page":"Writing reducibles","title":"Writing reducibles","text":"Note that it's often a good idea to implement Base.eltype:","category":"page"},{"location":"howto/reducibles/","page":"Writing reducibles","title":"Writing reducibles","text":"Base.eltype(::VecOfVec{T}) where {T} = T","category":"page"},{"location":"howto/reducibles/","page":"Writing reducibles","title":"Writing reducibles","text":"It can be then used as the input to the transducers:","category":"page"},{"location":"howto/reducibles/","page":"Writing reducibles","title":"Writing reducibles","text":"vov = VecOfVec(collect.([1:n for n in 1:3]))\ncollect(Map(identity), vov)","category":"page"},{"location":"howto/reducibles/","page":"Writing reducibles","title":"Writing reducibles","text":"Macro @next is used instead of function next to avoid the boilerplate for supporting early termination (see the details in in @next documentation).  In practice, using @next means that your __foldl__ supports early termination:","category":"page"},{"location":"howto/reducibles/","page":"Writing reducibles","title":"Writing reducibles","text":"vov |> Take(3) |> collect","category":"page"},{"location":"howto/reducibles/","page":"Writing reducibles","title":"Writing reducibles","text":"More complex example:","category":"page"},{"location":"howto/reducibles/","page":"Writing reducibles","title":"Writing reducibles","text":"vov |> PartitionBy(isequal(1)) |> Zip(Map(copy), Map(sum)) |> collect","category":"page"},{"location":"howto/reducibles/","page":"Writing reducibles","title":"Writing reducibles","text":"Notice that writing Transducers.__foldl__ is very straightforward comparing to how to define an iterator:","category":"page"},{"location":"howto/reducibles/","page":"Writing reducibles","title":"Writing reducibles","text":"function Base.iterate(vov::VecOfVec, state=(1, 1))","category":"page"},{"location":"howto/reducibles/","page":"Writing reducibles","title":"Writing reducibles","text":"Iterator state is a tuple of an index i to vov.vectors and an index j to vov.vectors[i]:","category":"page"},{"location":"howto/reducibles/","page":"Writing reducibles","title":"Writing reducibles","text":"    i, j = state","category":"page"},{"location":"howto/reducibles/","page":"Writing reducibles","title":"Writing reducibles","text":"If i is larger than the number of items, we are done:","category":"page"},{"location":"howto/reducibles/","page":"Writing reducibles","title":"Writing reducibles","text":"    i > length(vov.vectors) && return nothing","category":"page"},{"location":"howto/reducibles/","page":"Writing reducibles","title":"Writing reducibles","text":"If j is in bound, we are iterating the same sub-vector:","category":"page"},{"location":"howto/reducibles/","page":"Writing reducibles","title":"Writing reducibles","text":"    vi = vov.vectors[i]\n    if j <= length(vi)\n        return vi[j], (i, j + 1)\n    end","category":"page"},{"location":"howto/reducibles/","page":"Writing reducibles","title":"Writing reducibles","text":"Otherwise, find the next non-empty sub-vector and start iterating it:","category":"page"},{"location":"howto/reducibles/","page":"Writing reducibles","title":"Writing reducibles","text":"    for k in i + 1:length(vov.vectors)\n        vk = vov.vectors[k]\n        if !isempty(vk)\n            return vk[1], (k, 2)  # i=k, j=2\n        end\n    end\n    return nothing\nend\n\nBase.length(vov::VecOfVec) = sum(length, vov.vectors)\n\ncollect(vov)","category":"page"},{"location":"howto/reducibles/","page":"Writing reducibles","title":"Writing reducibles","text":"","category":"page"},{"location":"howto/reducibles/","page":"Writing reducibles","title":"Writing reducibles","text":"This page was generated using Literate.jl.","category":"page"},{"location":"howto/upgrade-to-ixf/","page":"Upgrade to new |> of Transducers.jl 0.4.39","title":"Upgrade to new |> of Transducers.jl 0.4.39","text":"EditURL = \"https://github.com/JuliaFolds/Transducers.jl/blob/master/examples/upgrade-to-ixf.jl\"","category":"page"},{"location":"howto/upgrade-to-ixf/#Upgrade-to-new-of-Transducers.jl-0.4.39","page":"Upgrade to new |> of Transducers.jl 0.4.39","title":"Upgrade to new |> of Transducers.jl 0.4.39","text":"","category":"section"},{"location":"howto/upgrade-to-ixf/","page":"Upgrade to new |> of Transducers.jl 0.4.39","title":"Upgrade to new |> of Transducers.jl 0.4.39","text":"Transducers.jl 0.4.39 now interprets |> differently.  Consider the following examples:","category":"page"},{"location":"howto/upgrade-to-ixf/","page":"Upgrade to new |> of Transducers.jl 0.4.39","title":"Upgrade to new |> of Transducers.jl 0.4.39","text":"using Transducers\nusing Logging                                                        # hide\n\nwith_logger(NullLogger()) do                                         # hide\ncollect(Filter(isodd) |> Map(inv), 1:5)\nfoldl(+, Filter(isodd) |> Map(inv), 1:5)\nend                                                                  # hide\nnothing                                                              # hide","category":"page"},{"location":"howto/upgrade-to-ixf/","page":"Upgrade to new |> of Transducers.jl 0.4.39","title":"Upgrade to new |> of Transducers.jl 0.4.39","text":"It is now recommended to write","category":"page"},{"location":"howto/upgrade-to-ixf/","page":"Upgrade to new |> of Transducers.jl 0.4.39","title":"Upgrade to new |> of Transducers.jl 0.4.39","text":"1:5 |> Filter(isodd) |> Map(inv) |> collect\nfoldl(+, 1:5 |> Filter(isodd) |> Map(inv))\nnothing                                                              # hide","category":"page"},{"location":"howto/upgrade-to-ixf/","page":"Upgrade to new |> of Transducers.jl 0.4.39","title":"Upgrade to new |> of Transducers.jl 0.4.39","text":"The last snippet can also be written as","category":"page"},{"location":"howto/upgrade-to-ixf/","page":"Upgrade to new |> of Transducers.jl 0.4.39","title":"Upgrade to new |> of Transducers.jl 0.4.39","text":"1:5 |> Filter(isodd) |> Map(inv) |> sum\nnothing                                                              # hide","category":"page"},{"location":"howto/upgrade-to-ixf/","page":"Upgrade to new |> of Transducers.jl 0.4.39","title":"Upgrade to new |> of Transducers.jl 0.4.39","text":"Note that |> now is compatible with the standard function application definition of |> (i.e., x |> f == f(x)):","category":"page"},{"location":"howto/upgrade-to-ixf/","page":"Upgrade to new |> of Transducers.jl 0.4.39","title":"Upgrade to new |> of Transducers.jl 0.4.39","text":"@assert 1:5 |> Filter(isodd) |> Map(inv) === Map(inv)(Filter(isodd)(1:5))","category":"page"},{"location":"howto/upgrade-to-ixf/","page":"Upgrade to new |> of Transducers.jl 0.4.39","title":"Upgrade to new |> of Transducers.jl 0.4.39","text":"note: Note\nJulia < 1.3 requires collection |> xf or eduction(xf, collection) instead of xf(collection).","category":"page"},{"location":"howto/upgrade-to-ixf/","page":"Upgrade to new |> of Transducers.jl 0.4.39","title":"Upgrade to new |> of Transducers.jl 0.4.39","text":"If there is no input collection; e.g.,","category":"page"},{"location":"howto/upgrade-to-ixf/","page":"Upgrade to new |> of Transducers.jl 0.4.39","title":"Upgrade to new |> of Transducers.jl 0.4.39","text":"with_logger(NullLogger()) do                                         # hide\nfoldl(right, GroupBy(x -> gcd(x, 6), Map(last) |> Filter(isodd), push!!), 1:10)\nend                                                                  # hide\nnothing                                                              # hide","category":"page"},{"location":"howto/upgrade-to-ixf/","page":"Upgrade to new |> of Transducers.jl 0.4.39","title":"Upgrade to new |> of Transducers.jl 0.4.39","text":"use the opposite composition opcompose instead:","category":"page"},{"location":"howto/upgrade-to-ixf/","page":"Upgrade to new |> of Transducers.jl 0.4.39","title":"Upgrade to new |> of Transducers.jl 0.4.39","text":"foldl(right, GroupBy(x -> gcd(x, 6), opcompose(Map(last), Filter(isodd)), push!!), 1:10)\nnothing                                                              # hide","category":"page"},{"location":"howto/upgrade-to-ixf/","page":"Upgrade to new |> of Transducers.jl 0.4.39","title":"Upgrade to new |> of Transducers.jl 0.4.39","text":"In Julia ≥ 1.5, ⨟ can also be used as the infix version of the opposite composition","category":"page"},{"location":"howto/upgrade-to-ixf/","page":"Upgrade to new |> of Transducers.jl 0.4.39","title":"Upgrade to new |> of Transducers.jl 0.4.39","text":"foldl(right, GroupBy(x -> gcd(x, 6), Map(last) ⨟ Filter(isodd), push!!), 1:10)","category":"page"},{"location":"howto/upgrade-to-ixf/","page":"Upgrade to new |> of Transducers.jl 0.4.39","title":"Upgrade to new |> of Transducers.jl 0.4.39","text":"Note that collection |> xf and xf(collection) create an eduction(xf, collection) which is iterable. However, it is not recommended to use it with non-specialized functions.  For example, even though","category":"page"},{"location":"howto/upgrade-to-ixf/","page":"Upgrade to new |> of Transducers.jl 0.4.39","title":"Upgrade to new |> of Transducers.jl 0.4.39","text":"ys = Int[]\nfor x in 1:5 |> Filter(isodd)\n    push!(ys, x)\nend\nnothing                                                              # hide","category":"page"},{"location":"howto/upgrade-to-ixf/","page":"Upgrade to new |> of Transducers.jl 0.4.39","title":"Upgrade to new |> of Transducers.jl 0.4.39","text":"works as expected, it is recommended to use","category":"page"},{"location":"howto/upgrade-to-ixf/","page":"Upgrade to new |> of Transducers.jl 0.4.39","title":"Upgrade to new |> of Transducers.jl 0.4.39","text":"ys = Int[]\nforeach(1:5 |> Filter(isodd)) do x\n    push!(ys, x)\nend\nnothing                                                              # hide","category":"page"},{"location":"howto/upgrade-to-ixf/","page":"Upgrade to new |> of Transducers.jl 0.4.39","title":"Upgrade to new |> of Transducers.jl 0.4.39","text":"when the performance is important.","category":"page"},{"location":"howto/upgrade-to-ixf/","page":"Upgrade to new |> of Transducers.jl 0.4.39","title":"Upgrade to new |> of Transducers.jl 0.4.39","text":"Transducers.jl 0.4.39 also adds xf'(rf) as the reducing function transformation.  This makes composing reducing functions easier.  For example, it can be used to compute even minimum and odd maximum in one go:","category":"page"},{"location":"howto/upgrade-to-ixf/","page":"Upgrade to new |> of Transducers.jl 0.4.39","title":"Upgrade to new |> of Transducers.jl 0.4.39","text":"rf = TeeRF(Filter(iseven)'(min), Filter(isodd)'(max))\nreduce(rf, Map(identity), 1:10)","category":"page"},{"location":"howto/upgrade-to-ixf/","page":"Upgrade to new |> of Transducers.jl 0.4.39","title":"Upgrade to new |> of Transducers.jl 0.4.39","text":"More details can be found in the reference entries such as Transducer, eduction, adjoint, reducingfunction and ∘.  To understand how those interfaces work coherently, see the explanation section on \"generalized\" transducers.","category":"page"},{"location":"howto/upgrade-to-ixf/","page":"Upgrade to new |> of Transducers.jl 0.4.39","title":"Upgrade to new |> of Transducers.jl 0.4.39","text":"","category":"page"},{"location":"howto/upgrade-to-ixf/","page":"Upgrade to new |> of Transducers.jl 0.4.39","title":"Upgrade to new |> of Transducers.jl 0.4.39","text":"This page was generated using Literate.jl.","category":"page"},{"location":"explanation/comparison_to_iterators/#comparison-to-iterators","page":"Comparison to iterators","title":"Comparison to iterators","text":"","category":"section"},{"location":"explanation/comparison_to_iterators/","page":"Comparison to iterators","title":"Comparison to iterators","text":"DocTestSetup = quote\n    using Transducers\nend","category":"page"},{"location":"explanation/comparison_to_iterators/","page":"Comparison to iterators","title":"Comparison to iterators","text":"How foldl is used illustrates the difference between iterators and transducers.  Consider a transducer","category":"page"},{"location":"explanation/comparison_to_iterators/","page":"Comparison to iterators","title":"Comparison to iterators","text":"julia> using Transducers\n\njulia> xf = opcompose(Filter(iseven), Map(x -> 2x));","category":"page"},{"location":"explanation/comparison_to_iterators/","page":"Comparison to iterators","title":"Comparison to iterators","text":"which works as","category":"page"},{"location":"explanation/comparison_to_iterators/","page":"Comparison to iterators","title":"Comparison to iterators","text":"julia> collect(xf, 1:6)\n3-element Array{Int64,1}:\n  4\n  8\n 12\n\njulia> foldl(+, xf, 1:6)  # 4 + 8 + 12\n24","category":"page"},{"location":"explanation/comparison_to_iterators/","page":"Comparison to iterators","title":"Comparison to iterators","text":"Implementation of the above computation in iterator would be:","category":"page"},{"location":"explanation/comparison_to_iterators/","page":"Comparison to iterators","title":"Comparison to iterators","text":"f(x) = 2x\nimap = Base.Iterators.Generator  # like `map`, but returns an iterator\nmapfoldl(f, +, filter(iseven, input), init=0)\nfoldl(+, imap(f, filter(iseven, input)))  # equivalent\n#        ______________________________\n#        composition occurs at input part","category":"page"},{"location":"explanation/comparison_to_iterators/","page":"Comparison to iterators","title":"Comparison to iterators","text":"Compare it to how transducers are used:","category":"page"},{"location":"explanation/comparison_to_iterators/","page":"Comparison to iterators","title":"Comparison to iterators","text":"foldl(+, opcompose(Filter(iseven), Map(f)), input, init=0)\n#        _________________________________\n#        composition occurs at computation part","category":"page"},{"location":"explanation/comparison_to_iterators/","page":"Comparison to iterators","title":"Comparison to iterators","text":"Although this is just a syntactic difference, it is reflected in the actual code generated by those two frameworks.  The code for iterator would be lowered to:","category":"page"},{"location":"explanation/comparison_to_iterators/","page":"Comparison to iterators","title":"Comparison to iterators","text":"function map_filter_iterators(xs, init)\n    ret = iterate(xs)\n    ret === nothing && return init\n    acc = init\n    @goto filter\n    local state, x\n    while true\n        while true                                    # input\n            ret = iterate(xs, state)                  #\n            ret === nothing && return acc             #\n            @label filter                             #\n            x, state = ret                            #\n            iseven(x) && break             # filter   :\n        end                                #          :\n        y = 2x              # imap         :          :\n        acc += y    # +     :              :          :\n    end             # :     :              :          :\n    #                 + <-- imap <-------- filter <-- input\nend","category":"page"},{"location":"explanation/comparison_to_iterators/","page":"Comparison to iterators","title":"Comparison to iterators","text":"Notice that the iteration of input is the inner most block, followed by filter, imap, and then finally +.  Iterators are described as pull-based; an outer iterator (say imap) has to \"pull\" an item from the inner iterator (filter in above example). It is reflected in the lowered code above.","category":"page"},{"location":"explanation/comparison_to_iterators/","page":"Comparison to iterators","title":"Comparison to iterators","text":"On the other hand, the code using transducers is lowered to:","category":"page"},{"location":"explanation/comparison_to_iterators/","page":"Comparison to iterators","title":"Comparison to iterators","text":"function map_filter_transducers(xs, init)\n    acc = init\n    #              input -> Filter --> Map --> +\n    for x in xs  # input    :          :       :\n        if iseven(x)  #     Filter     :       :\n            y = 2x    #                Map     :\n            acc += y  #                        +\n        end\n    end\n    return acc\nend\n\nxs = [6, 8, 1, 4, 5, 6, 6, 7, 9, 9, 7, 8, 6, 8, 2, 5, 2, 4, 3, 7]\n@assert map_filter_iterators(xs, 0) == map_filter_transducers(xs, 0)","category":"page"},{"location":"explanation/comparison_to_iterators/","page":"Comparison to iterators","title":"Comparison to iterators","text":"Notice that the iteration of input is at the outer most block while + is in the inner most block.  Transducers passed to foldl appears in the block between them in the order they are composed.  An outer transducer (say Filter) \"pushes\" arbitrary number of items to the inner transducer (Map in above example). Note that Filter can choose to not push an item (i.e., push zero item) when the predicate returns false.  This push-based nature of the transducers allows the generation of very natural and efficient code.  To put it another way, the transducers and transducible processes own the loop.","category":"page"},{"location":"explanation/comparison_to_iterators/","page":"Comparison to iterators","title":"Comparison to iterators","text":"As a consequence, computations requiring to expand an item into a sequence can be processed efficiently.  Consider the following example:","category":"page"},{"location":"explanation/comparison_to_iterators/","page":"Comparison to iterators","title":"Comparison to iterators","text":"julia> xf = opcompose(Map(x -> 1:x), Filter(iseven ∘ sum), Cat())\n       foldl(*, xf, 1:10)\n29262643200","category":"page"},{"location":"explanation/comparison_to_iterators/","page":"Comparison to iterators","title":"Comparison to iterators","text":"This is lowered to a nested for loops:","category":"page"},{"location":"explanation/comparison_to_iterators/","page":"Comparison to iterators","title":"Comparison to iterators","text":"function map_filter_cat_transducers(xs, init)\n    acc = init\n    for x in xs\n        y1 = 1:x                # Map\n        if iseven(sum(y1))      # Filter\n            for y2 in y1        # Cat\n                acc *= y2       # *\n            end\n        end\n    end\n    return acc\nend\n\n@assert foldl(*, xf, 1:10) == map_filter_cat_transducers(1:10, 1)","category":"page"},{"location":"explanation/comparison_to_iterators/","page":"Comparison to iterators","title":"Comparison to iterators","text":"It is not straightforward to implement an iterator like Cat that can output more than one items at a time.  Such an iterator has to track the state of the inner (y1 in above) and outer (xs in above) iterators and conditionally invoke the outer iterator once the inner iterator terminates.  This generates a complicated code and the compiler would have hard time optimizing it.","category":"page"},{"location":"explanation/comparison_to_iterators/","page":"Comparison to iterators","title":"Comparison to iterators","text":"DocTestSetup = nothing","category":"page"},{"location":"howto/transducers/","page":"Writing transducers","title":"Writing transducers","text":"EditURL = \"https://github.com/JuliaFolds/Transducers.jl/blob/master/examples/transducers.jl\"","category":"page"},{"location":"howto/transducers/#How-to-write-transducers","page":"Writing transducers","title":"How to write transducers","text":"","category":"section"},{"location":"howto/transducers/","page":"Writing transducers","title":"Writing transducers","text":"Transducers don't export public interface for implementing transducers (and reducible collections).  Let's import some handy ones:","category":"page"},{"location":"howto/transducers/","page":"Writing transducers","title":"Writing transducers","text":"using Transducers\nusing Transducers: Transducer, R_, next, inner, xform","category":"page"},{"location":"howto/transducers/#Stateless-transducer","page":"Writing transducers","title":"Stateless transducer","text":"","category":"section"},{"location":"howto/transducers/","page":"Writing transducers","title":"Writing transducers","text":"Let's write manually what opcompose(Filter(x -> x isa Int), Map(x -> x + 1)) would do:","category":"page"},{"location":"howto/transducers/","page":"Writing transducers","title":"Writing transducers","text":"struct AddOneIfInt <: Transducer end\n\nfunction Transducers.next(rf::R_{AddOneIfInt}, result, input)\n    if input isa Int","category":"page"},{"location":"howto/transducers/","page":"Writing transducers","title":"Writing transducers","text":"Output input + 1 is passed to the \"inner\" reducing step:","category":"page"},{"location":"howto/transducers/","page":"Writing transducers","title":"Writing transducers","text":"        next(inner(rf), result, input + 1)\n    else","category":"page"},{"location":"howto/transducers/","page":"Writing transducers","title":"Writing transducers","text":"Filtering out is done by \"doing nothing\"; return result-so-far as-is:","category":"page"},{"location":"howto/transducers/","page":"Writing transducers","title":"Writing transducers","text":"        result\n    end\nend","category":"page"},{"location":"howto/transducers/","page":"Writing transducers","title":"Writing transducers","text":"Ineed, for integer collection, it increments input by one:","category":"page"},{"location":"howto/transducers/","page":"Writing transducers","title":"Writing transducers","text":"addone_out1 = begin  # hide\ncollect(AddOneIfInt(), 1:5)\nend  # hide","category":"page"},{"location":"howto/transducers/","page":"Writing transducers","title":"Writing transducers","text":"Non integer elements are filtered out:","category":"page"},{"location":"howto/transducers/","page":"Writing transducers","title":"Writing transducers","text":"collect(AddOneIfInt(), Any[3, nothing, 2.0, missing, 5])","category":"page"},{"location":"howto/transducers/#Stateful-transducer","page":"Writing transducers","title":"Stateful transducer","text":"","category":"section"},{"location":"howto/transducers/","page":"Writing transducers","title":"Writing transducers","text":"AddOneIfInt is a stateless transducer which is very easy to implement.  A stateful transducer needs a bit more code.","category":"page"},{"location":"howto/transducers/","page":"Writing transducers","title":"Writing transducers","text":"using Transducers: start, complete, wrap, unwrap, wrapping\nusing Random","category":"page"},{"location":"howto/transducers/","page":"Writing transducers","title":"Writing transducers","text":"Let's define a transducer that spits out a random past element from the buffer:","category":"page"},{"location":"howto/transducers/","page":"Writing transducers","title":"Writing transducers","text":"struct RandomRecall <: Transducer\n    history::Int\n    seed::Int\nend\nRandomRecall() = RandomRecall(3, 0)\nnothing  # hide","category":"page"},{"location":"howto/transducers/","page":"Writing transducers","title":"Writing transducers","text":"A stateful transducer needs to implement Transducers.start to \"allocate\" its private state.  Here, the private state is a buffer and a random number generator state rng:","category":"page"},{"location":"howto/transducers/","page":"Writing transducers","title":"Writing transducers","text":"function Transducers.start(rf::R_{RandomRecall}, result)\n    buffer = []\n    rng = MersenneTwister(xform(rf).seed)\n    private_state = (buffer, rng)\n    return wrap(rf, private_state, start(inner(rf), result))\nend","category":"page"},{"location":"howto/transducers/","page":"Writing transducers","title":"Writing transducers","text":"Stateful transducer needs to unwrap its private state inside Transducers.next and then re-wrap it.  There is a helper function Transducers.wrapping does that with the do block:","category":"page"},{"location":"howto/transducers/","page":"Writing transducers","title":"Writing transducers","text":"function Transducers.next(rf::R_{RandomRecall}, result, input)\n    wrapping(rf, result) do (buffer, rng), iresult","category":"page"},{"location":"howto/transducers/","page":"Writing transducers","title":"Writing transducers","text":"Pickup a random element to be passed to the inner reducing function. Replace it with the new incoming one in the buffer:","category":"page"},{"location":"howto/transducers/","page":"Writing transducers","title":"Writing transducers","text":"        if length(buffer) < xform(rf).history\n            push!(buffer, input)\n            iinput = rand(rng, buffer)\n        else\n            i = rand(rng, 1:length(buffer))\n            iinput = buffer[i]\n            buffer[i] = input\n        end","category":"page"},{"location":"howto/transducers/","page":"Writing transducers","title":"Writing transducers","text":"Call the inner reducing function.  Note that iresult unwrapped by Transducers.wrapping must be passed to next:","category":"page"},{"location":"howto/transducers/","page":"Writing transducers","title":"Writing transducers","text":"        iresult = next(inner(rf), iresult, iinput)\n        return (buffer, rng), iresult\n    end\nend","category":"page"},{"location":"howto/transducers/","page":"Writing transducers","title":"Writing transducers","text":"Any transducer with custom Transducers.start must have a corresponding Transducers.complete.  It is responsible for unwrapping the result and call the complete for the inner reducing function.","category":"page"},{"location":"howto/transducers/","page":"Writing transducers","title":"Writing transducers","text":"function Transducers.complete(rf::R_{RandomRecall}, result)\n    _private_state, inner_result = unwrap(rf, result)\n    return complete(inner(rf), inner_result)\nend","category":"page"},{"location":"howto/transducers/","page":"Writing transducers","title":"Writing transducers","text":"Here is how it works:","category":"page"},{"location":"howto/transducers/","page":"Writing transducers","title":"Writing transducers","text":"recall_out1 = begin  # hide\ncollect(RandomRecall(), 1:5)\nend  # hide","category":"page"},{"location":"howto/transducers/","page":"Writing transducers","title":"Writing transducers","text":"Indeed, it picks up some random elements from the past elements. With slightly more complex transducer:","category":"page"},{"location":"howto/transducers/","page":"Writing transducers","title":"Writing transducers","text":"1:100 |> Filter(isodd) |> RandomRecall() |> Filter(x -> x > 10) |> Take(5) |> collect","category":"page"},{"location":"howto/transducers/","page":"Writing transducers","title":"Writing transducers","text":"Note that Transducers.complete can do more than unwrap and complete.  It is useful for, e.g., flushing the buffer.","category":"page"},{"location":"howto/transducers/","page":"Writing transducers","title":"Writing transducers","text":"function Transducers.complete(rf::R_{RandomRecall}, result)\n    (buffer, _), iresult = unwrap(rf, result)\n    for x in buffer","category":"page"},{"location":"howto/transducers/","page":"Writing transducers","title":"Writing transducers","text":"Note that inner next can be called more than one time inside next and complete:","category":"page"},{"location":"howto/transducers/","page":"Writing transducers","title":"Writing transducers","text":"        iresult = next(inner(rf), iresult, x)\n    end","category":"page"},{"location":"howto/transducers/","page":"Writing transducers","title":"Writing transducers","text":"complete for inner reducing function must be called exactly once:","category":"page"},{"location":"howto/transducers/","page":"Writing transducers","title":"Writing transducers","text":"    return complete(inner(rf), iresult)\nend","category":"page"},{"location":"howto/transducers/","page":"Writing transducers","title":"Writing transducers","text":"This then adds 3 (= RandomRecall().history) more elements to the output:","category":"page"},{"location":"howto/transducers/","page":"Writing transducers","title":"Writing transducers","text":"recall_out2 = begin  # hide\ncollect(RandomRecall(), 1:5)\nend  # hide","category":"page"},{"location":"howto/transducers/","page":"Writing transducers","title":"Writing transducers","text":"","category":"page"},{"location":"howto/transducers/","page":"Writing transducers","title":"Writing transducers","text":"This page was generated using Literate.jl.","category":"page"},{"location":"explanation/internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"explanation/internals/","page":"Internals","title":"Internals","text":"Modules = [Transducers]\nPublic = false\nFilter = Transducers.is_internal","category":"page"},{"location":"explanation/internals/#Transducers.DefaultInit","page":"Internals","title":"Transducers.DefaultInit","text":"DefaultInit(op)\n\nDefaultInit is like InitialValues.Init but strictly internal to Transducers.jl.  It is used for checking if the bottom reducing function is never called.\n\n\n\n\n\n","category":"constant"},{"location":"explanation/internals/#Transducers.AdHocXF","page":"Internals","title":"Transducers.AdHocXF","text":"AdHocXF(f, init, [onlast])\n\nExamples\n\njulia> using Transducers\n       using Transducers: AdHocXF, @next\n       using Setfield: @set!\n\njulia> flushlast(rf, result) = rf(@next(rf, result, result.state));\n\njulia> xf = AdHocXF(nothing, flushlast) do rf, result, input\n           m = match(r\"^name:(.*)\", input)\n           if m === nothing\n               push!(result.state.lines, input)\n               return result\n           else\n               chunk = result.state\n               @set! result.state = (name=strip(m.captures[1]), lines=String[])\n               push!(result.state.lines, input)\n               if chunk === nothing\n                   return result\n               else\n                   return rf(result, chunk)\n               end\n           end\n       end;\n\njulia> collect(xf, split(\"\"\"\n       name: Map\n       type: onetoone\n       name: Cat\n       type: expansive\n       name: Filter\n       type: contractive\n       name: Cat |> Filter\n       type: chaotic\n       \"\"\", \"\\n\"; keepempty=false))\n4-element Array{NamedTuple{(:name, :lines),Tuple{SubString{String},Array{String,1}}},1}:\n (name = \"Map\", lines = [\"name: Map\", \"type: onetoone\"])\n (name = \"Cat\", lines = [\"name: Cat\", \"type: expansive\"])\n (name = \"Filter\", lines = [\"name: Filter\", \"type: contractive\"])\n (name = \"Cat |> Filter\", lines = [\"name: Cat |> Filter\", \"type: chaotic\"])\n\n\n\n\n\n","category":"type"},{"location":"explanation/internals/#Transducers.NoAdjoint","page":"Internals","title":"Transducers.NoAdjoint","text":"Transducers.NoAdjoint(itr)\n\nBypass the optimization step by retransform.\n\n\n\n\n\n","category":"type"},{"location":"explanation/internals/#Transducers.ReducingFunctionTransform","page":"Internals","title":"Transducers.ReducingFunctionTransform","text":"ReducingFunctionTransform(xf)\n\nThe \"true\" transducer.\n\n\n\n\n\n","category":"type"},{"location":"explanation/internals/#Transducers.UseSIMD","page":"Internals","title":"Transducers.UseSIMD","text":"UseSIMD{ivdep}()\n\nTell the reducible to run the inner reducing function using @simd. The reducible can support it using @simd_if.\n\n\n\n\n\n","category":"type"},{"location":"explanation/internals/#Transducers._foldl_blockarray-Tuple{Any,Any,Any}","page":"Internals","title":"Transducers._foldl_blockarray","text":"_foldl_blockarray(rf, acc, coll::BlockArrays.BlockArray)\n\n\n\n\n\n","category":"method"},{"location":"explanation/internals/#Transducers._foldl_lazy_hcat-Tuple{Any,Any,AbstractArray{T,2} where T}","page":"Internals","title":"Transducers._foldl_lazy_hcat","text":"_foldl_lazy_hcat(rf, acc, coll::LazyArrays.Hcat)\n\n\n\n\n\n","category":"method"},{"location":"explanation/internals/#Transducers._foldl_lazy_vcat-Tuple{Any,Any,Any}","page":"Internals","title":"Transducers._foldl_lazy_vcat","text":"_foldl_lazy_vcat(rf, acc, coll::LazyArrays.Vcat)\n\n\n\n\n\n","category":"method"},{"location":"explanation/internals/#Transducers._set_joiner_value-Tuple{Any,Any}","page":"Internals","title":"Transducers._set_joiner_value","text":"_set_joiner_value(ps::PrivateState, x) :: PrivateState\n\nSet .state field of the PrivateState of the first \"unbalanced\" Joiner.  A Joiner matched with preceding Splitter would be treated as a regular reducing function node.  Thus, private state ps must have one more Joiner than Splitter.\n\n\n\n\n\n","category":"method"},{"location":"explanation/internals/#Transducers._unzip-Union{Tuple{Tuple{Vararg{Tuple{Vararg{Any,N}},N1} where N1}}, Tuple{N}} where N","page":"Internals","title":"Transducers._unzip","text":"_unzip(xs::Tuple)\n\nExamples\n\njulia> _unzip(((1, 2, 3), (4, 5, 6)))\n((1, 4), (2, 5), (3, 6))\n\n\n\n\n\n","category":"method"},{"location":"explanation/internals/#Transducers.air-Tuple{Any}","page":"Internals","title":"Transducers.air","text":"air.(broadcasting_expression) :: Broadcasted\n\nBroadcast without materialization.\n\nThe idea is taken from @dawbarton's _lazy function: https://discourse.julialang.org/t/19641/20.\n\n\n\n\n\n","category":"method"},{"location":"explanation/internals/#Transducers.combine-Tuple{Any,Any,Any}","page":"Internals","title":"Transducers.combine","text":"Transducers.combine(rf::R_{X}, state_left, state_right)\n\nThis is an optional interface for a transducer.  If transducer X is stateful (i.e., wrap is used in start), it has to be able to combine the private states to support fold functions that require an associative reducing function such as reduce. Typical implementation takes the following form:\n\nfunction combine(rf::R_{X}, a, b)\n    #   ,---- `ua` and `ub` are the private state of the transducer `X`\n    #  /  ,-- `ira` and `irb` are the states of inner reducing functions\n    # /  /\n    ua, ira = unwrap(rf, a)\n    ub, irb = unwrap(rf, b)\n    irc = combine(inner(rf), ira, irb)\n    uc = # somehow combine private states `ua` and `ub`\n    return wrap(rf, uc, irc)\nend\n\nSee ScanEmit, etc. for real-world examples.\n\n\n\n\n\n","category":"method"},{"location":"explanation/internals/#Transducers.extract_transducer-Tuple{Any}","page":"Internals","title":"Transducers.extract_transducer","text":"extract_transducer(foldable) -> (xf, foldable′)\n\n\"Reverse\" of eduction.\n\nExamples\n\njulia> using Transducers\n\njulia> double(x) = 2x;\n\njulia> xs = 1:10;\n\njulia> xf, foldable = Transducers.extract_transducer(double(x) for x in xs);\n\njulia> xf == Map(double)\ntrue\n\njulia> foldable == xs\ntrue\n\n\n\n\n\n","category":"method"},{"location":"explanation/internals/#Transducers.foldl_nocomplete-Tuple{Any,Any,Any}","page":"Internals","title":"Transducers.foldl_nocomplete","text":"foldl_nocomplete(rf, init, coll)\n\nCall __foldl__ without calling complete.\n\n\n\n\n\n","category":"method"},{"location":"explanation/internals/#Transducers.initialize-Tuple{Any,Any}","page":"Internals","title":"Transducers.initialize","text":"initialize(initializer, op) -> init\ninitialize(init, _) -> init\n\nReturn an initial value for op.  Throw an error if initializer (e.g., Init) creates unknown initial value.\n\nExamples\n\njulia> using Transducers\n       using Transducers: initialize\n\njulia> initialize(Init, +)\nInit(+)\n\njulia> initialize(123, +)\n123\n\njulia> unknown_op(x, y) = x + 2y;\n\njulia> initialize(Init, unknown_op)\nERROR: IdentityNotDefinedError: `init = Init` is specified but the identity element `Init(op)` is not defined for\n    op = unknown_op\n[...]\n\n\n\n\n\n","category":"method"},{"location":"explanation/internals/#Transducers.initvalue-Tuple{Any}","page":"Internals","title":"Transducers.initvalue","text":"initvalue(initializer::AbstractInitializer) -> init\ninitvalue(init) -> init\n\nMaterialize the initial value if the input is an AbstractInitializer. Return the input as-is if not.\n\n\n\n\n\n","category":"method"},{"location":"explanation/internals/#Transducers.issmall","page":"Internals","title":"Transducers.issmall","text":"Transducers.issmall(reducible, basesize) :: Bool\n\nCheck if reducible collection is considered small compared to basesize (an integer).  Fold functions such as reduce switches to sequential __foldl__ when issmall returns true.\n\nDefault implementation is amount(reducible) <= basesize.\n\n\n\n\n\n","category":"function"},{"location":"explanation/internals/#Transducers.maybe_usesimd-Tuple{Transducers.AbstractReduction,Union{Val{true}, Val{false}, Val{:ivdep}, Bool, Symbol}}","page":"Internals","title":"Transducers.maybe_usesimd","text":"maybe_usesimd(xform, simd)\n\nInsert UseSIMD to xform if appropriate.\n\nArguments\n\nxform::Transducer\nsimd: false, true, or :ivdep.\n\nExamples\n\njulia> using Transducers\n       using Transducers: maybe_usesimd\n\njulia> maybe_usesimd(reducingfunction(Map(identity), right), false)\nReduction(\n    Map(identity),\n    BottomRF(\n        Transducers.right))\n\njulia> maybe_usesimd(reducingfunction(Map(identity), right), true)\nReduction(\n    Transducers.UseSIMD{false}(),\n    Reduction(\n        Map(identity),\n        BottomRF(\n            Transducers.right)))\n\njulia> maybe_usesimd(reducingfunction(Cat(), right), true)\nReduction(\n    Cat(),\n    Reduction(\n        Transducers.UseSIMD{false}(),\n        BottomRF(\n            Transducers.right)))\n\njulia> maybe_usesimd(opcompose(Map(sin), Cat(), Map(cos))'(right), :ivdep)\nReduction(\n    Map(sin),\n    Reduction(\n        Cat(),\n        Reduction(\n            Transducers.UseSIMD{true}(),\n            Reduction(\n                Map(cos),\n                BottomRF(\n                    Transducers.right)))))\n\njulia> maybe_usesimd(\n           opcompose(Map(sin), Cat(), Map(cos), Cat(), Map(tan))'(right),\n           true,\n       )\nReduction(\n    Map(sin),\n    Reduction(\n        Cat(),\n        Reduction(\n            Map(cos),\n            Reduction(\n                Cat(),\n                Reduction(\n                    Transducers.UseSIMD{false}(),\n                    Reduction(\n                        Map(tan),\n                        BottomRF(\n                            Transducers.right)))))))\n\n\n\n\n\n","category":"method"},{"location":"explanation/internals/#Transducers.reform-Tuple{Transducers.Reduction,Any}","page":"Internals","title":"Transducers.reform","text":"reform(rf, f)\n\nReset \"bottom\" reducing function of rf to f.\n\n\n\n\n\n","category":"method"},{"location":"explanation/internals/#Transducers.retransform-Tuple{Any,Any}","page":"Internals","title":"Transducers.retransform","text":"Transducers.retransform(rf, itr) -> rf′, itr′\n\nExtract transformations in rf and itr and use the appropriate adjoint for better performance.\n\nExamples\n\njulia> using Transducers\n\njulia> double(x) = 2x;\n\njulia> itr0 = 1:10;\n\njulia> itr1 = (double(x) for x in itr0);\n\njulia> rf, itr2 = Transducers.retransform(+, itr1);\n\njulia> itr2 === itr0\ntrue\n\njulia> rf == reducingfunction(Map(double), +)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"explanation/internals/#Transducers.simple_transduce-NTuple{4,Any}","page":"Internals","title":"Transducers.simple_transduce","text":"simple_transduce(xform, step, init, coll)\n\nSimplified version of transduce.  For simple transducers Julia may be able to emit a good code.  This function exists only for performance tuning.\n\n\n\n\n\n","category":"method"},{"location":"explanation/internals/#Transducers.usesimd-Tuple{Transducers.AbstractReduction,Transducers.UseSIMD}","page":"Internals","title":"Transducers.usesimd","text":"usesimd(rf::Reduction, xfsimd::UseSIMD)\n\nWrap the inner-most loop of reducing function rf with xfsimd. xfsimd is inserted after the inner-most Cat if rf includes Cat.\n\n\n\n\n\n","category":"method"},{"location":"explanation/internals/#Transducers.@default_finaltype-Tuple{Any,Any}","page":"Internals","title":"Transducers.@default_finaltype","text":"@default_finaltype(xf::Transducer, coll)\n\nInfer the type of the object that would be fed into the second argument input of the bottom reducing function rf(acc, input).\n\nSee: Base.@default_eltype\n\n\n\n\n\n","category":"macro"},{"location":"explanation/internals/#Transducers.@simd_if-Tuple{Any,Any}","page":"Internals","title":"Transducers.@simd_if","text":"@simd_if rf for ... end\n\nWrap for-loop with @simd if the outer most transducer of the reducing function rf is UseSIMD.\n\n\n\n\n\n","category":"macro"},{"location":"explanation/internals/#Transducers.@~-Tuple{Any}","page":"Internals","title":"Transducers.@~","text":"(@~ broadcasting_expression) :: Broadcasted\n\n\n\n\n\n","category":"macro"},{"location":"explanation/internals/","page":"Internals","title":"Internals","text":"Modules = [Transducers.AutoObjectsReStacker]","category":"page"},{"location":"explanation/internals/#Transducers.AutoObjectsReStacker.restack","page":"Internals","title":"Transducers.AutoObjectsReStacker.restack","text":"restack(x) -> x\n\nAn identity function in the sense restack(x) === x.  However, it (recursively) re-construct x to beg the compiler to move everything in the stack.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"EditURL = \"https://github.com/JuliaFolds/Transducers.jl/blob/master/examples/tutorial_missings.jl\"","category":"page"},{"location":"tutorials/tutorial_missings/#Tutorial:-missing-value-handling","page":"Tutorial: Missing values","title":"Tutorial: missing value handling","text":"","category":"section"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"This tutorial illustrates the usage of Transducers.jl by stepping through various handling of missing values.","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"using Transducers","category":"page"},{"location":"tutorials/tutorial_missings/#Dot-product","page":"Tutorial: Missing values","title":"Dot product","text":"","category":"section"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"Here is a simple way to compute a dot product using foldl and MapSplat:","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"foldl(+, MapSplat(*), zip(1:3, 10:2:14))","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"Let's see what it does step by step.  First we create a \"printer\" transducer using the following function (see Map):","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"xf_printer(label) = Map() do x\n    println(label, \": \", x)\n    return x  # just return it as-is\nend\nnothing  # hide","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"This transducer just pass-through the input while printing its value (prefixed by a label).  Let's sandwich the previous MapSplat(*) with it:","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"foldl(\n    +,\n    zip(1:3, 10:2:14) |> xf_printer(\" input\") |> MapSplat(*) |> xf_printer(\"output\"),\n)\nflush(stdout)  # hide","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"You can see that the input tuple (1, 10) is splatted into function * by MapSplat which then outputs 10.  This is repeated for all inputs.","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"Perhaps unfortunately, this way of computing a dot product propagates any missing values contained in the input arrays to the result (which may actually be desired in certain cases).","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"xs = [1, missing, 3, 2]\nys = [10, 14, missing, 12]\nfoldl(+, MapSplat(*), zip(xs, ys))","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"However, it is very simple to ignore any missing values using OfType:","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"xf_mdot = opcompose(OfType(Tuple{Vararg{Number}}), MapSplat(*))\nfoldl(+, xf_mdot, zip(xs, ys))","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"Here, Tuple{Vararg{Number}} is a type that matches with a tuple of any length with numbers.  It does not match with a tuple if it has a missing.","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"@assert (1, 0.5) isa Tuple{Vararg{Number}}\n@assert (1, 0.5, 2im) isa Tuple{Vararg{Number}}\n@assert !((1, missing) isa Tuple{Vararg{Number}})","category":"page"},{"location":"tutorials/tutorial_missings/#Covariance","page":"Tutorial: Missing values","title":"Covariance","text":"","category":"section"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"Transducer xf_mdot above can also be used to compute the covariance.  First, we need the number of pairs of elements in xs and ys that both of them are not missing:","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"nonmissings = foldl(\n    right,\n    zip(xs, ys) |> OfType(Tuple{Vararg{Number}}) |> Count();\n    init = 0,\n)\nnonmissings  # hide","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"@assert nonmissings == 2  # hide","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"We do this by using Count and right.  Count ignores input and count the number of times the input is provided. Since OfType(Tuple{Vararg{Number}}) provides the inputs to the downstream transducer only if there is no missing values, this correctly counts the number of non-missing pairs.  Function right is simply defined as right(l, r) = r (and right(r) = r).  Thus, the whole foldl returns the last output of Count.  In case Count never gets called (i.e., there are no non-missing pairs), we pass init=0.","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"ans =  # hide\nfoldl(\n    right,\n    zip(Int[], Int[]) |> OfType(Tuple{Vararg{Number}}) |> Count();\n    init = 0,\n)\nans  # hide","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"@assert ans == 0  # hide","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"Finally, we have to pre-process the input to xf_mdot by subtracting the average.  It's easy to do with Map:","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"using Statistics: mean\n\nfunction xf_demean(xs, ys)\n    xmean = mean(skipmissing(xs))\n    ymean = mean(skipmissing(ys))\n    return Map(((x, y),) -> (x - xmean, y - ymean))\nend\n\nfoldl(+, zip(xs, ys) |> xf_demean(xs, ys) |> xf_mdot) / nonmissings","category":"page"},{"location":"tutorials/tutorial_missings/#Addition","page":"Tutorial: Missing values","title":"Addition","text":"","category":"section"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"How do we use transducers for vector-to-vector transformation?  Here is a function to calculate y = x + y while ignoring missing values in x.  First, mandatory input shape check:","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"function add_skipmissing!(ys, xs)\n    length(ys) == length(xs) || error(\"length(ys) != length(xs)\")\n    firstindex(ys) == 1 || error(\"firstindex(ys) != 1\")","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"For filtering out missing values from xs while tracking indices, we use Enumerate and Filter.  To iterate over the output of the transducer, foreach is used instead of foldl since mutating an array is better expressed as a side-effect than a fold.","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"    foreach(xs |> Enumerate() |> Filter(!(ismissing ∘ last))) do (i, xi)\n        @inbounds ys[i] += xi\n    end","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"We then return the mutated value to behave like the rest of Julia functions (push!, mul!, etc.):","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"    return ys\nend\nnothing  # hide","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"Example:","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"ans =  # hide\nadd_skipmissing!([100, 110, 120], [1, missing, 2])","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"@assert ans == [101, 110, 122]  # hide","category":"page"},{"location":"tutorials/tutorial_missings/#Vectorized-reduction","page":"Tutorial: Missing values","title":"Vectorized reduction","text":"","category":"section"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"foldl, mapfoldl, etc. in Base support dims argument. Transducers.jl does not support this argument as of writing. However, this can easily be emulated using eachcol, eachrow, or eachslice iterators in Base.","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"xs = [\n    0       missing 1       2\n    3       4       5       missing\n    missing 6       7       missing\n]\n\nfunction xf_sum_columns(prototype)\n    T = Base.nonmissingtype(eltype(prototype)) # subtract Missing from type\n    dims = size(prototype)\n    return Scan(add_skipmissing!, CopyInit(zeros(T, dims)))\nend\nnothing  # hide","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"We use CopyInit here to allocate the \"output array\" into which the columns are added by add_skipmissing!.","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"ans =  # hide\nfoldl(right, xf_sum_columns(xs[:, 1]), eachcol(xs))","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"@assert ans == [3, 12, 13]  # hide","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"Above computation returns the sum over each row without taking into account the relationship within a column.  Another possibly useful reduction is the sum of the columns with no missing values.  This can easily be done by prepending a filter:","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"ans =  # hide\nfoldl(\n    right,\n    eachcol(xs) |> Filter(x -> !any(ismissing, x)) |> xf_sum_columns(xs[:, 1]),\n)\nans  # hide","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"@assert ans == [1, 5, 7]  # hide","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"Note that above combination of Scan and right is redundant.  For example, we can simply pass add_skipmissing! to \"normal\" foldl:","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"ans =  # hide\nfoldl(add_skipmissing!, eachcol(xs), init=zeros(Int, size(xs, 1)))","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"@assert ans == [3, 12, 13]  # hide","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"However, packaging it as a transducer is sometimes useful as it can be composed with other transducers and \"bottom\" reducing function. For example, vectorized version of cumsum can easily obtained by composing it with append! (and then reshape after foldl):","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"result = foldl(\n    append!,\n    xf_sum_columns(xs[:, 1]),\n    eachcol(xs);\n    init = Int[],\n)\nans =  # hide\nreshape(result, (size(xs, 1), :))","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"@assert ans == [      # hide\n    0  0   1   3      # hide\n    3  7  12  12      # hide\n    0  6  13  13      # hide\n]                     # hide","category":"page"},{"location":"tutorials/tutorial_missings/#Argmax","page":"Tutorial: Missing values","title":"Argmax","text":"","category":"section"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"Another useful operation to do ignoring missing values is argmax/argmin.  It can be implemented using opcompose(Enumerate(), Filter(!(ismissing ∘ last))) (see also add_skipmissing! above) composed with ScanEmit.  We first need to define a function to be called by ScanEmit:","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"#                     ,--- current state\n#                     |\n#                     |              ,-- input\n#                     |              |\nfunction argmax_step((argmax, max), (index, value))\n    argmax, max = value > max ? (index, value) : (argmax, max)\n    return argmax, (argmax, max)\n    #       \\        \\\n    #        \\        \\__ next state\n    #         \\\n    #          \\__ output\nend\nnothing  # hide","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"This function is passed to ScanEmit with the initial state:","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"xf_argmax = opcompose(\n    Enumerate(),\n    Filter(!(ismissing ∘ last)),\n    ScanEmit(argmax_step, (0, typemin(Int))),\n    #                      |\n    #               initial state\n)\nnothing  # hide","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"As ScanEmit is one of the most complex (and powerful) transducer, it may require some comments on how above code works:","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"The state (argmax, max) is initialized to (0, typemin(Int)) in xf_argmax.  This is the first value passed to the first argument (argmax, max) of argmax_step.\nThe upstream transducer Enumerate() provides (index, value)-pair which becomes the input (the second argument) of argmax_step.\nFunction argmax_step must return a pair.  The first item becomes the output of ScanEmit.  In this case that's the index of the largest item seen so far.\nThe second item in the returned pair is fed back to argmax_step in the next call.","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"We have the argmax function by extracting the last output of xf_argmax:","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"foldl(right, xf_argmax, [1, 3, missing, 2])","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"Side note: We use typemin(Int) as the initial value of max for simplicity.  In practice, it should be typemin(eltype(input_array)).  A more generic solution is to special-case the first invocation by using a singleton like nothing.  Julia can handle small Union type such as this (see the next section).  Another solution is to use Init(>) from InitialValues.jl.","category":"page"},{"location":"tutorials/tutorial_missings/#Extrema","page":"Tutorial: Missing values","title":"Extrema","text":"","category":"section"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"Transducer xf_argmax in the previous section only outputs the index of the maximum element so far.  To output the maximum element as well, we can simply use Scan.  Also, while we are at it, let's support both argmax and argmin.  To this end, we parametrize the function passed to Scan by the comparison function > and <.  Another problem with xf_argmax is that it does not handle non-Int input types.  To properly handle different input types, we initialize Scan's state with nothing and special-case the first invocation to return the input as-is.  Following function argext_step takes the function > or < and return a function appropriate for Scan.","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"argext_step(should_update) =\n    (old, (index, value)) ->\n        if old === nothing || should_update(old[2], value)\n            (index, value)\n        else\n            old\n        end\nnothing  # hide\n\nxf_scanext(should_update) = Scan(argext_step(should_update), nothing)\nnothing  # hide","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"Passing < gives us the argmax transducer:","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"ans = # hide\nfoldl(\n    right,\n    [1.0, 3.0, missing, 2.0] |>\n        Enumerate() |>\n        OfType(Tuple{Integer,Number}) |>\n        xf_scanext(<),\n)","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"@assert ans === (2, 3.0) # hide","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"We now have transducers xf_scanext(<) and xf_scanext(>) for argmax and argmin, respectively.  We can compute them concurrently by Zip'ing them together:","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"xf_fullextrema = opcompose(\n    Enumerate(),\n    OfType(Tuple{Integer,Number}),\n    Zip(xf_scanext(>), xf_scanext(<)),\n)\n\nans = # hide\nfoldl(right, xf_fullextrema, [1.0, 3.0, -1.0, missing, 2.0])","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"@assert ans === ((3, -1.0), (2, 3.0))  # hide","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"This transducer produces a tuple ((argmin, min), (argmax, max)). To output only indices, append an appropriate Map:","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"xf_argextrema = opcompose(\n    xf_fullextrema,\n    Map() do ((argmin, min), (argmax, max))\n        (argmin, argmax)\n    end,\n)\n\nans = # hide\nfoldl(right, xf_argextrema, [1.0, 3.0, -1.0, missing, 2.0])","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"@assert ans === (3, 2)  # hide","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"","category":"page"},{"location":"tutorials/tutorial_missings/","page":"Tutorial: Missing values","title":"Tutorial: Missing values","text":"This page was generated using Literate.jl.","category":"page"},{"location":"howto/empty_result_handling/","page":"Empty result handling","title":"Empty result handling","text":"EditURL = \"https://github.com/JuliaFolds/Transducers.jl/blob/master/examples/empty_result_handling.jl\"","category":"page"},{"location":"howto/empty_result_handling/#Empty-result-handling","page":"Empty result handling","title":"Empty result handling","text":"","category":"section"},{"location":"howto/empty_result_handling/","page":"Empty result handling","title":"Empty result handling","text":"Transducible processes such as foldl try to do the right thing even when init is not given, if the given binary operation step is supported by InitialValues.jl (for example, +, *, &, and | are supported).  However, those functions throw an exception if the given collection is empty or filtered out by the transducers:","category":"page"},{"location":"howto/empty_result_handling/","page":"Empty result handling","title":"Empty result handling","text":"using Transducers\n\nadd1(x) = x + 1\n\nerr = try                                                            # hide\nfoldl(*, Map(add1), [])\ncatch err; err; end                                                  # hide\nshowerror(stdout, err)                                           # hide","category":"page"},{"location":"howto/empty_result_handling/","page":"Empty result handling","title":"Empty result handling","text":"To write robust code, it is recommended to use init if there is a reasonable default.  However, it may be useful to postpone \"materializing\" the result.  In such case, Init from InitialValues.jl can be used as a placeholder.","category":"page"},{"location":"howto/empty_result_handling/","page":"Empty result handling","title":"Empty result handling","text":"using InitialValues\n\nresult = foldl(*, Map(add1), [], init=Init)\nnothing                                                              # hide","category":"page"},{"location":"howto/empty_result_handling/","page":"Empty result handling","title":"Empty result handling","text":"init=Init is a short-hand notation of init=Init(*) (so that * does not have to be repeated):","category":"page"},{"location":"howto/empty_result_handling/","page":"Empty result handling","title":"Empty result handling","text":"@assert result === foldl(*, Map(add1), [], init=Init(*))","category":"page"},{"location":"howto/empty_result_handling/","page":"Empty result handling","title":"Empty result handling","text":"Note also that transduce can be used for passing init as a positional argument:","category":"page"},{"location":"howto/empty_result_handling/","page":"Empty result handling","title":"Empty result handling","text":"@assert result === transduce(Map(add1), Completing(*), Init, [])","category":"page"},{"location":"howto/empty_result_handling/","page":"Empty result handling","title":"Empty result handling","text":"Since the input collection [] is empty, result is Init(*) (which is an InitialValues.InitialValue):","category":"page"},{"location":"howto/empty_result_handling/","page":"Empty result handling","title":"Empty result handling","text":"using InitialValues: InitialValue\n@assert result::InitialValue === Init(*)","category":"page"},{"location":"howto/empty_result_handling/","page":"Empty result handling","title":"Empty result handling","text":"Init(*) is the left identity of *.  Multiplying it with any x from right returns x as-is.  This property may be useful, e.g., if result is known to be a scalar that is multiplied by a matrix just after the foldl:","category":"page"},{"location":"howto/empty_result_handling/","page":"Empty result handling","title":"Empty result handling","text":"result * ones(2, 2)","category":"page"},{"location":"howto/empty_result_handling/","page":"Empty result handling","title":"Empty result handling","text":"The identities Init(*) and Init(+) can be converted to numbers:","category":"page"},{"location":"howto/empty_result_handling/","page":"Empty result handling","title":"Empty result handling","text":"convert(Int, Init(*))","category":"page"},{"location":"howto/empty_result_handling/","page":"Empty result handling","title":"Empty result handling","text":"Init(*) can also be converted to a String:","category":"page"},{"location":"howto/empty_result_handling/","page":"Empty result handling","title":"Empty result handling","text":"convert(String, Init(*))","category":"page"},{"location":"howto/empty_result_handling/","page":"Empty result handling","title":"Empty result handling","text":"This means that no special code is required if the result is going to be stored into, e.g., an Array or a struct:","category":"page"},{"location":"howto/empty_result_handling/","page":"Empty result handling","title":"Empty result handling","text":"xs = [true, true]\nxs[1] = Init(+)\nxs","category":"page"},{"location":"howto/empty_result_handling/","page":"Empty result handling","title":"Empty result handling","text":"They can be converted into numbers also by using Integer:","category":"page"},{"location":"howto/empty_result_handling/","page":"Empty result handling","title":"Empty result handling","text":"Integer(Init(+))","category":"page"},{"location":"howto/empty_result_handling/","page":"Empty result handling","title":"Empty result handling","text":"or float:","category":"page"},{"location":"howto/empty_result_handling/","page":"Empty result handling","title":"Empty result handling","text":"float(Init(*))","category":"page"},{"location":"howto/empty_result_handling/","page":"Empty result handling","title":"Empty result handling","text":"","category":"page"},{"location":"howto/empty_result_handling/","page":"Empty result handling","title":"Empty result handling","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"EditURL = \"https://github.com/JuliaFolds/Transducers.jl/blob/master/examples/tutorial_parallel.jl\"","category":"page"},{"location":"tutorials/tutorial_parallel/#tutorial-parallel","page":"Tutorial: Parallelism","title":"Parallel processing tutorial","text":"","category":"section"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"See also: Overview of parallel processing in Transducers.jl","category":"page"},{"location":"tutorials/tutorial_parallel/#Quick-examples","page":"Tutorial: Parallelism","title":"Quick examples","text":"","category":"section"},{"location":"tutorials/tutorial_parallel/#Sequential-processing","page":"Tutorial: Parallelism","title":"Sequential processing","text":"","category":"section"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"using Transducers\n\nxs = randn(10_000_000)\nfoldl(+, Map(sin), xs)","category":"page"},{"location":"tutorials/tutorial_parallel/#Thread-based-parallelism","page":"Tutorial: Parallelism","title":"Thread-based parallelism","text":"","category":"section"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"Just replace foldl with reduce, to make use of multiple cores:","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"reduce(+, Map(sin), xs)","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"(In my laptop (4 core machine) I start seeing some speedup around length(xs) ≥ 100_000 for this transducer and reducing function.)","category":"page"},{"location":"tutorials/tutorial_parallel/#Process-based-parallelism","page":"Tutorial: Parallelism","title":"Process-based parallelism","text":"","category":"section"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"using Distributed\naddprocs(4)\n\ndreduce(+, Map(sin), xs)","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"(Note: there is likely no speedup for light-weight computation and large input data like this, when using dreduce.)","category":"page"},{"location":"tutorials/tutorial_parallel/#Parallel-processing-with-iterator-comprehensions","page":"Tutorial: Parallelism","title":"Parallel processing with iterator comprehensions","text":"","category":"section"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"You can also use eduction to use iterator comprehension with multi-thread reduce:","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"reduce(+, eduction(sin(x) for x in xs if abs(x) < 1); basesize = 500_000)","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"reduce(+, eduction(x * y for x in 1:3, y in 1:3))","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"You can omit eduction when using Transducers.jl-specific functions like tcollect/dcollect:","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"tcollect(sin(x) for x in xs if abs(x) < 1)","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"and tcopy/dcopy:","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"using StructArrays: StructVector\ntable = StructVector(a = [1, 2, 3], b = [5, 6, 7])\n\ntcopy((A = row.a + 1, B = row.b - 1) for row in table if isodd(row.a))","category":"page"},{"location":"tutorials/tutorial_parallel/#When-can-I-use-reduce-and-dreduce?","page":"Tutorial: Parallelism","title":"When can I use reduce and dreduce?","text":"","category":"section"},{"location":"tutorials/tutorial_parallel/#Requirement-1:-Associative-reducing-step-function","page":"Tutorial: Parallelism","title":"Requirement 1: Associative reducing step function","text":"","category":"section"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"Parallel reductions such as reduce and dreduce requires associative reducing step function. Recall that associativity means that the grouping of evaluations of binary operator does not matter:","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"op = +  # for example\na, b, c = 1, 2, 3  # for example\n\n@assert op(op(a, b), c) == op(a, op(b, c))","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"Given this property, computations like a + b + c + d can be done with different \"groupings\":","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"  a + b + c + d\n\n= ((a + b) + c) + d                +\n                                  / \\\n                                 +   d\n                                / \\\n                               +   c           foldl-like grouping\n                              / \\\n                             a   b\n\n= (a + b) + (c + d)                +\n                                  / \\\n                                 /   \\\n                                /     \\        reduce-like grouping\n                               +       +\n                              / \\     / \\\n                             a   b   c   d","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"Notice that, in the last grouping, computation of c + d does not have to wait for the result of a + b.  This is why we need associativity for parallel execution.","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"note: Note\nDo not confuse associativity with commutativity op(a, b) = op(b, a).  For example, matrix multiplication *(::Matrix, ::Matrix) is associative but not commutative in general. However, since reduce only requires associativity, it is valid to use reduce(*, xf, matrices).","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"As reducing function + is associative, it can be used with reduce (and dreduce):","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"reduce(+, Map(identity), 1:10; init = 0, basesize = 1)","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"and the result is the same as the sequential version:","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"foldl(+, Map(identity), 1:10; init = 0)","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"Note: basesize is for forcing reduce to avoid falling back to foldl for small length container such as 1:10.","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"On the other hand, binary function - is not associative.  Thus, reduce cannot be used instead of foldl (they produce different result):","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"reduce(-, Map(identity), 1:10; init = 0, basesize = 1)","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"foldl(+, Map(identity), 1:10; init = 0)","category":"page"},{"location":"tutorials/tutorial_parallel/#Requirement-2:-stateless-transducers","page":"Tutorial: Parallelism","title":"Requirement 2: stateless transducers","text":"","category":"section"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"Parallel reduction only work with stateless transducers Map, Filter, Cat, etc. and you will get an error when using stateful transducers such as Scan with reduce or dreduce:","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"err = try                                                            # hide\nreduce(+, Scan(+), 1:10; basesize = 1)\ncatch err; err; end                                                  # hide\nprint(stdout, \"ERRPR: \")                                         # hide\nshowerror(stdout, err)                                           # hide","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"Stateful transducers cannot be used with reduce because it is impossible to start processing input collection from the middle when the transducers need to know all previous elements (= stateful).","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"ScanEmit is a stateful transducer but it is assumed that it is used in a context that outputs can be treated as stateless (see: Splitting a string into words and counting them in parallel).","category":"page"},{"location":"tutorials/tutorial_parallel/#tutorial-parallel-collect","page":"Tutorial: Parallelism","title":"Example: parallel collect","text":"","category":"section"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"note: Note\nThis section explains the implementation ideas of parallel collect.  Pre-defined functions such as tcopy and dcopy should cover many use-cases.","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"Suppose (pretend) there is a compute-heavy transducer:","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"xf_compute = opcompose(Filter(!ismissing), Map(x -> x^2))\nnothing                                                              # hide","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"Transducers.jl supports applying this to an input container and then collecting the results into another container.  It can be done sequentially (collect, copy, etc.) and in parallel using threads (tcollect, tcopy) or using multiple processes (dcollect, dcopy).  For example:","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"xs = [abs(x) > 1 ? missing : x for x in randn(10_000)]\ny1 = collect(xf_compute, xs)\nnothing                                                              # hide","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"Doing this in parallel is as easy as using tcollect or dcollect. However, it is easy to do this manually, too:","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"using BangBang: append!!\n\nsingleton_vector(x) = [x]\ny2 = reduce(append!!, xs |> xf_compute |> Map(singleton_vector))\n@assert y1 == y2","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"This code illustrates the common pattern in parallel processing:","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"Put a result from the transducer in a \"singleton solution\". Here, it is [x].\nThen \"merge\" the (singleton) solution into the exsiting one. This is done by append!! in the above example.","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"To illustrate how reduce(append!!, xs |> ... |> Map(singleton_vector)) works, let's create a reducing function that records the arguments and returned values of append!!:","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"chan = Channel(Inf)\n\nfunction append_and_log!!(a, b)","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"As arguments and output may be mutated later, we use copy to record the snapshots of their values at this moment:","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"    a0 = copy(a)\n    b0 = copy(b)\n    c = append!!(a, b)\n    put!(chan, (a0, b0) => copy(c))\n    return c\nend\nnothing                                                              # hide","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"This function can be used instead of append!!.  Let's try simpler and shorter example.  This is equivalent to collect(1:4):","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"reduce(append_and_log!!, Map(singleton_vector), 1:4; basesize = 1, init = Union{}[])","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"(See below for why we are using init = Union{}[] here.)","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"Here is the list of arguments and returned value of append!! in this reduction:","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"records = Pair[]\nwhile isready(chan)\n    push!(records, take!(chan))\nend\nrecords","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"This recorded inputs and outputs of append!! show that its \"call tree\" is:","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"          [1,2,3,4] <------------- append!!([1,2], [3,4]) == [1,2,3,4]\n         /         \\\n    [1,2]           [3,4] <------- append!!([3], [4]) == [3, 4]\n   /     \\         /     \\\n [1]     [2]     [3]     [4] <---- append!!([], [4]) == [4]\n / \\     / \\     / \\     / \\\n[] [1]  [] [2]  [] [3]  [] [4]","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"Compare this to the example a + b + c + d above.","category":"page"},{"location":"tutorials/tutorial_parallel/#Optimization-and-generic-container-handling","page":"Tutorial: Parallelism","title":"Optimization and generic container handling","text":"","category":"section"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"Above usage of reduce is not quite efficient as singleton_vector allocates small objects in the heap.  Thus, it makes sense to use immutable objects for the singleton solutions so that Julia compiler can eliminate allocation of the intermediate singleton solutions. Here, this can be done by simply using SVectorinstead of singleton_vector:","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"using StaticArrays: SVector\n\nreduce(append!!, Map(SVector), 1:4)","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"However, notice that the return value is a static vector.  This is not ideal when the input collection is large.  The output collection type can be specified by init.  We can simply use init = Union{}[] in this case:","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"reduce(append!!, Map(SVector), 1:4; init = Union{}[])","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"Note that passing Vector to init of reduce is usually a wrong choice as it would mean that the same object is simultaneously mutated by different threads.  However, since Vector{Union{}} cannot have any element (as there is no object of type Union{}), using Union{}[] for init is an exception and it is a good way to indicate that output vector should use the \"smallest\" eltype required.  That is to say, append!! widens the vector \"just enough\" to fit the resulting elements.","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"For generic containers (e.g., various table types), use BangBang.Empty as the empty initial value.  This is useful for creating a table object such as DataFrame as the result of parallel processing:","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"using BangBang: Empty\nusing DataFrames: DataFrame\n\ny5 =                                                                 # hide\nreduce(append!!, Map(x -> SVector((a = x,))), 1:4; init = Empty(DataFrame))\nText(y5)                                                             # hide","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"It is slightly more tricky to make this approach work with other table types such as StructArrays and TypedTables.  Use tcopy or dcopy to work with generic containers.","category":"page"},{"location":"tutorials/tutorial_parallel/#Example:-ad-hoc-histogram","page":"Tutorial: Parallelism","title":"Example: ad-hoc histogram","text":"","category":"section"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"Following example counts number of occurrence of each leading digit in a distribution of random numbers.  First, let's create \"singleton solutions\" using transducers:","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"xs = 1_000_000 * randn(10_000_000)\ndicts1 = xs |> Map(abs) |> Filter(x -> x > 1) |> Map() do x\n    y = digits(floor(Int, x))[end]\n    Dict(y => 1)\nend\nnothing                                                              # hide","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"The singleton solutions can be merged using mergewith!(+, a, b). Conveniently, mergewith!(+) is the curried form (args...) -> mergewith!(+, args...):","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"using Compat: mergewith!  # not required in Julia >= 1.5\nrf! = mergewith!(+)\nrf!(Dict(:a => 1, :b => 2), Dict(:b => 3, :c => 4))","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"This is the form of binary function appropriate for foldl and reduce.","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"Note that it is OK to use in-place function mergewith! here because the dictionary passed as a is created by Dict(y => 1) and not shared by anyone.  When there is no such guarantee, passing init = OnInit(Dict{Int,Int}) is a good option.  Note that passing init = Dict{Int,Int}() to reduce is not correct as multiple tasks would share and try to mutate the same dictionary this way.","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"Let's try this with parallel reduce:","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"counts1 = reduce(mergewith!(+), dicts1)\nnothing                                                              # hide","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"Compare the result with foldl:","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"counts2 = foldl(mergewith!(+), dicts1)\n@assert counts1 == counts2","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"Hopefully the result is close to the Benford's law - Wikipedia:","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"let n = sum(values(counts1))\n    sort!(keys(counts1) .=> values(counts1) ./ n)\nend","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"Since we are counting only nine elements, it is actually better to use fixed-size container such as a tuple in this case:","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"dicts2 = xs |> Map(abs) |> Filter(x -> x > 1) |> Map() do x\n    y = digits(floor(Int, x))[end]\n    ntuple(i -> i == y, 9)\nend\n\ncounts3 = reduce(dicts2; init=ntuple(_ -> 0, 9)) do a, b\n    map(+, a, b)\nend\n@assert Dict(zip(1:9, counts3)) == counts1","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"Note that, as tuples are immutable, it is valid to pass it as init of reduce.","category":"page"},{"location":"tutorials/tutorial_parallel/#MicroCollections.jl-for-efficient-singleton-solution","page":"Tutorial: Parallelism","title":"MicroCollections.jl for efficient singleton solution","text":"","category":"section"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"When the appropriate \"bins\" are not known, mergewith!(+)-based strategy is more appropriate.  However, it is not ideal to allocate a small container like Dict(y => 1) in the heap for each iteration. MicroCollections.jl provides singleton (and empty) containers that are designed for this usecase.  The SingletonDict is \"upcast\" to the mutable Dict in the first invocation when merged with BangBang.jl functions:","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"using BangBang: mergewith!!\nusing MicroCollections: SingletonDict\n\nacc1 = mergewith!!(+, SingletonDict(:a => 1), SingletonDict(:b => 1))\nText(acc1)                                                           # hide","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"This dictionary is reused in the subsequent iterations:","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"acc2 = mergewith!!(+, acc1, SingletonDict(:b => 1))\nText(acc2)                                                           # hide","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"acc3 = mergewith!!(+, acc2, SingletonDict(:c => 1))\nText(acc3)                                                           # hide","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"The first result is reused across these iterations (within a single thread).","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"@assert acc1 === acc2 === acc3","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"Finally, Dicts from different threads are merged using the same function mergewith!!(+):","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"acc4 = Dict(:a => 5, :c => 3)  # from different thread\nacc5 = mergewith!!(+, acc3, acc4)\nText(acc5)                                                           # hide","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"Thus, dicts1 can be optimized simply by replacing Dict(y => 1) with SingletonDict(y => 1):","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"dicts3 = xs |> Map(abs) |> Filter(x -> x > 1) |> Map() do x\n    y = digits(floor(Int, x))[end]\n    SingletonDict(y => 1)\nend\n\ncounts4 = reduce(mergewith!!(+), dicts3)\n@assert counts1 == counts4","category":"page"},{"location":"tutorials/tutorial_parallel/#Example:-early-termination","page":"Tutorial: Parallelism","title":"Example: early termination","text":"","category":"section"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"Find the first element that is multiple of three:","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"reduce(ReduceIf(x -> x % 3 == 0), 1:10; init = nothing, basesize = 1) do _, x\n    # # Uncomment for demo:\n    # x == 3 ? sleep(0.1) : @show x  # give other tasks a chance to finish first\n    return x\nend","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"This snippet always returns 3, even though the reductions for c = 6 and c = 9 may finish first.","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"","category":"page"},{"location":"tutorials/tutorial_parallel/","page":"Tutorial: Parallelism","title":"Tutorial: Parallelism","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/manual/#Transducers-and-Transducible-processes","page":"Manual","title":"Transducers and Transducible processes","text":"","category":"section"},{"location":"reference/manual/","page":"Manual","title":"Manual","text":"Pages = [\"manual.md\"]\nOrder = [:function, :type]","category":"page"},{"location":"reference/manual/#Transducible-processes","page":"Manual","title":"Transducible processes","text":"","category":"section"},{"location":"reference/manual/","page":"Manual","title":"Manual","text":"transduce\nfoldl\nforeach\nreduce\ndreduce\ndtransduce\neduction\nmap!\ncopy!\ncopy\ntcopy\ndcopy\nappend!\nTransducers.append!!\ncollect\ntcollect\ndcollect\nChannel","category":"page"},{"location":"reference/manual/#Transducers.transduce","page":"Manual","title":"Transducers.transduce","text":"transduce(xf, step, init, reducible) :: Union{T, Reduced{T}}\n\nSee foldl.\n\n\n\n\n\n","category":"function"},{"location":"reference/manual/#Base.foldl","page":"Manual","title":"Base.foldl","text":"foldl(step, xf::Transducer, reducible; init, simd) :: T\nfoldl(step, ed::Eduction; init, simd) :: T\ntransduce(xf, step, init, reducible; simd) :: Union{T, Reduced{T}}\n\nCompose transducer xf with reducing step function step and reduce itr using it.\n\nnote: Note\ntransduce differs from foldl as Reduced{T} is returned if the transducer xf or step aborts the reduction and step is not automatically wrapped by Completing.\n\nThis API is modeled after transduce in Clojure.\n\nFor parallel versions, see reduce and dreduce.\n\nSee also: Empty result handling.\n\nArguments\n\nxf::Transducer: A transducer.\nstep: A callable which accepts 1 and 2 arguments.  If it only accepts 2 arguments, wrap it with Completing to \"add\" 1-argument form (i.e., complete protocol).\nreducible: A reducible object (array, dictionary, any iterator, etc.).\ninit: An initial value fed to the first argument to reducing step function step.  This argument can be omitted for well know binary operations like + or *.  Supported binary operations are listed in InitialValues.jl documentation.  When Init (not the result of Init, such as Init(*)) is given, it is automatically \"instantiated\" as Init(step) (where step is appropriately unwrapped if step is a Completing).  See Empty result handling in the manual for more information.\nsimd: If true or :ivdep, enable SIMD using Base.@simd.  If :ivdep, use @simd ivdep for ... end variant.  Read Julia manual of Base.@simd to understand when it is appropriate to use this option.  For example, simd = :ivdep must not be used with stateful transducer like Scan.  This option has no effect if false (default).\n\nExamples\n\njulia> using Transducers\n\njulia> foldl(Filter(isodd), 1:4, init=0.0) do state, input\n           @show state, input\n           state + input\n       end\n(state, input) = (0.0, 1)\n(state, input) = (1.0, 3)\n4.0\n\n\n\n\n\n","category":"function"},{"location":"reference/manual/#Base.foreach","page":"Manual","title":"Base.foreach","text":"foreach(eff, xf::Transducer, reducible; simd)\nforeach(eff, ed::Eduction; simd)\n\nFeed the results of xf processing items in reducible into a unary function eff.  This is useful when the primary computation at the bottom is the side-effect.  It is also equivalent to foreach(eff, eduction(xf, coll)).  Note that\n\nforeach(eduction(xf, coll)) do x\n    ...\nend\n\ncan be more efficient than\n\nfor x in eduction(xf, coll)\n    ...\nend\n\nas the former does not have to translate the transducer protocol to the iterator protocol.\n\nforeach supports all constructs in the native for loop as well as the enhancements [julia_issue_22891] to break with a value (break D(x) below) and append the else clause (E(x) below).\n\n[julia_issue_22891]: See also: break with value + loop else clauses (JuliaLang/julia#22891)\n\nThis native for loop\n\nans = for x in xs\n    A(x)\n    B(x) && break\n    C(x) && break D(x)\nelse\n    E(x)\nend\n\ncan be written as\n\nans = foreach(Map(identity), xs) do x\n    A(x)\n    B(x) && return reduced()\n    C(x) && return reduced(D(x))\n    x  # required for passing `x` to `E(x)` below\nend |> ifunreduced() do x\n    E(x)\nend\n\nSee: mapfoldl, reduced, ifunreduced.\n\ncompat: Transducers.jl 0.3\nforeach is changed to return what the do block (eff function) returns as-is in version 0.3.  This was required for supporting \"for-else\" (|> ifunreduced).  Previously, it only supported break-with-value and always applied unreduced before it returns.\n\nExamples\n\njulia> using Transducers\n\njulia> foreach(eduction(Filter(isodd), 1:4)) do input\n           @show input\n       end\ninput = 1\ninput = 3\n3\n\njulia> foreach(Filter(!ismissing), [1, missing, 2, 3]) do input\n           @show input\n           if iseven(input)\n               return reduced()\n           end\n       end\ninput = 1\ninput = 2\nReduced(nothing)\n\nIt is often useful to append |> unreduced to unwrap Reduced in the final result (note that |> here is the standard function application, not the transducer composition).\n\njulia> foreach(Filter(!ismissing), [1, missing, 2, 3]) do input\n           reduced(\"got $input\")\n       end |> unreduced\n\"got 1\"\n\nCombination of break-with-value and for-else is useful for triggering action after (e.g.) some kind of membership testing failed:\n\njulia> has2(xs) = foreach(Filter(!ismissing), xs) do input\n           input == 2 && reduced(true)\n       end |> ifunreduced() do input\n           @show input\n           false\n       end;\n\njulia> has2([1, missing, 2, 3])\ntrue\n\njulia> has2([1, missing])\ninput = false\nfalse\n\nHowever, note the output input = false in the last example.  This is because how && works in Julia\n\njulia> false && \"otherwise\"\nfalse\n\nThus, pure membership testing functions like has2 above can be written in a more concise manner:\n\njulia> simpler_has2(xs) = foreach(Filter(!ismissing), xs) do input\n           input == 2 && reduced(true)\n       end |> unreduced;\n\njulia> simpler_has2([1, missing, 2, 3])\ntrue\n\njulia> simpler_has2([1, missing])\nfalse\n\n\n\n\n\n","category":"function"},{"location":"reference/manual/#Base.reduce","page":"Manual","title":"Base.reduce","text":"reduce(step, xf, reducible; [init, simd, basesize, stoppable]) :: T\n\nThread-based parallelization of foldl.  The \"bottom\" reduction function step(::T, ::T) :: T must be associative and init must be its identity element.\n\nTransducers composing xf must be stateless (e.g., Map, Filter, Cat, etc.) except for ScanEmit. Note that Scan is not supported (although possible in theory).  Early termination requires Julia ≥ 1.3.\n\nUse tcollect or tcopy to collect results into a container.\n\nSee also: Parallel processing tutorial, foldl, dreduce.\n\nKeyword Arguments\n\nbasesize::Integer = amount(reducible) ÷ nthreads(): A size of chunk in reducible that is processed by each worker.  A smaller size may be required when:\ncomputation time for processing each item fluctuates a lot\ncomputation can be terminated by reduced or transducers using it, such as ReduceIf\nstoppable::Bool: [This option usually does not have to be set manually.]  Transducers.jl's reduce executed in the \"stoppable\" mode used for optimizing reduction with reduced has a slight overhead if reduced is not used.  This mode can be disabled by passing stoppable = false.  It is usually automatically detected and set appropriately.  Note that this option is purely for optimization and does not affect the result value.\nFor other keyword arguments, see foldl.\n\ncompat: Transducers.jl 0.4.23\nKeyword option stoppable requires at least Transducers.jl 0.4.23.\n\nExamples\n\njulia> using Transducers\n\njulia> reduce(+, 1:3 |> Map(exp) |> Map(log))\n6.0\n\njulia> using BangBang: append!!\n\njulia> reduce(append!!, Map(x -> 1:x), 1:2; basesize=1, init=Union{}[])\n3-element Array{Int64,1}:\n 1\n 1\n 2\n\n\n\n\n\n","category":"function"},{"location":"reference/manual/#Transducers.dreduce","page":"Manual","title":"Transducers.dreduce","text":"dreduce(step, xform::Transducer, array; [init, simd, basesize, threads_basesize, pool])\n\nDistributed.jl-based parallelization of foldl.  Input collection must be indexable.\n\nUnlike reduce, early termination by reduced is not supported yet.\n\nUse dcollect or dcopy to collect results into a container.\n\nSee also: Parallel processing tutorial, foldl, reduce.\n\ncompat: Transducers.jl 0.4.3\nNew in version 0.4.3.\n\nKeyword Arguments\n\npool::AbstractWorkerPool: Passed to Distributed.remotecall.\nbasesize::Integer = amount(array) ÷ nworkers(): A size of chunk in array that is processed by each worker.  A smaller size may be required when computation time for processing each item can fluctuate a lot.\nthreads_basesize::Integer = basesize ÷ nthreads(): A size of chunk in array that is processed by each task in each worker process. The default setting assumes that the number of threads used in all workers are the same.  For heterogeneous setup where each worker process has different number of threads, it may be required to use smaller threads_basesize and basesize to get a good performance.\nFor other keyword arguments, see foldl.\n\nExamples\n\njulia> using Transducers\n\njulia> dreduce(+, 1:3 |> Map(exp) |> Map(log))\n6.0\n\n\n\n\n\n","category":"function"},{"location":"reference/manual/#Transducers.dtransduce","page":"Manual","title":"Transducers.dtransduce","text":"dtransduce(xform::Transducer, step, init, array; [simd, basesize, threads_basesize, pool])\n\nSee dreduce and transduce.\n\n\n\n\n\n","category":"function"},{"location":"reference/manual/#Transducers.eduction","page":"Manual","title":"Transducers.eduction","text":"eduction(xf::Transducer, coll)\nxf(coll)\ncoll |> xf\n\nCreate a iterable and reducible object.\n\nIterable.\nReducible; i.e., it can be handled by transduce efficiently.\n\nThis API is modeled after eduction in Clojure.\n\nnote: Note\nEven though eduction returns an iterable, it is highly recommended to use the foldl-based method provided by Transducers.jl when the performance is important.\n\nExamples\n\njulia> using Transducers\n\njulia> for x in 1:1000 |> Filter(isodd) |> Take(3)  # slow\n           @show x\n       end\nx = 1\nx = 3\nx = 5\n\njulia> foreach(1:1000 |> Filter(isodd) |> Take(3)) do x  # better\n           @show x\n       end;\nx = 1\nx = 3\nx = 5\n\n\n\n\n\neduction(iterator::Iterators.Generator)\neduction(iterator::Iterators.Filter)\neduction(iterator::Iterators.Flatten)\n\nConvert an iterator to an eduction.  The iterators that are typically used in the generator comprehensions are supported.\n\ncompat: Transducers.jl 0.3\nNew in version 0.3.\n\nExamples\n\njulia> using Transducers\n\njulia> iter = (y for x in 1:10 if x % 2 == 0 for y in (x, x + 1));\n\njulia> ed = eduction(iter);\n\njulia> collect(iter) == collect(ed)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"reference/manual/#Base.map!","page":"Manual","title":"Base.map!","text":"map!(xf::Transducer, dest, src; simd)\n\nFeed src to transducer xf, storing the result in dest. Collections dest and src must have the same shape.  Transducer xf may contain filtering transducers.  If some entries src are skipped, the corresponding entries in dest will be unchanged. Transducer xf must not contain any expansive transducers such as MapCat.\n\nSee also copy!.\n\nExamples\n\njulia> using Transducers\n\njulia> xs = collect(1:5)\n       ys = zero(xs)\n       map!(Filter(isodd), ys, xs)\n5-element Array{Int64,1}:\n 1\n 0\n 3\n 0\n 5\n\njulia> ans === ys\ntrue\n\n\n\n\n\n","category":"function"},{"location":"reference/manual/#Base.copy!","page":"Manual","title":"Base.copy!","text":"copy!(xf::Transducer, dest, src)\n\nFeed src to transducer xf, storing the result in dest. Collections dest and src may have the same shape.  Source src must be iterable.  Destination dest must implement empty! and push!.\n\nSee also map!.\n\nExamples\n\njulia> using Transducers\n\njulia> copy!(opcompose(PartitionBy(x -> x ÷ 3), Map(sum)), Int[], 1:10)\n4-element Array{Int64,1}:\n  3\n 12\n 21\n 19\n\n\n\n\n\n","category":"function"},{"location":"reference/manual/#Base.copy","page":"Manual","title":"Base.copy","text":"copy(xf::Transducer, T, foldable) :: Union{T, Empty{T}}\ncopy(xf::Transducer, foldable::T) :: Union{T, Empty{T}}\ncopy([T,] eduction::Eduction) :: Union{T, Empty{T}}\n\nProcess foldable with a transducer xf and then create a container of type T filled with the result.  Return BangBang.Empty{T} if the transducer does not produce anything.  (This is because there is no consistent interface to create an empty container given its type and not all containers support creating an empty container.)\n\nFor parallel versions, see tcopy and dcopy.\n\ncompat: Transducers.jl 0.4.4\nNew in version 0.4.4.\n\ncompat: Transducers.jl 0.4.8\ncopy now accepts eductions.\n\nExamples\n\njulia> using Transducers\n       using BangBang: Empty\n\njulia> copy(Map(x -> x => x^2), Dict, 2:2)\nDict{Int64,Int64} with 1 entry:\n  2 => 4\n\njulia> @assert copy(Filter(_ -> false), Set, 1:1) === Empty(Set)\n\njulia> using TypedTables\n\njulia> @assert copy(Map(x -> (a=x, b=x^2)), Table, 1:1) == Table(a=[1], b=[1])\n\njulia> using StructArrays\n\njulia> @assert copy(Map(x -> (a=x, b=x^2)), StructVector, 1:1) == StructVector(a=[1], b=[1])\n\njulia> using DataFrames\n\njulia> @assert copy(\n           Map(x -> (A = x.a + 1, B = x.b + 1)),\n           DataFrame(a = [1], b = [2]),\n       ) == DataFrame(A = [2], B = [3])\n\n\n\n\n\n","category":"function"},{"location":"reference/manual/#Transducers.tcopy","page":"Manual","title":"Transducers.tcopy","text":"tcopy(xf::Transducer, T, reducible; basesize) :: Union{T, Empty{T}}\ntcopy(xf::Transducer, reducible::T; basesize) :: Union{T, Empty{T}}\ntcopy([T,] itr; basesize) :: Union{T, Empty{T}}\n\nThread-based parallel version of copy. Keyword arguments are passed to reduce.\n\nSee also: Parallel processing tutorial (especially Example: parallel collect).\n\ncompat: Transducers.jl 0.4.5\nNew in version 0.4.5.\n\ncompat: Transducers.jl 0.4.8\ntcopy now accepts iterator comprehensions and eductions.\n\nExamples\n\njulia> using Transducers\n\njulia> tcopy(Map(x -> x => x^2), Dict, 2:2)\nDict{Int64,Int64} with 1 entry:\n  2 => 4\n\njulia> using TypedTables\n\njulia> @assert tcopy(Map(x -> (a=x,)), Table, 1:1) == Table(a=[1])\n\njulia> using StructArrays\n\njulia> @assert tcopy(Map(x -> (a=x,)), StructVector, 1:1) == StructVector(a=[1])\n\ntcopy works with iterator comprehensions and eductions (unlike copy, there is no need for manual conversion with eduction):\n\njulia> table = StructVector(a = [1, 2, 3], b = [5, 6, 7]);\n\njulia> @assert tcopy(\n           (A = row.a + 1, B = row.b - 1) for row in table if isodd(row.a)\n       ) == StructVector(A = [2, 4], B = [4, 6])\n\njulia> @assert tcopy(\n           DataFrame,\n           (A = row.a + 1, B = row.b - 1) for row in table if isodd(row.a)\n       ) == DataFrame(A = [2, 4], B = [4, 6])\n\njulia> @assert table |>\n           Filter(row -> isodd(row.a)) |> Map(row -> (A = row.a + 1, B = row.b - 1)) |>\n           tcopy == StructVector(A = [2, 4], B = [4, 6])\n\nIf you have Cat or MapCat at the end of the transducer, consider using reduce directly:\n\njulia> using Transducers\n       using DataFrames\n\njulia> @assert tcopy(\n           DataFrame,\n           1:2 |> Map(x -> DataFrame(a = [x])) |> MapCat(eachrow);\n           basesize = 1,\n       ) == DataFrame(a = [1, 2])\n\njulia> using BangBang: Empty, append!!\n\njulia> @assert reduce(\n           append!!,\n           Map(x -> DataFrame(a = [x])),\n           1:2;\n           basesize = 1,\n           # init = Empty(DataFrame),\n       ) == DataFrame(a = [1, 2])\n\nNote that above snippet assumes that it is OK to mutate the dataframe returned by the transducer.  Use init = Empty(DataFrame) if this is not the case.\n\nThis approach of using reduce works with other containers; e.g., with TypedTables.Table:\n\njulia> using TypedTables\n\njulia> @assert reduce(\n           append!!,\n           Map(x -> Table(a = [x])),\n           1:2;\n           basesize = 1,\n           # init = Empty(Table),\n       ) == Table(a = [1, 2])\n\n\n\n\n\n","category":"function"},{"location":"reference/manual/#Transducers.dcopy","page":"Manual","title":"Transducers.dcopy","text":"dcopy(xf::Transducer, T, reducible; [basesize, threads_basesize]) :: Union{T, Empty{T}}\ndcopy(xf::Transducer, reducible::T; [basesize, threads_basesize]) :: Union{T, Empty{T}}\ndcopy([T,] itr; [basesize, threads_basesize]) :: Union{T, Empty{T}}\n\nDistributed.jl-based parallel version of copy.  Keyword arguments are passed to dreduce.  For examples, see tcopy.\n\nSee also: Parallel processing tutorial (especially Example: parallel collect).\n\ncompat: Transducers.jl 0.4.5\nNew in version 0.4.5.\n\ncompat: Transducers.jl 0.4.8\ndcopy now accepts iterator comprehensions and eductions.\n\n\n\n\n\n","category":"function"},{"location":"reference/manual/#Base.append!","page":"Manual","title":"Base.append!","text":"append!(xf::Transducer, dest, src) -> dest\n\nThis API is modeled after into in Clojure.\n\nwarning: Warning\nThe performance of append!(dest, src::Eduction) is poor. Use append!! instead if two-argument form is preferred.\n\nExamples\n\njulia> using Transducers\n\njulia> append!(Drop(2), [-1, -2], 1:5)\n5-element Array{Int64,1}:\n -1\n -2\n  3\n  4\n  5\n\n\n\n\n\n","category":"function"},{"location":"reference/manual/#BangBang.append!!","page":"Manual","title":"BangBang.append!!","text":"BangBang.append!!(xf::Transducer, dest, src) -> dest′\nBangBang.append!!(dest, src::Eduction) -> dest′\n\nMutate-or-widen version of append!.\n\ncompat: Transducers.jl 0.4.4\nNew in version 0.4.4.\n\ncompat: Transducers.jl 0.4.37\nPerformance optimization for append!!(dest, src::Eduction) requires version 0.4.37.\n\nExamples\n\njulia> using Transducers, BangBang\n\njulia> append!!(opcompose(Drop(2), Map(x -> x + 0.0)), [-1, -2], 1:5)\n5-element Array{Float64,1}:\n -1.0\n -2.0\n  3.0\n  4.0\n  5.0\n\n\n\n\n\n","category":"function"},{"location":"reference/manual/#Base.collect","page":"Manual","title":"Base.collect","text":"collect(xf::Transducer, itr) :: Vector\ncollect(ed::Eduction) :: Vector\n\nProcess an iterable itr using a transducer xf and collect the result into a Vector.\n\nFor parallel versions, see tcollect and dcollect.\n\ncompat: Transducers.jl 0.4.8\ncollect now accepts eductions.\n\nExamples\n\njulia> using Transducers\n\njulia> collect(Interpose(missing), 1:3)\n5-element Array{Union{Missing, Int64},1}:\n 1\n  missing\n 2\n  missing\n 3\n\n\n\n\n\n","category":"function"},{"location":"reference/manual/#Transducers.tcollect","page":"Manual","title":"Transducers.tcollect","text":"tcollect(xf::Transducer, reducible; basesize) :: Union{Vector, Empty{Vector}}\ntcollect(itr; basesize) :: Union{Vector, Empty{Vector}}\n\nThread-based parallel version of collect. This is just a short-hand notation of tcopy(xf, Vector, reducible). Use tcopy to get a container other than a Vector.\n\nSee also: Parallel processing tutorial (especially Example: parallel collect).\n\ncompat: Transducers.jl 0.4.5\nNew in version 0.4.5.\n\ncompat: Transducers.jl 0.4.8\ntcollect now accepts iterator comprehensions and eductions.\n\nExamples\n\njulia> using Transducers\n\njulia> tcollect(Map(x -> x^2), 1:2)\n2-element Array{Int64,1}:\n 1\n 4\n\njulia> tcollect(x^2 for x in 1:2)\n2-element Array{Int64,1}:\n 1\n 4\n\n\n\n\n\n","category":"function"},{"location":"reference/manual/#Transducers.dcollect","page":"Manual","title":"Transducers.dcollect","text":"dcollect(xf::Transducer, reducible; [basesize, threads_basesize]) :: Union{Vector, Empty{Vector}}\ndcollect(itr; [basesize, threads_basesize]) :: Union{Vector, Empty{Vector}}\n\nDistributed.jl-based parallel version of collect. This is just a short-hand notation of dcopy(xf, Vector, reducible). Use dcopy to get a container other than a Vector.\n\nSee also: Parallel processing tutorial (especially Example: parallel collect).\n\ncompat: Transducers.jl 0.4.5\nNew in version 0.4.5.\n\ncompat: Transducers.jl 0.4.8\ndcollect now accepts iterator comprehensions and eductions.\n\n\n\n\n\n","category":"function"},{"location":"reference/manual/#Base.Channel","page":"Manual","title":"Base.Channel","text":"Channel(xf::Transducer, itr; kwargs...)\nChannel(ed::Eduction; kwargs...)\n\nPipe items from an iterable itr processed by the transducer xf through a channel.  Channel(xf, itr) and Channel(eduction(xf, itr)) are equivalent.  Note that itr itself can be a Channel.\n\nKeyword arguments are passed to Channel(function; kwargs...).\n\nExamples\n\njulia> using Transducers\n\njulia> ch1 = Channel(Filter(isodd), 1:5);\n\njulia> ch2 = Channel(Map(x -> 2x - 1), ch1);\n\njulia> ed = eduction(Map(x -> 1:x), ch2);\n\njulia> ch3 = Channel(Cat(), ed);\n\njulia> foreach(PartitionBy(isequal(1)), ch3) do input\n           @show input\n       end;\ninput = [1, 1]\ninput = [2, 3, 4, 5]\ninput = [1]\ninput = [2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\n\n\n","category":"type"},{"location":"reference/manual/#Experimental-transducible-processes","page":"Manual","title":"Experimental transducible processes","text":"","category":"section"},{"location":"reference/manual/","page":"Manual","title":"Manual","text":"Transducers.channel_unordered\nTransducers.append_unordered!","category":"page"},{"location":"reference/manual/#Transducers.channel_unordered","page":"Manual","title":"Transducers.channel_unordered","text":"channel_unordered(xf, input; eltype, size, ntasks, basesize) :: Channel{eltype}\nchannel_unordered(itr; eltype, size, ntasks, basesize) :: Channel{eltype}\n\nProvide elements in input processed by a transducer xf through a Channel.\n\nUnary method channel_unordered(itr) produces a Channel that provides elements in the input iterator itr with possibly different order.  Iterator comprehensions and eductions can be passed as the input itr.\n\nUse append_unordered! to send outputs to an existing channel.\n\ncompat: Transducers.jl 0.4.8\nNew in version 0.4.8.\n\ncompat: Transducers.jl 0.4.9\nUnary method channel_unordered(itr) requires Transducers.jl 0.4.9.\n\nwarning: Warning\nThis API is experimental.  Backward incompatible change, including the removal of this API, is more likely to occur than other parts of this package.\n\nKeyword Arguments\n\neltype::Type: element type of returned channel\nsize: The size of Channel. A non-negative Int or Inf.\nntasks::Int: Number of concurrent tasks.  Default to Threads.nthreads().\nbasesize: The \"batch size\" of the processing; i.e., the number of elements to be processed in a single task.  Default to 1.\n\nExamples\n\njulia> using Transducers: Map, channel_unordered\n\njulia> sort!(collect(channel_unordered(Map(x -> x + 1), 1:3)))\n3-element Array{Any,1}:\n 2\n 3\n 4\n\njulia> sort!(collect(channel_unordered(x + 1 for x in 1:3 if isodd(x))))\n2-element Array{Any,1}:\n 2\n 4\n\n\n\n\n\n","category":"function"},{"location":"reference/manual/#Transducers.append_unordered!","page":"Manual","title":"Transducers.append_unordered!","text":"append_unordered!(output, xf, input; ntasks, basesize)\nappend_unordered!(output, itr; ntasks, basesize)\n\nProcess input elements through a transducer xf and then push! them into output in undefined order.\n\nBinary method append_unordered!(output, itr) is like append!(output, itr) but without order guarantee.  Iterator comprehensions and eductions can be passed as the input itr.\n\noutput (typically a Channel) must implement thread-safe push!(output, x) method.\n\nSee also channel_unordered.\n\ncompat: Transducers.jl 0.4.8\nNew in version 0.4.8.\n\ncompat: Transducers.jl 0.4.9\nBinary method append_unordered!(output, itr) requires Transducers.jl 0.4.9.\n\nwarning: Warning\nThis API is experimental.  Backward incompatible change, including the removal of this API, is more likely to occur than other parts of this package.\n\nExamples\n\njulia> using Transducers: Map, append_unordered!\n\njulia> input = Channel(Map(identity), 1:3);\n\njulia> output = Channel{Int}(0);\n\njulia> task = @async try\n           append_unordered!(output, Map(x -> x + 1), input)\n       finally\n           close(output)\n       end;\n\njulia> sort!(collect(output))\n3-element Array{Int64,1}:\n 2\n 3\n 4\n\njulia> input = Channel(Map(identity), 1:3);\n\njulia> output = Channel{Int}(0);\n\njulia> task = @async try\n           append_unordered!(output, (y for x in input if isodd(x) for y in 1:x))\n       finally\n           close(output)\n       end;\n\njulia> sort!(collect(output))\n4-element Array{Int64,1}:\n 1\n 1\n 2\n 3\n\n\n\n\n\n","category":"function"},{"location":"reference/manual/#Transducers","page":"Manual","title":"Transducers","text":"","category":"section"},{"location":"reference/manual/","page":"Manual","title":"Manual","text":"Transducers.Transducer\nBase.:∘\nBase.adjoint","category":"page"},{"location":"reference/manual/#Transducers.Transducer","page":"Manual","title":"Transducers.Transducer","text":"Transducer\n\nThe abstract type for transducers.\n\nA transducer xf can be used as both iterator transformation xf(itr) and reducing function transformation xf'(rf).\n\nSee also adjoint for xf'(rf).\n\ncompat: Transducers.jl 0.4.39\nThe call overload xf(rf) requires Transducers.jl 0.4.39 or later.\n\nnote: Note\nThe call overload xf(rf) requires Julia 1.3 or later. For older Julia versions, use eduction.\n\nExamples\n\njulia> using Transducers\n\njulia> xs = Map(inv)(2:2:4)\n2-element StepRange{Int64,Int64} |>\n    Map(inv)\n\njulia> collect(xs)\n2-element Array{Float64,1}:\n 0.5\n 0.25\n\njulia> rf = Map(inv)'(+)\nReduction(\n    Map(inv),\n    BottomRF(\n        +))\n\njulia> rf(1, 4)  # +(1, inv(4))\n1.25\n\n\n\n\n\n","category":"type"},{"location":"reference/manual/#Base.:∘","page":"Manual","title":"Base.:∘","text":"f ⨟ g\ng ∘ f\nopcompose(f, g)\ncompose(g, f)\n\nComposition of transducers.\n\ncompat: Transducers.jl 0.4.39\nTransducers.jl 0.4.39 or later is required for composing transducers with ∘ and other operators and functions derived from it.Transducers written as f |> g |> h in previous versions of Transducers.jl can now be written as f ⨟ g ⨟ h (in Julia 1.5 or later) or opcompose(f, g, h).\n\nnote: Note\n\"op\" in opcompose does not stand for operator; it stands for opposite.\n\n\n\n\n\n","category":"function"},{"location":"reference/manual/#Base.adjoint","page":"Manual","title":"Base.adjoint","text":"xf'\n\nxf'(rf₁) is a shortcut for calling reducingfunction(xf, rf₁).\n\nMore precisely, adjoint xf′ of a transducer xf is a reducing function transform rf₁ -> rf₂.  That is to say, xf' a function that maps a reducing function rf₁ to another reducing function rf₂.\n\nExamples\n\njulia> using Transducers\n\njulia> y = Map(inv)'(+)(10, 2)\n10.5\n\njulia> y == +(10, inv(2))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"reference/manual/","page":"Manual","title":"Manual","text":"Modules = [Transducers]\nPrivate = false\nFilter = Transducers.is_transducer_type","category":"page"},{"location":"reference/manual/#Transducers.Broadcasting","page":"Manual","title":"Transducers.Broadcasting","text":"Broadcasting()\n\nBroadcast inner reducing function over elements in the input.  Roughly speaking, it transforms the inner reducing function op to op′(a, b) = op.(a, b).  However, it has a better memory usage and better initial value handling.\n\nIf the input is an array, the array created at the first iteration is reused if it can hold the element types of subsequent iterations. Otherwise, the array type is widen as needed.\n\nIf init passed to the fold function is a lazy \"initializer\" object such as OnInit, it is initialized independently for each item in the first input array.  This makes using Broadcasting for (possibly) in-place functions safe.\n\ncompat: Transducers.jl 0.4.32\nNew in version 0.4.32.\n\nnote: Note\nBroadcasting transducer is not supported in Julia 1.0.\n\nExamples\n\njulia> using Transducers\n\njulia> foldl(+, Broadcasting(), [[1, 2], [3, 4], 5])\n2-element Array{Int64,1}:\n  9\n 11\n\njulia> foldl(+, Broadcasting(), [(0,), [1], [2.0], [3 + 0im]])\n1-element Array{Complex{Float64},1}:\n 6.0 + 0.0im\n\njulia> foldl(\n           *,\n           [[[1], [10, 100]], [[2], [20, 200]], [[3], [30, 300]]] |>\n               Broadcasting() |> Broadcasting(),\n       )\n2-element Array{Array{Int64,1},1}:\n [6]\n [6000, 6000000]\n\nWhen processing nested data structure (e.g., array-of-arrays) and mutating accumulator in-place, be careful with sharing the accumulators with each processing of items in the input.  For example, this is a bad example:\n\njulia> add!(a, b) = a .+= b;\n\njulia> foldl(add!, Broadcasting(), [[[1], [2, 3]], [[4, 5], 6]];\n             init = Ref([0, 0]))\n2-element Array{Array{Int64,1},1}:\n [13, 15]\n [13, 15]\n\njulia> ans[1] === ans[2]  # they are the same object\ntrue\n\nUse OnInit to initialize a new array with each item in the input:\n\njulia> foldl(add!, Broadcasting(), [[[1], [2, 3]], [[4, 5], 6]];\n             init = OnInit(() -> [0, 0]))\n2-element Array{Array{Int64,1},1}:\n [5, 6]\n [8, 9]\n\njulia> ans == [\n           add!(add!([0, 0], [1]), [4, 5]),\n           add!(add!([0, 0], [2, 3]), 6),\n       ]\ntrue\n\n\n\n\n\n","category":"type"},{"location":"reference/manual/#Transducers.Cat","page":"Manual","title":"Transducers.Cat","text":"Cat()\n\nConcatenate/flatten nested iterators.\n\nThis API is modeled after cat in Clojure.\n\nExamples\n\njulia> using Transducers\n\njulia> collect(Cat(), [[1, 2], [3], [4, 5]]) == 1:5\ntrue\n\n\n\n\n\n","category":"type"},{"location":"reference/manual/#Transducers.Count","page":"Manual","title":"Transducers.Count","text":"Count([start[, step]])\n\nGenerate a sequence start, start + step, start + step + step, and so on.\n\nNote that input is ignored.  To use the input in the downstream reduction steps, use Zip.\n\nstart defaults to 1 and step defaults to oneunit(start).\n\nSee also: Iterators.countfrom. Enumerate\n\nExamples\n\njulia> using Transducers\n\njulia> collect(Zip(Map(identity), Count()), -3:-1)\n3-element Array{Tuple{Int64,Int64},1}:\n (-3, 1)\n (-2, 2)\n (-1, 3)\n\njulia> using Dates\n\njulia> 1:3 |> Zip(Map(identity), Count(Day(1))) |> MapSplat(*) |> collect ==\n       [Day(1), Day(4), Day(9)]\ntrue\n\n\n\n\n\n","category":"type"},{"location":"reference/manual/#Transducers.Dedupe","page":"Manual","title":"Transducers.Dedupe","text":"Dedupe()\n\nDe-duplicate consecutive items.\n\nThis API is modeled after dedupe in Clojure.\n\nExamples\n\njulia> using Transducers\n\njulia> collect(Dedupe(), [1, 1, 2, 1, 3, 3, 2])\n5-element Array{Int64,1}:\n 1\n 2\n 1\n 3\n 2\n\n\n\n\n\n","category":"type"},{"location":"reference/manual/#Transducers.Drop","page":"Manual","title":"Transducers.Drop","text":"Drop(n)\n\nDrop first n items.\n\nThis API is modeled after drop in Clojure.\n\nExamples\n\njulia> using Transducers\n\njulia> 1:5 |> Drop(3) |> collect\n2-element Array{Int64,1}:\n 4\n 5\n\n\n\n\n\n","category":"type"},{"location":"reference/manual/#Transducers.DropLast","page":"Manual","title":"Transducers.DropLast","text":"DropLast(n)\n\nDrop last n items.\n\nThis API is modeled after drop-last in Clojure.\n\nExamples\n\njulia> using Transducers\n\njulia> 1:5 |> DropLast(2) |> collect\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\njulia> 1:1 |> DropLast(2) |> collect == []\ntrue\n\njulia> 1:0 |> DropLast(2) |> collect == []\ntrue\n\n\n\n\n\n","category":"type"},{"location":"reference/manual/#Transducers.DropWhile","page":"Manual","title":"Transducers.DropWhile","text":"DropWhile(pred)\n\nDrop items while pred returns true consecutively.  It becomes a no-op after pred returns a false.\n\nThis API is modeled after drop-while in Clojure.\n\nExamples\n\njulia> using Transducers\n\njulia> collect(DropWhile(x -> x < 3), [1:5; 1:2])\n5-element Array{Int64,1}:\n 3\n 4\n 5\n 1\n 2\n\n\n\n\n\n","category":"type"},{"location":"reference/manual/#Transducers.Enumerate","page":"Manual","title":"Transducers.Enumerate","text":"Enumerate([start[, step]])\n\nTransducer variant of Base.enumerate. The start and step arguments are optional and have the same meaning as in Count.\n\nExamples\n\njulia> using Transducers\n\njulia> collect(Enumerate(), [\"A\", \"B\", \"C\"])\n3-element Array{Tuple{Int64,String},1}:\n (1, \"A\")\n (2, \"B\")\n (3, \"C\")\n\njulia> start=2; step=3;\n\njulia> collect(Enumerate(start, step), [\"A\", \"B\", \"C\"])\n3-element Array{Tuple{Int64,String},1}:\n (2, \"A\")\n (5, \"B\")\n (8, \"C\")\n\n\n\n\n\n\n","category":"type"},{"location":"reference/manual/#Transducers.Filter","page":"Manual","title":"Transducers.Filter","text":"Filter(pred)\n\nSkip items for which pred is evaluated to false.\n\nThis API is modeled after filter in Clojure.\n\nExamples\n\njulia> using Transducers\n\njulia> 1:3 |> Filter(iseven) |> collect\n1-element Array{Int64,1}:\n 2\n\n\n\n\n\n","category":"type"},{"location":"reference/manual/#Transducers.FlagFirst","page":"Manual","title":"Transducers.FlagFirst","text":"FlagFirst()\n\nOutput (isfirst, input) where isfirst::Bool is true only for the first iteration and input is the original input.\n\nSee also: IterTools.flagfirst\n\nExamples\n\njulia> using Transducers\n\njulia> collect(FlagFirst(), 1:3)\n3-element Array{Tuple{Bool,Int64},1}:\n (1, 1)\n (0, 2)\n (0, 3)\n\n\n\n\n\n","category":"type"},{"location":"reference/manual/#Transducers.GroupBy","page":"Manual","title":"Transducers.GroupBy","text":"GroupBy(key, rf, [init])\nGroupBy(key, xf::Transducer, [step = right, [init]])\n\nGroup the input stream by a function key and then fan-out each group of key-value pairs to the reducing function rf.\n\nFor example, if GroupBy is used as in:\n\nxs |> Map(upstream) |> GroupBy(key, rf, init) |> Map(downstream)\n\nthen the \"function signatures\" would be:\n\nupstream(_) :: V\nkey(::V) :: K\nrf(::Y, ::Pair{K, V}) ::Y\ndownstream(::Dict{K, Y})\n\nThat is to say,\n\nOuput of the upstream is fed into the function key that produces the group key (of type K).\nFor each new group key, a new transducible process is started with the initial state init :: Y.  Pass OnInit or CopyInit object to init for creating a dedicated (possibly mutable) state for each group.\nAfter one \"nested\" reducing function rf is called, the intermediate result dictionary (of type Dict{K, Y}) accumulating the current and all preceding results is then fed into the downstream.\n\nSee also groupreduce in SplitApplyCombine.jl.\n\ncompat: Transducers.jl 0.3\nNew in version 0.3.\n\nExamples\n\njulia> using Transducers\n       using BangBang  # for `push!!`\n\njulia> foldl(right, GroupBy(string, Map(last), push!!), [1, 2, 1, 2, 3])\nTransducers.GroupByViewDict{String,Array{Int64,1},…} with 3 entries:\n  \"1\" => [1, 1]\n  \"2\" => [2, 2]\n  \"3\" => [3]\n\nNote that the reduction stops if one of the group returns a reduced.  This can be used, for example, to find if there is a group with a sum grater than 3 and stop the computation as soon as it is find:\n\njulia> result = transduce(\n           GroupBy(\n               string,\n               opcompose(Map(last), Scan(+), ReduceIf(x -> x > 3)),\n           ),\n           right,\n           nothing,\n           [1, 2, 1, 2, 3],\n       );\n\njulia> result isa Reduced\ntrue\n\njulia> unreduced(result)\nTransducers.GroupByViewDict{String,Any,…} with 2 entries:\n  \"1\" => 2\n  \"2\" => 4\n\n\n\n\n\n","category":"type"},{"location":"reference/manual/#Transducers.Interpose","page":"Manual","title":"Transducers.Interpose","text":"Interpose(sep)\n\nInterleave input items with a sep.\n\nThis API is modeled after interpose in Clojure.\n\nExamples\n\njulia> using Transducers\n\njulia> collect(Interpose(missing), 1:3)\n5-element Array{Union{Missing, Int64},1}:\n 1\n  missing\n 2\n  missing\n 3\n\n\n\n\n\n","category":"type"},{"location":"reference/manual/#Transducers.Iterated","page":"Manual","title":"Transducers.Iterated","text":"Iterated(f, init)\n\nGenerate a sequence init, f(init), f(f(init)), f(f(f(init))), and so on.\n\nNote that input is ignored.  To use the input in the downstream reduction steps, use Zip.\n\nPass OnInit or CopyInit object to init for creating a dedicated (possibly mutable) state for each fold.\n\nSee also: Scan, ScanEmit.\n\nThe idea is taken from IterTools.iterated\n\nExamples\n\njulia> using Transducers\n\njulia> collect(Iterated(x -> 2x, 1), 1:5)\n5-element Array{Int64,1}:\n  1\n  2\n  4\n  8\n 16\n\njulia> collect(Zip(Map(identity), Iterated(x -> 2x, 1)), 1:5)\n5-element Array{Tuple{Int64,Int64},1}:\n (1, 1)\n (2, 2)\n (3, 4)\n (4, 8)\n (5, 16)\n\n\n\n\n\n","category":"type"},{"location":"reference/manual/#Transducers.Keep","page":"Manual","title":"Transducers.Keep","text":"Keep(f)\n\nPass non-nothing output of f to the inner reducing step.\n\nThis API is modeled after keep in Clojure.\n\nExamples\n\njulia> using Transducers\n\njulia> xf = Keep() do x\n           if x < 3\n               x + 1\n           end\n       end;\n\njulia> collect(xf, 1:5)\n2-element Array{Int64,1}:\n 2\n 3\n\n\n\n\n\n","category":"type"},{"location":"reference/manual/#Transducers.Map","page":"Manual","title":"Transducers.Map","text":"Map(f)\n\nApply unary function f to each input and pass the result to the inner reducing step.\n\nThis API is modeled after map in Clojure.\n\nExamples\n\njulia> using Transducers\n\njulia> collect(Map(x -> 2x), 1:3)\n3-element Array{Int64,1}:\n 2\n 4\n 6\n\n\n\n\n\n","category":"type"},{"location":"reference/manual/#Transducers.MapCat","page":"Manual","title":"Transducers.MapCat","text":"MapCat(f)\n\nConcatenate output of f which is expected to return an iterable.\n\nThis API is modeled after mapcat in Clojure.\n\nExamples\n\njulia> using Transducers\n\njulia> collect(MapCat(x -> 1:x), 1:3)\n6-element Array{Int64,1}:\n 1\n 1\n 2\n 1\n 2\n 3\n\n\n\n\n\n","category":"type"},{"location":"reference/manual/#Transducers.MapSplat","page":"Manual","title":"Transducers.MapSplat","text":"MapSplat(f)\n\nLike Map(f) but calls f(input...) for each input and then pass the result to the inner reducing step.\n\nExamples\n\njulia> using Transducers\n\njulia> collect(MapSplat(*), zip(1:3, 10:10:30))\n3-element Array{Int64,1}:\n 10\n 40\n 90\n\n\n\n\n\n","category":"type"},{"location":"reference/manual/#Transducers.NotA","page":"Manual","title":"Transducers.NotA","text":"NotA(T)\n\nSkip items of type T.  Unlike Filter(!ismissing), downstream transducers can have a correct type information for NotA(Missing).\n\nSee also: OfType\n\nExamples\n\njulia> using Transducers\n\njulia> [1, missing, 2] |> NotA(Missing) |> collect\n2-element Array{Int64,1}:\n 1\n 2\n\n\n\n\n\n","category":"type"},{"location":"reference/manual/#Transducers.OfType","page":"Manual","title":"Transducers.OfType","text":"OfType(T)\n\nInclude only items of type T.\n\nSee also: NotA\n\nExamples\n\njulia> using Transducers\n\njulia> [1, missing, 2] |> OfType(Int) |> collect\n2-element Array{Int64,1}:\n 1\n 2\n\n\n\n\n\n","category":"type"},{"location":"reference/manual/#Transducers.Partition","page":"Manual","title":"Transducers.Partition","text":"Partition(size, step = size, flush = false)\nPartition(size; step = size, flush = false)\n\nSliding window of width size and interval step.\n\nwarning: Warning\nThe vector passed to the inner reducing function is valid only during its immediate reduction step.  It must be reduced immediately or copied.\n\nThis API is modeled after partition-all in Clojure.\n\nExamples\n\njulia> using Transducers\n\njulia> 1:8 |> Partition(3) |> Map(copy) |> collect\n2-element Array{Array{Int64,1},1}:\n [1, 2, 3]\n [4, 5, 6]\n\njulia> 1:8 |> Partition(3; flush=true) |> Map(copy) |> collect\n3-element Array{Array{Int64,1},1}:\n [1, 2, 3]\n [4, 5, 6]\n [7, 8]\n\njulia> 1:8 |> Partition(3; step=1) |> Map(copy) |> collect\n6-element Array{Array{Int64,1},1}:\n [1, 2, 3]\n [2, 3, 4]\n [3, 4, 5]\n [4, 5, 6]\n [5, 6, 7]\n [6, 7, 8]\n\n\n\n\n\n","category":"type"},{"location":"reference/manual/#Transducers.PartitionBy","page":"Manual","title":"Transducers.PartitionBy","text":"PartitionBy(f)\n\nGroup input sequence into chunks in which f returns a same value consecutively.\n\nwarning: Warning\nThe vector passed to the inner reducing function is valid only during its immediate reduction step.  It must be reduced immediately or copied.\n\nThis API is modeled after partition-by in Clojure.\n\nExamples\n\njulia> using Transducers\n\njulia> 1:9 |> PartitionBy(x -> (x + 1) ÷ 3) |> Map(copy) |> collect\n4-element Array{Array{Int64,1},1}:\n [1]\n [2, 3, 4]\n [5, 6, 7]\n [8, 9]\n\n\n\n\n\n","category":"type"},{"location":"reference/manual/#Transducers.ReduceIf","page":"Manual","title":"Transducers.ReduceIf","text":"ReduceIf(pred)\n\nStop fold when pred(x) returns true for the output x of the upstream transducer.\n\nExamples\n\njulia> using Transducers\n\njulia> foldl(right, ReduceIf(x -> x == 3), 1:10)\n3\n\n\n\n\n\n","category":"type"},{"location":"reference/manual/#Transducers.Replace","page":"Manual","title":"Transducers.Replace","text":"Replace(assoc)\n\nReplace each input with the value in the associative container assoc (e.g., a dictionary, array, string) if it matches with a key/index. Otherwise output the input as-is.\n\nThis API is modeled after replace in Clojure.\n\nExamples\n\njulia> using Transducers\n\njulia> collect(Replace(Dict('a' => 'A')), \"abc\")\n3-element Array{Char,1}:\n 'A'\n 'b'\n 'c'\n\njulia> collect(Replace([:a, :b, :c]), 0:4)\n5-element Array{Any,1}:\n 0\n  :a\n  :b\n  :c\n 4\n\njulia> collect(Replace(\"abc\"), 0:4)\n5-element Array{Any,1}:\n 0\n  'a'\n  'b'\n  'c'\n 4\n\n\n\n\n\n","category":"type"},{"location":"reference/manual/#Transducers.Scan","page":"Manual","title":"Transducers.Scan","text":"Scan(f, [init = Init])\n\nAccumulate input with binary function f and pass the accumulated result so far to the inner reduction step.\n\nThe inner reducing step receives the sequence y₁, y₂, y₃, ..., yₙ, ... when the sequence x₁, x₂, x₃, ..., xₙ, ... is fed to Scan(f).\n\ny₁ = f(init, x₁)\ny₂ = f(y₁, x₂)\ny₃ = f(y₂, x₃)\n...\nyₙ = f(yₙ₋₁, xₙ)\n\nThis is a generalized version of the prefix sum also known as cumulative sum, inclusive scan, or scan.\n\nNote that the associativity of f is not required when the transducer is used in a process that gurantee an order, such as foldl.\n\nUnless f is a function with known identity element such as +, *, min, max, and append!, the initial state init must be provided.\n\nPass OnInit or CopyInit object to init for creating a dedicated (possibly mutable) state for each fold.\n\nSee also: ScanEmit, Iterated.\n\nExamples\n\njulia> using Transducers\n\njulia> collect(Scan(*), 1:3)\n3-element Array{Int64,1}:\n 1\n 2\n 6\n\njulia> 1:3 |> Map(x -> x + im) |> Scan(*) |> collect\n3-element Array{Complex{Int64},1}:\n 1 + 1im\n 1 + 3im\n 0 + 10im\n\njulia> collect(Scan(*, 10), 1:3)\n3-element Array{Int64,1}:\n 10\n 20\n 60\n\n\n\n\n\n","category":"type"},{"location":"reference/manual/#Transducers.ScanEmit","page":"Manual","title":"Transducers.ScanEmit","text":"ScanEmit(f, init[, onlast])\n\nAccumulate input x with a function f with the call signature (u, x) -> (y, u) and pass the result y to the inner reduction step.\n\nThe inner reducing step receives the sequence y₁, y₂, y₃, ..., yₙ, ... computed as follows\n\nu₀ = init\ny₁, u₁ = f(u₀, x₁)\ny₂, u₂ = f(u₁, x₂)\ny₃, u₃ = f(u₂, x₃)\n...\nyₙ, uₙ = f(uₙ₋₁, xₙ)\n...\nyₒₒ = onlast(uₒₒ)\n\nwhen the sequence x₁, x₂, x₃, ..., xₙ, ... is fed to ScanEmit(f).\n\nPass OnInit or CopyInit object to init for creating a dedicated (possibly mutable) state for each fold.\n\nSee also: Scan, Iterated.\n\nExamples\n\njulia> using Transducers\n\njulia> collect(ScanEmit(tuple, 0), 1:3)\n3-element Array{Int64,1}:\n 0\n 1\n 2\n\n\n\n\n\n","category":"type"},{"location":"reference/manual/#Transducers.TCat","page":"Manual","title":"Transducers.TCat","text":"TCat(basesize::Integer)\n\nThreaded version of Cat (concatenate/flatten).\n\nTo use this transducer, all the downstream (inner) transducers must be stateless (or of type ScanEmit) and the reducing function must be associative.  See also: Parallel processing tutorial.\n\nNote that the upstream (outer) transducers need not to be stateless as long as it is called with non-parallel reduction such as foldl and collect.\n\nExamples\n\njulia> using Transducers\n\njulia> 1:3 |> Map(x -> 1:x) |> TCat(1) |> tcollect\n6-element Array{Int64,1}:\n 1\n 1\n 2\n 1\n 2\n 3\n\njulia> 1:3 |> Scan(+) |> Map(x -> 1:x) |> TCat(1) |> collect\n10-element Array{Int64,1}:\n 1\n 1\n 2\n 3\n 1\n 2\n 3\n 4\n 5\n 6\n\n\n\n\n\n","category":"type"},{"location":"reference/manual/#Transducers.Take","page":"Manual","title":"Transducers.Take","text":"Take(n)\n\nTake n items from the input sequence.\n\nThis API is modeled after take in Clojure.\n\nExamples\n\njulia> using Transducers\n\njulia> 1:10 |> Take(2) |> collect\n2-element Array{Int64,1}:\n 1\n 2\n\njulia> 1:2 |> Take(5) |> collect\n2-element Array{Int64,1}:\n 1\n 2\n\n\n\n\n\n","category":"type"},{"location":"reference/manual/#Transducers.TakeLast","page":"Manual","title":"Transducers.TakeLast","text":"TakeLast(n)\n\nTake last n items from the input sequence.\n\nExamples\n\njulia> using Transducers\n\njulia> 1:10 |> TakeLast(2) |> collect\n2-element Array{Int64,1}:\n  9\n 10\n\njulia> 1:2 |> TakeLast(5) |> collect\n2-element Array{Int64,1}:\n 1\n 2\n\n\n\n\n\n","category":"type"},{"location":"reference/manual/#Transducers.TakeNth","page":"Manual","title":"Transducers.TakeNth","text":"TakeNth(n)\n\nOutput every n item to the inner reducing step.\n\nThis API is modeled after take-nth in Clojure.\n\nExamples\n\njulia> using Transducers\n\njulia> 1:9 |> TakeNth(3) |> collect\n3-element Array{Int64,1}:\n 1\n 4\n 7\n\n\n\n\n\n","category":"type"},{"location":"reference/manual/#Transducers.TakeWhile","page":"Manual","title":"Transducers.TakeWhile","text":"TakeWhile(pred)\n\nTake items while pred returns true.  Abort the reduction when pred returns false for the first time.\n\nThis API is modeled after take-while in Clojure.\n\nExamples\n\njulia> using Transducers\n\njulia> [1, 2, 3, 1, 2] |> TakeWhile(x -> x < 3) |> collect\n2-element Array{Int64,1}:\n 1\n 2\n\n\n\n\n\n","category":"type"},{"location":"reference/manual/#Transducers.Unique","page":"Manual","title":"Transducers.Unique","text":"Unique(by = identity)\n\nPass only unseen item to the inner reducing step.\n\nThe item is distinguished by the output of function by when given.\n\nThis API is modeled after distinct in Clojure.\n\ncompat: Transducers.jl 0.4.2\nNew in version 0.4.2.\n\nExamples\n\njulia> using Transducers\n\njulia> [1, 1, 2, -1, 3, 3, 2] |> Unique() |> collect\n4-element Array{Int64,1}:\n  1\n  2\n -1\n  3\n\njulia> [1, 1, 2, -1, 3, 3, 2] |> Unique(x -> x^2) |> collect\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\n\n\n\n\n","category":"type"},{"location":"reference/manual/#Transducers.Zip-Tuple","page":"Manual","title":"Transducers.Zip","text":"Zip(xforms...)\n\nZip outputs of transducers xforms in a tuple and pass it to the inner reduction step.\n\nwarning: Warning\nHead transducers drive tail transducers.  Be careful when using it with transducers other than Map, especially the contractive ones like PartitionBy and the expansive ones like MapCat.\n\nExamples\n\njulia> using Transducers\n\njulia> collect(Zip(Map(identity), Map(x -> 10x), Map(x -> 100x)), 1:3)\n3-element Array{Tuple{Int64,Int64,Int64},1}:\n (1, 10, 100)\n (2, 20, 200)\n (3, 30, 300)\n\n\n\n\n\n","category":"method"},{"location":"reference/manual/#Experimental-transducers","page":"Manual","title":"Experimental transducers","text":"","category":"section"},{"location":"reference/manual/","page":"Manual","title":"Manual","text":"Transducers.ZipSource\nTransducers.GetIndex\nTransducers.SetIndex\nTransducers.Inject","category":"page"},{"location":"reference/manual/#Transducers.ZipSource","page":"Manual","title":"Transducers.ZipSource","text":"ZipSource(xform::Transducer)\n\nBranch input into two \"flows\", inject one into xform and then merge (zip) the output of xform with the original (source) input.\n\nwarning: Warning\nThis API is experimental.  Backward incompatible change, including the removal of this API, is more likely to occur than other parts of this package.\n\nTo illustrate how it works, consider the following usage\n\ncollection |> xf0 |> ZipSource(xf1) |> xf2\n\nwhere xf0, xf1, and xf2 are some transducers.  Schematically, the output yn from xfn flows as follows:\n\nxf0      xf1                       xf2\n---- y0 ------ y1 ---.-- (y0, y1) ----->\n      |              |\n       `-------------'\n\nExamples\n\njulia> using Transducers\n       using Transducers: ZipSource\n\njulia> collect(ZipSource(opcompose(Filter(isodd), Map(x -> x + 1))), 1:5)\n3-element Array{Tuple{Int64,Int64},1}:\n (1, 2)\n (3, 4)\n (5, 6)\n\n\n\n\n\n","category":"type"},{"location":"reference/manual/#Transducers.GetIndex","page":"Manual","title":"Transducers.GetIndex","text":"GetIndex(array)\nGetIndex{inbounds}(array)\n\nTransform an integer input i to array[i].\n\nwarning: Warning\nThis API is experimental.  Backward incompatible change, including the removal of this API, is more likely to occur than other parts of this package.\n\nExamples\n\njulia> using Transducers\n       using Transducers: GetIndex\n\njulia> collect(GetIndex(1:10), [2, 3, 4])\n3-element Array{Int64,1}:\n 2\n 3\n 4\n\njulia> collect(GetIndex{true}(1:10), [2, 3, 4])\n3-element Array{Int64,1}:\n 2\n 3\n 4\n\n\n\n\n\n","category":"type"},{"location":"reference/manual/#Transducers.SetIndex","page":"Manual","title":"Transducers.SetIndex","text":"SetIndex(array)\nSetIndex{inbounds}(array)\n\nPerform array[i] = v for each input pair (i, v).\n\nwarning: Warning\nThis API is experimental.  Backward incompatible change, including the removal of this API, is more likely to occur than other parts of this package.\n\nExamples\n\njulia> using Transducers\n       using Transducers: SetIndex\n\njulia> ys = zeros(3);\n\njulia> foldl(first ∘ tuple, SetIndex(ys), [(1, 11.1), (3, 33.3)], init=nothing)\n\njulia> ys\n3-element Array{Float64,1}:\n 11.1\n  0.0\n 33.3\n\n\n\n\n\n","category":"type"},{"location":"reference/manual/#Transducers.Inject","page":"Manual","title":"Transducers.Inject","text":"Inject(iterator)\n\nInject the output from iterator to the stream processed by the inner reduction step.\n\nwarning: Warning\nThis API is experimental.  Backward incompatible change, including the removal of this API, is more likely to occur than other parts of this package.\n\nExamples\n\njulia> using Transducers\n       using Transducers: Inject\n\njulia> collect(Inject(Iterators.cycle(\"hello\")), 1:8)\n8-element Array{Tuple{Int64,Char},1}:\n (1, 'h')\n (2, 'e')\n (3, 'l')\n (4, 'l')\n (5, 'o')\n (6, 'h')\n (7, 'e')\n (8, 'l')\n\njulia> collect(Inject(Iterators.repeated([1 2])), 1:4)\n4-element Array{Tuple{Int64,Array{Int64,2}},1}:\n (1, [1 2])\n (2, [1 2])\n (3, [1 2])\n (4, [1 2])\n\njulia> collect(Inject(Iterators.product(1:2, 3:5)), 1:100)\n6-element Array{Tuple{Int64,Tuple{Int64,Int64}},1}:\n (1, (1, 3))\n (2, (2, 3))\n (3, (1, 4))\n (4, (2, 4))\n (5, (1, 5))\n (6, (2, 5))\n\n\n\n\n\n","category":"type"},{"location":"reference/manual/#combinators","page":"Manual","title":"Other reducing function combinators","text":"","category":"section"},{"location":"reference/manual/","page":"Manual","title":"Manual","text":"Transducers.TeeRF\nTransducers.ProductRF","category":"page"},{"location":"reference/manual/#Transducers.TeeRF","page":"Manual","title":"Transducers.TeeRF","text":"TeeRF(reducing_functions::Tuple)\nTeeRF(reducing_functions...)\n\nCombine multiple reducing functions into a new reducing function that \"multicast\" the input to multiple reducing functions.\n\nRoughly speaking, TeeRF(op₁, op₂, ..., opₙ) is equivalent to\n\n((a₁, a₂, ..., aₙ), x) -> (op₁(a₁, x), op₂(a₂, x), ..., opₙ(aₙ, x))\n\nFor combine, it behaves like ProductRF.\n\ncompat: Transducers.jl 0.4.32\nNew in version 0.4.32.\n\nExamples\n\njulia> using Transducers\n\njulia> extrema′(xs, xf = Map(identity)) = foldl(TeeRF(min, max), xf, xs);\n\njulia> extrema′([5, 2, 6, 8, 3])\n(2, 8)\n\nNote that the input is considered empty unless all reducing functions call their bottom reducing functions.  Specify init to obain results even when the input collection is empty or all filtered out.\n\njulia> filtering_max = Filter(isodd)'(max);\n\njulia> foldl(TeeRF(min, filtering_max), Map(identity), [5, 2, 6, 8, 3])\n(2, 5)\n\njulia> foldl(TeeRF(min, filtering_max), Map(identity), 2:2:8)\nERROR: EmptyResultError: ...\n\njulia> foldl(TeeRF(min, filtering_max), Map(identity), 2:2:8; init = Init)\n(2, Init(max))\n\n\n\n\n\n","category":"type"},{"location":"reference/manual/#Transducers.ProductRF","page":"Manual","title":"Transducers.ProductRF","text":"ProductRF(reducing_functions::Tuple)\nProductRF(reducing_functions...)\n\nCombine N reducing functions into a new reducing function that work on N-tuple.  The i-th reducing function recieves the i-th element of the input tuple.\n\nRoughly speaking, ProductRF(op₁, op₂, ..., opₙ) is equivalent to\n\n((a₁, a₂, ..., aₙ), (b₁, b₂, ..., bₙ)) -> (op₁(a₁, b₁), op₂(a₂, b₂), ..., opₙ(aₙ, bₙ))\n\ncompat: Transducers.jl 0.4.32\nNew in version 0.4.32.\n\nExamples\n\nLike TeeRF, ProductRF can be used to drive multiple reducing functions.  ProductRF is more \"low-level\" in the sense that TeeRF can be defined in terms of ProductRF (other direction is much harder):\n\njulia> using Transducers\n\njulia> TeeRF′(fs...) = reducingfunction(\n           Map(x -> ntuple(_ -> x, length(fs))),\n           ProductRF(fs...),\n       );\n\njulia> foldl(TeeRF′(min, max), Map(identity), [5, 2, 6, 8, 3])\n(2, 8)\n\nProductRF may be useful for handling pre-existing stream whose item type is already a tuple:\n\njulia> foldl(ProductRF(&, +), Map(x -> (isodd(x), x)), [5, 2, 6, 8, 3])\n(false, 24)\n\njulia> foldl(TeeRF(reducingfunction(Map(isodd), &), +), Map(identity), [5, 2, 6, 8, 3])\n(false, 24)\n\n\n\n\n\n","category":"type"},{"location":"reference/manual/#Early-termination","page":"Manual","title":"Early termination","text":"","category":"section"},{"location":"reference/manual/","page":"Manual","title":"Manual","text":"Reduced\nreduced\nunreduced\nifunreduced","category":"page"},{"location":"reference/manual/#Transducers.Reduced","page":"Manual","title":"Transducers.Reduced","text":"Reduced\n\nThe type signaling transducible processes to abort.\n\nnote: Note\nCall reduced function for aborting the transducible process since reduced makes sure x is not doubly wrapped.  Reduced is meant to be used as x isa Reduced for checking if the result from transduce is due to early termination.\n\nSee reduced, unreduced.\n\nExamples\n\njulia> using Transducers\n\njulia> function step_demo(y, x)\n           if x > 5\n               return reduced(y)\n           else\n               return y + x\n           end\n       end;\n\njulia> result = transduce(Map(identity), Completing(step_demo), 0, 1:10)\nReduced(15)\n\njulia> result isa Reduced\ntrue\n\njulia> unreduced(result)\n15\n\njulia> result = transduce(Map(identity), Completing(step_demo), 0, 1:4)\n10\n\njulia> result isa Reduced\nfalse\n\njulia> unreduced(result)\n10\n\n\n\n\n\n","category":"type"},{"location":"reference/manual/#Transducers.reduced","page":"Manual","title":"Transducers.reduced","text":"reduced([x = nothing])\n\nStop transducible process with the final value x (default: nothing).  Return x as-is if it already is a reduced value.\n\nSee Reduced, unreduced.\n\nThis API is modeled after ensure-reduced in Clojure.\n\nExamples\n\njulia> using Transducers\n\njulia> foldl(Enumerate(), \"abcdef\"; init=0) do y, (i, x)\n           if x == 'd'\n               return reduced(y)\n           end\n           return y + i\n       end\n6\n\njulia> foreach(Enumerate(), \"abc\") do (i, x)\n           println(i, ' ', x)\n           if x == 'b'\n               return reduced()\n           end\n       end;\n1 a\n2 b\n\n\n\n\n\n","category":"function"},{"location":"reference/manual/#Transducers.unreduced","page":"Manual","title":"Transducers.unreduced","text":"unreduced(x)\n\nUnwrap x if it is a Reduced; do nothing otherwise.\n\nSee Reduced, reduced.\n\nThis API is modeled after unreduced in Clojure.\n\n\n\n\n\n","category":"function"},{"location":"reference/manual/#Transducers.ifunreduced","page":"Manual","title":"Transducers.ifunreduced","text":"ifunreduced(f, [x])\n\nEquivalent to unreduced(x) if x is a Reduced; otherwise run f(x).  Return a curried version if x is not provided.\n\nSee: foreach.\n\nExamples\n\njulia> using Transducers\n\njulia> 1 |> ifunreduced() do x\n           println(\"called with x = \", x)\n       end\ncalled with x = 1\n\njulia> reduced(1) |> ifunreduced() do x\n           println(\"called with x = \", x)\n       end\n1\n\nNotice that nothing is printed in the last example.\n\nImplementation\n\nifunreduced(f) = x -> ifunreduced(f, x)\nifunreduced(f, x::Reduced) = unreduced(x)\nifunreduced(f, x) = f(x)\n\n\n\n\n\n","category":"function"},{"location":"reference/manual/#Miscellaneous","page":"Manual","title":"Miscellaneous","text":"","category":"section"},{"location":"reference/manual/","page":"Manual","title":"Manual","text":"Transducer(::Transducers.Comprehension)\nTransducer(::OnlineStats.OnlineStat)\nreducingfunction\nCompleting\nOnInit\nCopyInit\nright\nsetinput\nAdHocFoldable\nwithprogress","category":"page"},{"location":"reference/manual/#Transducers.Transducer-Tuple{Union{Base.Generator, Base.Iterators.Filter, Base.Iterators.Flatten}}","page":"Manual","title":"Transducers.Transducer","text":"Transducer(iterator::Iterators.Generator)\nTransducer(iterator::Iterators.Filter)\nTransducer(iterator::Iterators.Flatten)\n\nExtract \"processing\" part of an iterator as a Transducer.  The \"data source\" iterator (i.e., xs in (f(x) for x in xs)) is ignored and nothing must be used as a place holder (i.e., (f(x) for x in nothing)).\n\nSee also eduction.\n\ncompat: Transducers.jl 0.3\nNew in version 0.3.\n\nExamples\n\njulia> using Transducers\n\njulia> xf1 = Transducer(2x for x in nothing if x % 2 == 0);\n\njulia> xf2 = opcompose(Filter(x -> x % 2 == 0), Map(x -> 2x));  # equivalent\n\njulia> xs = 1:10\n       collect(xf1, xs) == collect(xf2, xs)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"reference/manual/#Transducers.Transducer-Tuple{OnlineStatsBase.OnlineStat}","page":"Manual","title":"Transducers.Transducer","text":"Transducer(o::OnlineStat)\n\nUse an OnlineStat as a stateful transducer.\n\nIt is implemented as:\n\nopcompose(Scan(fit!, CopyInit(o)), Map(value))\n\nExamples\n\njulia> using Transducers\n       using OnlineStats: Mean\n\njulia> collect(Transducer(Mean()), 1:4)\n4-element Array{Float64,1}:\n 1.0\n 1.5\n 2.0\n 2.5\n\n\n\n\n\n","category":"method"},{"location":"reference/manual/#Transducers.reducingfunction","page":"Manual","title":"Transducers.reducingfunction","text":"reducingfunction(xf, step; simd)\nxf'(step; simd)\n\nApply transducer xf to the reducing function step to create a new reducing function.\n\ncompat: Transducers.jl 0.3\nNew in version 0.3.\n\nwarning: Warning\nBe careful using reducingfunction with stateful transducers like Scan with mutable init (e.g., Scan(push!, [])).  See more in Examples below.\n\nArguments\n\nxf::Transducer: A transducer.\nstep: A callable which accepts 1 and 2 arguments.  If it only accepts 2 arguments, wrap it with Completing to \"add\" 1-argument form (i.e., complete protocol).\n\nKeyword Arguments\n\nsimd: false, true, or :ivdep. See maybe_usesimd.\n\nExamples\n\njulia> using Transducers\n\njulia> rf = reducingfunction(Map(x -> x + 1), *);\n\njulia> rf(10, 2) === 10 * (2 + 1)\ntrue\n\nWarning: Be careful when using reducingfunction with stateful transducers\n\nStateful Transducers themselves in Transducers.jl are not inherently broken with reducingfunction.  However, it can produce incorrect results when combined with mutable states:\n\njulia> scan_state = [];\n\njulia> rf_bad = opcompose(Scan(push!, scan_state), Cat())'(string);\n\njulia> transduce(rf_bad, \"\", 1:3)\n\"112123\"\n\nThe first run works.  However, observe that the vector scan_state is not empty anymore:\n\njulia> scan_state\n3-element Array{Any,1}:\n 1\n 2\n 3\n\nThus, the second run produces an incorrect result:\n\njulia> transduce(rf_bad, \"\", 1:3)\n\"123112312123123\"\n\nOne way to solve this issue is to use CopyInit or OnInit.\n\njulia> scan_state = CopyInit([])\nCopyInit(Any[])\n\njulia> rf_good = opcompose(Scan(push!, scan_state), Cat())'(string);\n\njulia> transduce(rf_good, \"\", 1:3)\n\"112123\"\n\njulia> scan_state\nCopyInit(Any[])\n\njulia> transduce(rf_good, \"\", 1:3)\n\"112123\"\n\n\n\n\n\nreducingfunction([xf::Transducer,] o::OnlineStat; simd)\n\nConvert an OnlineStat to a reducing function.  Returned function can be used with foldl, reduce, and dreduce. Note that input o is only used as a \"prototype\"; i.e., it's not going to be mutated.\n\nExamples\n\njulia> using Transducers\n       using OnlineStats: Mean\n\njulia> foldl(reducingfunction(Mean()), Map(x -> x^2), 1:4)\nMean: n=4 | value=7.5\n\njulia> foldl(Mean(), Map(x -> x^2), 1:4)  # equivalent to above\nMean: n=4 | value=7.5\n\njulia> reduce(Mean(), Map(x -> x^2), 1:4)  # threaded\nMean: n=4 | value=7.5\n\njulia> foldl(Mean(), eduction(x^2 for x in 1:4))  # ditto\nMean: n=4 | value=7.5\n\njulia> reduce(Mean(), eduction(x^2 for x in 1:4))  # ditto\nMean: n=4 | value=7.5\n\ndreduce can be used instead of reduce.  However the usual caveats of code availability for Distributed.jl apply.\n\n\n\n\n\n","category":"function"},{"location":"reference/manual/#Transducers.Completing","page":"Manual","title":"Transducers.Completing","text":"Completing(function)\n\nWrap a function to add a no-op complete protocol.  Use it when passing a function without unary method to transduce etc.\n\nThis API is modeled after completing in Clojure.\n\n\n\n\n\n","category":"type"},{"location":"reference/manual/#Transducers.OnInit","page":"Manual","title":"Transducers.OnInit","text":"OnInit(f)\n\nCall a callable f to create an initial value.\n\nSee also CopyInit.\n\nOnInit or CopyInit must be used whenever using in-place reduction with reduce etc.\n\nExamples\n\njulia> using Transducers\n\njulia> xf1 = Scan(push!, [])\nScan(push!, Any[])\n\njulia> foldl(right, xf1, 1:3)\n3-element Array{Any,1}:\n 1\n 2\n 3\n\njulia> xf1\nScan(push!, Any[1, 2, 3])\n\nNotice that the array is stored in xf1 and mutated in-place.  As a result, second run of foldl contains the results from the first run:\n\njulia> foldl(right, xf1, 10:11)\n5-element Array{Any,1}:\n  1\n  2\n  3\n 10\n 11\n\nThis may not be desired.  To avoid this behavior, create an OnInit object which takes a factory function to create a new initial value.\n\njulia> xf2 = Scan(push!, OnInit(() -> []))\nScan(push!, OnInit(##9#10()))\n\njulia> foldl(right, xf2, 1:3)\n3-element Array{Any,1}:\n 1\n 2\n 3\n\njulia> foldl(right, xf2, [10.0, 11.0])\n2-element Array{Any,1}:\n 10.0\n 11.0\n\nKeyword argument init for transducible processes also accept an OnInit:\n\njulia> foldl(push!, Map(identity), \"abc\"; init=OnInit(() -> []))\n3-element Array{Any,1}:\n 'a'\n 'b'\n 'c'\n\nTo create a copy of a mutable object, CopyInit is easier to use.\n\nHowever, more powerful and generic pattern is to use push!! from BangBang.jl and initialize init with Union{}[] so that it automatically finds the minimal element type.\n\njulia> using BangBang\n\njulia> foldl(push!!, Map(identity), \"abc\"; init=Union{}[])\n3-element Array{Char,1}:\n 'a'\n 'b'\n 'c'\n\n\n\n\n\n","category":"type"},{"location":"reference/manual/#Transducers.CopyInit","page":"Manual","title":"Transducers.CopyInit","text":"CopyInit(value)\n\nThis is equivalent to OnInit(() -> deepcopy(value)).\n\ncompat: Transducers.jl 0.3\nNew in version 0.3.\n\nExamples\n\njulia> using Transducers\n\njulia> init = CopyInit([]);\n\njulia> foldl(push!, Map(identity), 1:3; init=init)\n3-element Array{Any,1}:\n 1\n 2\n 3\n\njulia> foldl(push!, Map(identity), 1:3; init=init)  # `init` can be reused\n3-element Array{Any,1}:\n 1\n 2\n 3\n\n\n\n\n\n","category":"type"},{"location":"reference/manual/#Transducers.right","page":"Manual","title":"Transducers.right","text":"right([l, ]r) -> r\n\nIt is simply defined as\n\nright(l, r) = r\nright(r) = r\n\nThis function is meant to be used as step argument for foldl etc. for extracting the last output of the transducers.\n\ncompat: Transducers.jl 0.3\nInitial value must be manually specified.  In 0.2, it was automatically set to nothing.\n\nExamples\n\njulia> using Transducers\n\njulia> foldl(right, Take(5), 1:10)\n5\n\njulia> foldl(right, Drop(5), 1:3; init=0)  # using `init` as the default value\n0\n\n\n\n\n\n","category":"function"},{"location":"reference/manual/#Transducers.setinput","page":"Manual","title":"Transducers.setinput","text":"setinput(ed::Eduction, coll)\n\nSet input collection of eduction ed to coll.\n\ncompat: Transducers.jl 0.3\nPreviously, setinput combined with eduction was a recommended way to use transducers in a type stable manner.  As of v0.3, all the foldl-like functions and eduction are type stable for many cases.  This workaround is no more necessary.\n\nExamples\n\njulia> using Transducers\n\njulia> ed = eduction(Map(x -> 2x), Float64[]);\n\njulia> xs = ones(2, 3);\n\njulia> foldl(+, setinput(ed, xs))\n12.0\n\n\n\n\n\n","category":"function"},{"location":"reference/manual/#Transducers.AdHocFoldable","page":"Manual","title":"Transducers.AdHocFoldable","text":"AdHocFoldable(foldl, [collection = nothing])\n\nProvide a different way to fold collection without creating a wrapper type.\n\nArguments\n\nfoldl::Function: a function that implements __foldl__.\ncollection: a collection passed to the last argument of foldl.\n\nExamples\n\njulia> using Transducers\n       using Transducers: @next, complete\n       using ArgCheck\n\njulia> function uppertriangle(A::AbstractMatrix)\n           @argcheck !Base.has_offset_axes(A)\n           return AdHocFoldable(A) do rf, acc, A\n               for j in 1:size(A, 2), i in 1:min(j, size(A, 1))\n                   acc = @next(rf, acc, @inbounds A[i, j])\n               end\n               return complete(rf, acc)\n           end\n       end;\n\njulia> A = reshape(1:6, (3, 2))\n3×2 reshape(::UnitRange{Int64}, 3, 2) with eltype Int64:\n 1  4\n 2  5\n 3  6\n\njulia> collect(Map(identity), uppertriangle(A))\n3-element Array{Int64,1}:\n 1\n 4\n 5\n\njulia> function circularwindows(xs::AbstractVector, h::Integer)\n           @argcheck !Base.has_offset_axes(xs)\n           @argcheck h >= 0\n           @argcheck 2 * h + 1 <= length(xs)\n           return AdHocFoldable(xs) do rf, acc, xs\n               buffer = similar(xs, 2 * h + 1)\n               @inbounds for i in 1:h\n                   buffer[1:h - i + 1] .= @view xs[end - h + i:end]\n                   buffer[h - i + 2:end] .= @view xs[1:h + i]\n                   acc = @next(rf, acc, buffer)\n               end\n               for i in h + 1:length(xs) - h\n                   acc = @next(rf, acc, @inbounds @view xs[i - h:i + h])\n               end\n               @inbounds for i in 1:h\n                   buffer[1:end - i] .= @view xs[end - 2 * h + i:end]\n                   buffer[end - i + 1:end] .= @view xs[1:i]\n                   acc = @next(rf, acc, buffer)\n               end\n               return complete(rf, acc)\n           end\n       end;\n\njulia> collect(Map(collect), circularwindows(1:9, 2))\n9-element Array{Array{Int64,1},1}:\n [8, 9, 1, 2, 3]\n [9, 1, 2, 3, 4]\n [1, 2, 3, 4, 5]\n [2, 3, 4, 5, 6]\n [3, 4, 5, 6, 7]\n [4, 5, 6, 7, 8]\n [5, 6, 7, 8, 9]\n [6, 7, 8, 9, 1]\n [7, 8, 9, 1, 2]\n\njulia> expressions(str::AbstractString; kwargs...) =\n           AdHocFoldable(str) do rf, val, str\n               pos = 1\n               while true\n                   expr, pos = Meta.parse(str, pos;\n                                          raise = false,\n                                          depwarn = false,\n                                          kwargs...)\n                   expr === nothing && break\n                   val = @next(rf, val, expr)\n               end\n               return complete(rf, val)\n           end;\n\njulia> collect(Map(identity), expressions(\"\"\"\n       x = 1\n       y = 2\n       \"\"\"))\n2-element Array{Expr,1}:\n :(x = 1)\n :(y = 2)\n\njulia> counting = AdHocFoldable() do rf, acc, _\n           i = 0\n           while true\n               i += 1\n               acc = @next(rf, acc, i)\n           end\n       end;\n\njulia> foreach(counting) do i\n           @show i;\n           i == 3 && return reduced()\n       end;\ni = 1\ni = 2\ni = 3\n\n\n\n\n\n","category":"type"},{"location":"reference/manual/#Transducers.withprogress","page":"Manual","title":"Transducers.withprogress","text":"withprogress(foldable) -> foldable′\n\nWrap a foldable so that progress is shown in logging-based progress meter (e.g., Juno) during foldl, reduce, dreduce, etc.\n\nFor parallel reduction such as reduce and dreduce, reasonably small basesize and threads_basesize (for dreduce) must be used to ensure that progress information is updated frequently.  However, it may slow down the computation if basesize is too small.\n\nKeyword Arguments\n\ninterval::Real: Minimum interval (in seconds) for how often progress is logged.\n\nExamples\n\njulia> using Transducers\n\njulia> xf = Map() do x\n           sleep(0.01)\n           x\n       end;\n\njulia> foldl(+, xf, withprogress(1:100; interval=1e-3))  # see progress meter\n5050\n\nIn foldl and reduce, withprogress can be nested.  This is not supported in dreduce.\n\njulia> xf = opcompose(\n           MapCat() do x\n               withprogress(1:x; interval=1e-3)  # nested progress\n           end,\n           Map() do x\n               sleep(0.5)\n               x\n           end,\n       );\n\njulia> if VERSION >= v\"1.3-alpha\"\n           # Calling `sleep` in thread is safe in Julia 1.3:\n           reduce(+, xf, withprogress(1:10; interval=1e-3); basesize=1)\n       else\n           foldl(+, xf, withprogress(1:10; interval=1e-3))\n       end\n220\n\n\n\n\n\n","category":"function"},{"location":"reference/manual/#Deprecated","page":"Manual","title":"Deprecated","text":"","category":"section"},{"location":"reference/manual/","page":"Manual","title":"Manual","text":"mapfoldl\nmapreduce","category":"page"},{"location":"reference/manual/#Base.mapfoldl","page":"Manual","title":"Base.mapfoldl","text":"mapfoldl(xf::Transducer, step, reducible; init, simd)\n\nwarning: Warning\nmapfoldl exists primary for backward compatibility.  It is recommended to use foldl.\n\nLike foldl but step is not automatically wrapped by Completing.\n\nExamples\n\njulia> using Transducers\n\njulia> function step_demo(state, input)\n           @show state, input\n           state + input\n       end;\n\njulia> function step_demo(state)\n           println(\"Finishing with state = \", state)\n           state\n       end;\n\njulia> mapfoldl(Filter(isodd), step_demo, 1:4, init=0.0)\n(state, input) = (0.0, 1)\n(state, input) = (1.0, 3)\nFinishing with state = 4.0\n4.0\n\n\n\n\n\n","category":"function"},{"location":"reference/manual/#Base.mapreduce","page":"Manual","title":"Base.mapreduce","text":"mapreduce(xf, step, reducible; init, simd)\n\nwarning: Warning\nmapreduce exists primary for backward compatibility.  It is recommended to use reduce.\n\nLike reduce but step is not automatically wrapped by Completing.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/words/","page":"Parallel word count","title":"Parallel word count","text":"EditURL = \"https://github.com/JuliaFolds/Transducers.jl/blob/master/examples/words.jl\"","category":"page"},{"location":"tutorials/words/#parallel-word-count","page":"Parallel word count","title":"Splitting a string into words and counting them in parallel","text":"","category":"section"},{"location":"tutorials/words/","page":"Parallel word count","title":"Parallel word count","text":"We start from the parallel algorithm presented in Guy Steele's 2009 ICFP talk (video).  It splits a space-separated string into list of strings (words).  The repeating theme in the talk was to build \"singleton solutions\" and then merge them together using an associative function.  We will follow this guideline and slightly extend the algorithm.","category":"page"},{"location":"tutorials/words/","page":"Parallel word count","title":"Parallel word count","text":"It is highly recommended to just watch the talk for understanding the algorithm.  However, we briefly describe how it works.","category":"page"},{"location":"tutorials/words/","page":"Parallel word count","title":"Parallel word count","text":"When a certain contiguous region of a string is processed, we either already have seen at least one space or not.  These two states are tracked using following two types.  If there is no space so far, we only have a chunk of a possibly larger word (see example below):","category":"page"},{"location":"tutorials/words/","page":"Parallel word count","title":"Parallel word count","text":"struct Chunk\n    s::String\nend","category":"page"},{"location":"tutorials/words/","page":"Parallel word count","title":"Parallel word count","text":"If there are one or more spaces, (possibly zero) words that are already determined and left/right \"chunks\" have to be tracked separately:","category":"page"},{"location":"tutorials/words/","page":"Parallel word count","title":"Parallel word count","text":"struct Segment\n    l::String\n    A::Vector{String}\n    r::String\nend","category":"page"},{"location":"tutorials/words/","page":"Parallel word count","title":"Parallel word count","text":"Here is an example taken from the talk:","category":"page"},{"location":"tutorials/words/","page":"Parallel word count","title":"Parallel word count","text":"Segment(\"Here\", [\"is\", \"a\"], \"\")\n   |\n   |       Segment(\"lian\", [], \"string\")\n __|_____            _|______\n|        |          |        |\nHere is a sesquipedalian string of words\n          |________|          |________|\n   Chunk(\"sesquipeda\")        Segment(\"g\", [\"of\"], \"words\")","category":"page"},{"location":"tutorials/words/","page":"Parallel word count","title":"Parallel word count","text":"We then need a way to merge two results which can independently in one of the above two states.","category":"page"},{"location":"tutorials/words/","page":"Parallel word count","title":"Parallel word count","text":"⊕(x::Chunk, y::Chunk) = Chunk(x.s * y.s)\n⊕(x::Chunk, y::Segment) = Segment(x.s * y.l, y.A, y.r)\n⊕(x::Segment, y::Chunk) = Segment(x.l, x.A, x.r * y.s)\n⊕(x::Segment, y::Segment) =\n    Segment(x.l,\n            append!(append!(x.A, maybewordv(x.r * y.l)), y.A),\n            y.r)\n\nmaybewordv(s::String) = isempty(s) ? String[] : [s]\nnothing  # hide","category":"page"},{"location":"tutorials/words/","page":"Parallel word count","title":"Parallel word count","text":"Input is a sequence of Chars.  Each of them has to be converted into a \"singleton solution\" which can be merged with already aggregated (or another singleton) solution with ⊕:","category":"page"},{"location":"tutorials/words/","page":"Parallel word count","title":"Parallel word count","text":"segmentorchunk(c::Char) = c == ' ' ? Segment(\"\", [], \"\") : Chunk(string(c))\nnothing  # hide","category":"page"},{"location":"tutorials/words/","page":"Parallel word count","title":"Parallel word count","text":"Putting them together, we get:","category":"page"},{"location":"tutorials/words/","page":"Parallel word count","title":"Parallel word count","text":"function collectwords(s::String)\n    g = mapfoldl(segmentorchunk, ⊕, s; init=Segment(\"\", [], \"\"))\n    if g isa Char\n        return maybewordv(g.s)\n    else\n        return append!(append!(maybewordv(g.l), g.A), maybewordv(g.r))\n    end\nend\nnothing  # hide","category":"page"},{"location":"tutorials/words/","page":"Parallel word count","title":"Parallel word count","text":"Let's run a few tests covering some edge cases:","category":"page"},{"location":"tutorials/words/","page":"Parallel word count","title":"Parallel word count","text":"using Test\n@testset begin\n    @test collectwords(\"This is a sample\") == [\"This\", \"is\", \"a\", \"sample\"]\n    @test collectwords(\" Here is another sample \") == [\"Here\", \"is\", \"another\", \"sample\"]\n    @test collectwords(\"JustOneWord\") == [\"JustOneWord\"]\n    @test collectwords(\" \") == []\n    @test collectwords(\"\") == []\nend\nnothing  # hide","category":"page"},{"location":"tutorials/words/#String-splitting-transducer","page":"Parallel word count","title":"String-splitting transducer","text":"","category":"section"},{"location":"tutorials/words/","page":"Parallel word count","title":"Parallel word count","text":"Let's try to make it re-usable by packaging it into transducers.","category":"page"},{"location":"tutorials/words/","page":"Parallel word count","title":"Parallel word count","text":"using Transducers","category":"page"},{"location":"tutorials/words/","page":"Parallel word count","title":"Parallel word count","text":"Rather than accumulating words into a vector, we are going to write a transducer that \"emits\" a word as soon as it is ready.  The downstream transducer may choose to record everything or only aggregate, e.g., reduced statistics.  To this end, we replace Segment in the original algorithm to","category":"page"},{"location":"tutorials/words/","page":"Parallel word count","title":"Parallel word count","text":"struct Vacant\n    l::String\n    r::String\nend","category":"page"},{"location":"tutorials/words/","page":"Parallel word count","title":"Parallel word count","text":"and output the words in the \"middle\" without accumulating it.  We use ScanEmit which requires an operator/function like ⊕ above but returning a pair of output and next state.  This function (extract below) must have the signature (S, S) -> (O, S) where S is the type for accumulated state and input and O is the output type.","category":"page"},{"location":"tutorials/words/","page":"Parallel word count","title":"Parallel word count","text":"extract(x::Chunk, y::Chunk) = (), Chunk(x.s * y.s)\nextract(x::Chunk, y::Vacant) = (), Vacant(x.s * y.l, y.r)\nextract(x::Vacant, y::Chunk) = (), Vacant(x.l, x.r * y.s)\nextract(x::Vacant, y::Vacant) = maybewordt(x.r * y.l), Vacant(x.l, y.r)\n\nmaybewordt(s) = isempty(s) ? () : (s,)\nnothing  # hide","category":"page"},{"location":"tutorials/words/","page":"Parallel word count","title":"Parallel word count","text":"maybewordt(x.r * y.l) in extract(x::Vacant, y::Vacant) is the \"emission\".","category":"page"},{"location":"tutorials/words/","page":"Parallel word count","title":"Parallel word count","text":"The words at the beginning and/or the end are not handled by extract.  This must be handled separately:","category":"page"},{"location":"tutorials/words/","page":"Parallel word count","title":"Parallel word count","text":"lastword(x::Chunk) = maybewordt(x.s)\nlastword(x::Vacant) = (maybewordt(x.r)..., maybewordt(x.l)...)\n\nvacantorchunk(c::Char) = c == ' ' ? Vacant(\"\", \"\") : Chunk(string(c))\n\nwordsxf = opcompose(Map(vacantorchunk), ScanEmit(extract, Chunk(\"\"), lastword), Cat())","category":"page"},{"location":"tutorials/words/","page":"Parallel word count","title":"Parallel word count","text":"Test:","category":"page"},{"location":"tutorials/words/","page":"Parallel word count","title":"Parallel word count","text":"@testset begin\n    @test collect(wordsxf, \"This is a sample\") == [\"is\", \"a\", \"sample\", \"This\"]\n    @test collect(wordsxf, \" Here is another sample \") == [\"Here\", \"is\", \"another\", \"sample\"]\n    @test collect(wordsxf, \"JustOneWord\") == [\"JustOneWord\"]\n    @test collect(wordsxf, \" \") == []\n    @test collect(wordsxf, \"\") == []\nend\nnothing  # hide","category":"page"},{"location":"tutorials/words/","page":"Parallel word count","title":"Parallel word count","text":"Side note: In the first example, the first word This comes last. This is actually expected since both .l and .r are flushed in lastword which is called at the very end.  Here, This is stored in .l field.  If the order of the words is important, there are many possible fixes.  For example, extract and lastword can bundle information about the origin of the word (left vs middle-or-right).  Alternatively, perhaps the easiest solution is to insert a space in the beginning of input data.","category":"page"},{"location":"tutorials/words/#Word-counting-transducer","page":"Parallel word count","title":"Word-counting transducer","text":"","category":"section"},{"location":"tutorials/words/","page":"Parallel word count","title":"Parallel word count","text":"We can pipe the resulting words into various transducers.","category":"page"},{"location":"tutorials/words/","page":"Parallel word count","title":"Parallel word count","text":"processcount(word) = Base.ImmutableDict(word => 1)\ncountxf = opcompose(wordsxf, Map(processcount))","category":"page"},{"location":"tutorials/words/","page":"Parallel word count","title":"Parallel word count","text":"Transducer countxf constructs a \"singleton solution\" as a dictionary which then accumulated with the associative reducing step function mergecont!:","category":"page"},{"location":"tutorials/words/","page":"Parallel word count","title":"Parallel word count","text":"mergecont!(a, b) = merge!(+, a, b)\nnothing  # hide","category":"page"},{"location":"tutorials/words/","page":"Parallel word count","title":"Parallel word count","text":"Putting the transducer and reducing function together, we get:","category":"page"},{"location":"tutorials/words/","page":"Parallel word count","title":"Parallel word count","text":"countwords(s; kwargs...) =\n    reduce(mergecont!,\n           countxf,\n           collect(s);\n           init = CopyInit(Dict{String,Int}()),\n           kwargs...)\nnothing  # hide","category":"page"},{"location":"tutorials/words/","page":"Parallel word count","title":"Parallel word count","text":"Side note: Since reduce does not support string, the input string is converted to a Vector{Char} first by collect.","category":"page"},{"location":"tutorials/words/","page":"Parallel word count","title":"Parallel word count","text":"Side note 2: We use CopyInit to create a fresh initial state for each sub-reduce to avoid overwriting mutable data between threads.","category":"page"},{"location":"tutorials/words/","page":"Parallel word count","title":"Parallel word count","text":"Side note 3: reduce wraps mergecont! automatically with Completing.  This is why mergecont! does not have to have the unary method.","category":"page"},{"location":"tutorials/words/","page":"Parallel word count","title":"Parallel word count","text":"Let's run some tests with different basesize (length(s) / basesize corresponds to number of tasks to be used):","category":"page"},{"location":"tutorials/words/","page":"Parallel word count","title":"Parallel word count","text":"@testset for basesize in [1, 2, 4]\n    @test countwords(\"This is a sample\", basesize=basesize) ==\n        Dict(\"This\" => 1, \"is\" => 1, \"a\" => 1, \"sample\" => 1)\n    @test countwords(\" Here is another sample \", basesize=basesize) ==\n        Dict(\"Here\" => 1, \"is\" => 1, \"another\" => 1, \"sample\" => 1)\n    @test countwords(\"JustOneWord\", basesize=basesize) ==\n        Dict(\"JustOneWord\" => 1)\n    @test countwords(\" \", basesize=basesize) == Dict()\n    @test countwords(\"\", basesize=basesize) == Dict()\n    @test countwords(\"aaa bb aaa aaa bb bb aaa\", basesize=basesize) ==\n        Dict(\"aaa\" => 4, \"bb\" => 3)\n    @test countwords(\"あああ いい あああ あああ いい いい あああ\", basesize=basesize) ==\n        Dict(\"あああ\" => 4, \"いい\" => 3)\nend\nnothing  # hide","category":"page"},{"location":"tutorials/words/","page":"Parallel word count","title":"Parallel word count","text":"","category":"page"},{"location":"tutorials/words/","page":"Parallel word count","title":"Parallel word count","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/interface/#Transducer-interface","page":"Interface","title":"Transducer interface","text":"","category":"section"},{"location":"reference/interface/#Core-interface-for-transducers","page":"Interface","title":"Core interface for transducers","text":"","category":"section"},{"location":"reference/interface/","page":"Interface","title":"Interface","text":"Transducers.AbstractFilter\nTransducers.R_\nTransducers.inner\nTransducers.xform\nTransducers.start\nTransducers.next\nTransducers.@next\nTransducers.complete\nTransducers.combine","category":"page"},{"location":"reference/interface/#Transducers.AbstractFilter","page":"Interface","title":"Transducers.AbstractFilter","text":"AbstractFilter <: Transducer\n\nThe abstract type for filter-like transducers.\n\n\n\n\n\n","category":"type"},{"location":"reference/interface/#Transducers.R_","page":"Interface","title":"Transducers.R_","text":"Transducers.R_{X}\n\nWhen defining a transducer type X, it is often required to dispatch on type rf::R_{X} (Reducing Function) which bundles the current transducer xform(rf)::X and the inner reducing function inner(rf)::R_.\n\n\n\n\n\n","category":"type"},{"location":"reference/interface/#Transducers.inner","page":"Interface","title":"Transducers.inner","text":"Transducers.inner(rf::R_)\n\nReturn the inner reducing function of rf.\n\n\n\n\n\n","category":"function"},{"location":"reference/interface/#Transducers.xform","page":"Interface","title":"Transducers.xform","text":"Transducers.xform(rf::R_{X}) -> xf :: X\n\nReturn the transducer xf associated with rf.  Returned transducer xf is \"atomic\"; i.e., it is not a Composition transducer type.\n\n\n\n\n\n","category":"function"},{"location":"reference/interface/#Transducers.start","page":"Interface","title":"Transducers.start","text":"Transducers.start(rf::R_{X}, state)\n\nThis is an optional interface for a transducer.  Default implementation just calls start of the inner reducing function; i.e.,\n\nstart(rf::Reduction, result) = start(inner(rf), result)\n\nIf the transducer X is stateful, it can \"bundle\" its private state with wrap:\n\nstart(rf::R_{X}, result) = wrap(rf, PRIVATE_STATE, start(inner(rf), result))\n\nwhere PRIVATE_STATE is an initial value for the private state that can be used inside next via wrapping.\n\nSee Take, PartitionBy, etc. for real-world examples.\n\nSide notes: There is no related API in Clojure's Transducers. Transducers.jl uses it to implement stateful transducers using \"pure\" functions.  The idea is based on a slightly different approach taken in C++ Transducer library atria.\n\n\n\n\n\n","category":"function"},{"location":"reference/interface/#Transducers.next","page":"Interface","title":"Transducers.next","text":"Transducers.next(rf::R_{X}, state, input)\n\nThis is the only required interface.  It takes the following form (if start is not defined):\n\nnext(rf::R_{X}, result, input) =\n    # code calling next(inner(rf), result, possibly_modified_input)\n\nWhen calling next, it is almost always a better idea to use the macro form @next.  See the details in its documentation.\n\nSee Map, Filter, Cat, etc. for real-world examples.\n\n\n\n\n\n","category":"function"},{"location":"reference/interface/#Transducers.@next","page":"Interface","title":"Transducers.@next","text":"@next(rf, state, input)\n\nIt is expanded to\n\nresult = next(rf, state, input)\nresult isa Reduced && return result\nresult\n\nThis is usually the best way to call next as checking for Reduced is required to support early termination.\n\nSee also: next, Reduced, @return_if_reduced.\n\n\n\n\n\n","category":"macro"},{"location":"reference/interface/#Transducers.complete","page":"Interface","title":"Transducers.complete","text":"Transducers.complete(rf::R_{X}, state)\n\nThis is an optional interface for a transducer.  If transducer X has some internal state, this is the last chance to \"flush\" the result.\n\nSee PartitionBy, etc. for real-world examples.\n\nIf start(rf::R_{X}, state) is defined, complete must unwarp state before returning state to the outer reducing function.\n\ncompat: Transducers.jl 0.3\nIn Transducers.jl 0.2, complete had a fallback implementation to automatically call unwrap when wrap is called in start. Relying on this fallback implementation is now deprecated.\n\n\n\n\n\n","category":"function"},{"location":"reference/interface/#Transducers.combine","page":"Interface","title":"Transducers.combine","text":"Transducers.combine(rf::R_{X}, state_left, state_right)\n\nThis is an optional interface for a transducer.  If transducer X is stateful (i.e., wrap is used in start), it has to be able to combine the private states to support fold functions that require an associative reducing function such as reduce. Typical implementation takes the following form:\n\nfunction combine(rf::R_{X}, a, b)\n    #   ,---- `ua` and `ub` are the private state of the transducer `X`\n    #  /  ,-- `ira` and `irb` are the states of inner reducing functions\n    # /  /\n    ua, ira = unwrap(rf, a)\n    ub, irb = unwrap(rf, b)\n    irc = combine(inner(rf), ira, irb)\n    uc = # somehow combine private states `ua` and `ub`\n    return wrap(rf, uc, irc)\nend\n\nSee ScanEmit, etc. for real-world examples.\n\n\n\n\n\n","category":"function"},{"location":"reference/interface/#Helpers-for-stateful-transducers","page":"Interface","title":"Helpers for stateful transducers","text":"","category":"section"},{"location":"reference/interface/","page":"Interface","title":"Interface","text":"Transducers.wrap\nTransducers.unwrap\nTransducers.wrapping","category":"page"},{"location":"reference/interface/#Transducers.wrap","page":"Interface","title":"Transducers.wrap","text":"wrap(rf::R_{X}, state, iresult)\n\nPack private state for reducing function rf (or rather the transducer X) with the result iresult returned from the inner reducing function inner(rf).  This packed result is typically passed to the outer reducing function.\n\nThis is intended to be used only in start.  Inside next, use wrapping.\n\nnote: Implementation detail\nIf iresult is a Reduced, wrap actually unwraps all internal state iresult recursively.  However, this is an implementation detail that should not matter when writing transducers.\n\nConsider a reducing step constructed as\n\nrf = Reduction(xf₁ |> xf₂ |> xf₃, f)\n\nwhere each xfₙ is a stateful transducer and hence needs a private state stateₙ.  Then, calling start(rf, result)) is equivalent to\n\nwrap(rf,\n     state₁,                     # private state for xf₁\n     wrap(inner(rf),\n          state₂,                # private state for xf₂\n          wrap(inner(rf).inner,\n               state₃,           # private state for xf₃\n               result)))\n\nor equivalently\n\nresult₃ = result\nresult₂ = wrap(inner(inner(rf)), state₃, result₃)\nresult₁ = wrap(inner(rf),        state₂, result₂)\nresult₀ = wrap(rf,               state₁, result₁)\n\nThe inner most step function receives the original result as the first argument while transducible processes such as foldl only sees the outer-most \"tree\" result₀ during the reduction.\n\nSee wrapping, unwrap, and start.\n\n\n\n\n\n","category":"function"},{"location":"reference/interface/#Transducers.unwrap","page":"Interface","title":"Transducers.unwrap","text":"unwrap(rf, result)\n\nUnwrap wraped result to a private state and inner result. Following identity holds:\n\nunwrap(rf, wrap(rf, state, iresult)) == (state, iresult)\n\nThis is intended to be used only in complete.  Inside next, use wrapping.\n\n\n\n\n\n","category":"function"},{"location":"reference/interface/#Transducers.wrapping","page":"Interface","title":"Transducers.wrapping","text":"wrapping(f, rf, result)\n\nFunction f must take two argument state and iresult, and return a tuple (state, iresult).  This is intended to be used only in next, possibly with a do block.\n\nnext(rf::R_{MyTransducer}, result, input) =\n    wrapping(rf, result) do my_state, iresult\n        # code calling `next(inner(rf), iresult, possibly_modified_input)`\n        return my_state, iresult  # possibly modified\n    end\n\nSee wrap, unwrap, and next.\n\n\n\n\n\n","category":"function"},{"location":"reference/interface/#Interface-for-reducibles","page":"Interface","title":"Interface for reducibles","text":"","category":"section"},{"location":"reference/interface/","page":"Interface","title":"Interface","text":"Transducers.__foldl__\nTransducers.@return_if_reduced","category":"page"},{"location":"reference/interface/#Transducers.__foldl__","page":"Interface","title":"Transducers.__foldl__","text":"__foldl__(rf, init, reducible::T)\n\nLeft fold a reducible with reducing function rf and initial value init.  This is primary an API for overloading when the reducible \"container\" or \"context\" (e.g., I/O stream) of type T can provide a better reduction mechanism than the default iterator-based one.\n\nFor a simple iterable type MyType, a valid implementation is:\n\nfunction __foldl__(rf, val, itr::MyType)\n    for x in itr\n        val = @next(rf, val, x)\n    end\n    return complete(rf, val)\nend\n\nalthough in this case default __foldl__ can handle MyType and thus there is no need for defining it.  In general, defining __foldl__ is useful only when there is a better way to go over items in reducible than Base.iterate.\n\nSee also: @next.\n\n\n\n\n\n","category":"function"},{"location":"reference/interface/#Transducers.@return_if_reduced","page":"Interface","title":"Transducers.@return_if_reduced","text":"@return_if_reduced expr\n\nIt transforms the given expression to:\n\nval = expr\nval isa Reduced && return val\nval\n\nSee also @next.\n\ncompat: Transducers.jl 0.3\nIn v0.2, the calling convention was @return_if_reduced complete(rf, val) and it was transformed to val isa Reduced && return reduced(complete(rf, unreduced(val))).  For the rationale behind the change, see this commit message.\n\nExamples\n\njulia> using Transducers: @return_if_reduced\n\njulia> @macroexpand @return_if_reduced f(x)\nquote\n    #158#val = f(x)\n    #= ... =#\n    begin\n        #158#val isa Transducers.Reduced && return #158#val\n        #= ... =#\n        #158#val\n    end\nend\n\n\n\n\n\n","category":"macro"},{"location":"#Transducers-for-Julia","page":"Home","title":"Transducers for Julia","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DocTestSetup = quote\n    using Transducers\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"Transducers are transformations of \"sequence\" of input that can be composed very efficiently.  The interface used by transducers naturally describes a wide range of processes that is expressible as a succession of steps. Furthermore, transducers can be defined without specifying the details of the input and output (collections, streams, channels, etc.)  and therefore achieves a full reusability.  Transducers are introduced by Rich Hickey, the creator of the Clojure language. His Strange Loop talk is a great introduction to the idea of transducers.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Transducers.jl is an implementation of the transducers in Julia. Aiming to satisfy high-performance needs of Julia users, Transducers.jl uses a formulation that is pure [pure] and aiding type-stability.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Sequential, multi-threaded, and distributed computation with a single API –- transducers (see overview of parallel processing).\nSupport various table types including DataFrames.jl, StructArrays.jl, TypedTables.jl, etc. using Tables.jl and BangBang.jl API (see copy, etc.).\nOnlineStats.jl integration.\nRobust typocalypse-free implementation of map, collect, and alike based on mutate-or-widen strategy implemented in BangBang.jl.\nUser interface-agnostic progress bar support based on ProgressLogging.jl that works with threaded and distributed processing (see withprogress).","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"Transducers\")","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you are familiar with iterators (see also Base.Iterators and IterTools.jl) it would look very familiar to you:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Transducers\n\njulia> 1:3 |> Map(x -> 2x) |> collect  # double each element\n3-element Array{Int64,1}:\n 2\n 4\n 6\n\njulia> 1:6 |> Filter(iseven) |> collect  # collect only evens\n3-element Array{Int64,1}:\n 2\n 4\n 6\n\njulia> 1:3 |> MapCat(x -> 1:x) |> collect  # concatenate mapped results\n6-element Array{Int64,1}:\n 1\n 1\n 2\n 1\n 2\n 3\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"Transducers can be composed (without, unlike iterators, referring to the input):","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> 1:6 |> Filter(iseven) |> Map(x -> 2x) |> collect\n3-element Array{Int64,1}:\n  4\n  8\n 12","category":"page"},{"location":"","page":"Home","title":"Home","text":"An efficient way to use transducers is combination with foldl.  This computation is done without creating any intermediate lazy object and compiles to a single loop:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> foldl(+, 1:6 |> Filter(iseven) |> Map(x -> 2x))\n24","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more detailed discussions on the difference to iterators, see Comparison to iterators.","category":"page"},{"location":"#List-of-transducers","page":"Home","title":"List of transducers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Here is the list of pre-defined transducers:","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Markdown\nimport Transducers\nMarkdown.MD(Transducers.TransducerLister())","category":"page"},{"location":"#Links","page":"Home","title":"Links","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"\"Transducers\" by Rich Hickey - YouTube\nRich Hickey - Inside Transducers - YouTube\nCppCon 2015: Juan Pedro Bolívar Puente “Transducers: from Clojure to C++\" - YouTube","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"[pure]: ...although not pure in the strong sense as Base.@pure.","category":"page"}]
}
