<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial: Missing values · Transducers.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Transducers.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><a class="toctext" href="../../manual/">Manual</a></li><li><a class="toctext" href="../../interface/">Interface</a></li><li><span class="toctext">Examples</span><ul><li class="current"><a class="toctext" href>Tutorial: Missing values</a><ul class="internal"><li><a class="toctext" href="#Dot-product-1">Dot product</a></li><li><a class="toctext" href="#Covariance-1">Covariance</a></li><li><a class="toctext" href="#Addition-1">Addition</a></li><li><a class="toctext" href="#Vectorized-reduction-1">Vectorized reduction</a></li><li><a class="toctext" href="#Argmax-1">Argmax</a></li></ul></li><li><a class="toctext" href="../words/">Parallel word count</a></li><li><a class="toctext" href="../primes/">Prime sieve</a></li><li><a class="toctext" href="../transducers/">Writing transducers</a></li><li><a class="toctext" href="../reducibles/">Writing reducibles</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Examples</li><li><a href>Tutorial: Missing values</a></li></ul><a class="edit-page" href="https://github.com/tkf/Transducers.jl/blob/master/examples/tutorial_missings.jl"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Tutorial: Missing values</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Tutorial:-missing-value-handling-1" href="#Tutorial:-missing-value-handling-1">Tutorial: missing value handling</a></h1><p>This tutorial illustrates the usage of Transducers.jl by stepping through various handling of missing values.</p><div><pre><code class="language-julia">using Transducers</code></pre></div><h2><a class="nav-anchor" id="Dot-product-1" href="#Dot-product-1">Dot product</a></h2><p>Here is a simple way to compute a dot product using <a href="../../manual/#Base.mapfoldl"><code>mapfoldl</code></a> and <a href="../../manual/#Transducers.MapSplat"><code>MapSplat</code></a>:</p><div><pre><code class="language-julia">mapfoldl(MapSplat(*), +, zip(1:3, 10:2:14))</code></pre><pre><code class="language-none">76</code></pre></div><p>Let&#39;s see what it does step by step.  First we create a &quot;printer&quot; transducer using this function (see <a href="../../manual/#Transducers.Map"><code>Map</code></a>):</p><div><pre><code class="language-julia">xf_printer(label) = Map() do x
    println(label, &quot;: &quot;, x)
    return x  # just return it as-is
end</code></pre></div><p>This transducer just pass-through the input while printing its value (prefixed by a <code>label</code>).  Let&#39;s sandwich the previous <code>MapSplat(*)</code> with it:</p><div><pre><code class="language-julia">_ = mapfoldl(
    xf_printer(&quot; input&quot;) |&gt; MapSplat(*) |&gt; xf_printer(&quot;output&quot;),
    +, zip(1:3, 10:2:14))</code></pre><pre><code class="language-none"> input: (1, 10)
output: 10
 input: (2, 12)
output: 24
 input: (3, 14)
output: 42</code></pre></div><p>You can see that the input tuple <code>(1, 10)</code> is splatted into function <code>*</code> by <code>MapSplat</code> which then outputs <code>10</code>.  This is repeated for all inputs.</p><p>Perhaps unfortunately, this way of computing a dot product propagates any missing values contained in the input arrays to the result (which may actually be desired in certain cases).</p><div><pre><code class="language-julia">xs = [1, missing, 3, 2]
ys = [10, 14, missing, 12]
mapfoldl(MapSplat(*), +, zip(xs, ys))</code></pre><pre><code class="language-none">missing</code></pre></div><p>However, it is very simple to ignore any missing values using <a href="../../manual/#Transducers.NotA"><code>NotA</code></a>:</p><div><pre><code class="language-julia">xf_mdot = MapSplat(*) |&gt; NotA(Missing)
mapfoldl(xf_mdot, +, zip(xs, ys))</code></pre><pre><code class="language-none">34</code></pre></div><h2><a class="nav-anchor" id="Covariance-1" href="#Covariance-1">Covariance</a></h2><p>This transducer <code>xf_mdot</code> can also be used to compute the covariance.  First, we need the number of pairs of elements in <code>xs</code> and <code>ys</code> that <em>both</em> of them are not <code>missing</code>:</p><div><pre><code class="language-julia">nonmissings = mapfoldl(xf_mdot |&gt; Count(), right, zip(xs, ys); init=0)</code></pre><pre><code class="language-none">2</code></pre></div><div></div><p>We do this by using <a href="../../manual/#Transducers.Count"><code>Count</code></a> and <a href="../../manual/#Transducers.right"><code>right</code></a>.  <code>Count</code> ignores input and count the number of times the input is provided. Since <code>xf_mdot</code> provides the inputs to the downstream transducer, this correctly counts the number of non-missing pairs.  Function <code>right</code> is simply defined as <code>right(l, r) = r</code> (and <code>right(r) = r</code>). Thus, the whole <code>mapfoldl</code> returns the last output of <code>Count</code>.  In case <code>Count</code> never gets called (i.e., there are no non-missing pairs), we pass <code>init=0</code>.</p><div><pre><code class="language-julia">mapfoldl(xf_mdot |&gt; Count(), right, zip(Int[], Int[]); init=0)</code></pre><pre><code class="language-none">0</code></pre></div><div></div><p>Finally, we have to pre-process the input to <code>xf_mdot</code> by subtracting the average.  It&#39;s easy to do with <code>Map</code>:</p><div><pre><code class="language-julia">using Statistics: mean

function xf_demean(xs, ys)
    xmean = mean(skipmissing(xs))
    ymean = mean(skipmissing(ys))
    return Map(((x, y),) -&gt; (x - xmean, y - ymean))
end

mapfoldl(xf_demean(xs, ys) |&gt; xf_mdot, +, zip(xs, ys)) / nonmissings</code></pre><pre><code class="language-none">1.0</code></pre></div><h2><a class="nav-anchor" id="Addition-1" href="#Addition-1">Addition</a></h2><p>How do we use transducers for vector-to-vector transformation?  Here is a function to calculate <span>$y = x + y$</span> while ignoring missing values in <span>$x$</span>.</p><div><pre><code class="language-julia">function add_skipmissing!(ys, xs)
    length(ys) == length(xs) || error(&quot;length(ys) != length(xs)&quot;)</code></pre></div><p>For filtering out missing values from <code>xs</code> while tracking indices, we use <a href="../../manual/#Transducers.Zip-Tuple"><code>Zip</code></a>.  To iterate over the output of the transducer, <a href="../../manual/#Base.foreach"><code>foreach</code></a> is used instead of <a href="../../manual/#Base.mapfoldl"><code>mapfoldl</code></a> since mutating an array is better expressed as a side-effect than a fold.</p><div><pre><code class="language-julia">    foreach(Zip(Count(), NotA(Missing)), xs) do (i, xi)
        @inbounds ys[i] += xi
    end</code></pre></div><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>Note the difference between <code>Zip(Count(), NotA(Missing))</code> and <code>Zip(NotA(Missing), Count())</code> in Transducers.jl.  The former enumerates all the elements in <code>xs</code> while the latter enumerates <em>only</em> non-missing values.</p></div></div><p>We then return the mutated value to behave like the rest of Julia functions (<code>push!</code>, <code>mul!</code>, etc.):</p><div><pre><code class="language-julia">    return ys
end</code></pre></div><p>Example:</p><div><pre><code class="language-julia">add_skipmissing!([100, 110, 120], [1, missing, 2])</code></pre></div><h2><a class="nav-anchor" id="Vectorized-reduction-1" href="#Vectorized-reduction-1">Vectorized reduction</a></h2><p><code>foldl</code>, <code>mapfoldl</code>, etc. in <code>Base</code> support <code>dims</code> argument. However, this can easily be emulated using <code>eachcol</code>, <code>eachrow</code>, or <code>eachslice</code> iterators in <code>Base</code>.</p><div><pre><code class="language-julia">xs = [
    0       missing 1       2
    3       4       5       missing
    missing 6       7       missing
]

function xf_sum_columns(prototype)
    T = Base.nonmissingtype(eltype(prototype)) # subtract Missing from type
    dims = size(prototype)
    return Scan(add_skipmissing!, Initializer(() -&gt; zeros(T, dims)))
end</code></pre></div><p>We use <a href="../../manual/#Transducers.Initializer"><code>Initializer</code></a> here to allocate the &quot;output array&quot; into which the columns are added by <code>add_skipmissing!</code>.</p><div><pre><code class="language-julia">mapfoldl(xf_sum_columns(xs[:, 1]), right, eachcol(xs))</code></pre><pre><code class="language-none">3-element Array{Int64,1}:
  3
 12
 13</code></pre></div><div></div><p>Above computation returns the sum over each row without taking into account the relationship within a column.  Another possibly useful reduction is the sum of the columns with no missing values.  This can easily be done by prepending a filter:</p><div><pre><code class="language-julia">mapfoldl(Filter(x -&gt; !any(ismissing, x)) |&gt; xf_sum_columns(xs[:, 1]),
         right, eachcol(xs))</code></pre><pre><code class="language-none">3-element Array{Int64,1}:
 1
 5
 7</code></pre></div><div></div><p>Note that above combination of <code>Scan</code> and <code>right</code> is redundant.  For example, we can simply pass <code>add_skipmissing!</code> to &quot;normal&quot; <code>foldl</code>:</p><div><pre><code class="language-julia">foldl(add_skipmissing!, eachcol(xs), init=zeros(Int, size(xs, 1)))</code></pre><pre><code class="language-none">3-element Array{Int64,1}:
  3
 12
 13</code></pre></div><div></div><p>However, packaging it as a transducer is sometimes useful as it can be composed with other transducers and &quot;bottom&quot; reducing function. For example, vectorized version of <code>cumsum</code> can easily obtained by composing it with <code>append!</code> (and then <code>reshape</code> after <code>mapfoldl</code>):</p><div><pre><code class="language-julia">result = mapfoldl(
    xf_sum_columns(xs[:, 1]),
    Completing(append!),
    eachcol(xs);
    init = Int[])
reshape(result, (size(xs, 1), :))</code></pre><pre><code class="language-none">3×4 Array{Int64,2}:
 0  0   1   3
 3  7  12  12
 0  6  13  13</code></pre></div><div></div><p>Note that we need <a href="../../manual/#Transducers.Completing"><code>Completing</code></a> here since <code>append!</code> does not have the unary method used for <a href="../../interface/#Transducers.complete"><code>complete</code></a> protocol.</p><h2><a class="nav-anchor" id="Argmax-1" href="#Argmax-1">Argmax</a></h2><p>Another useful operation to do ignoring missing values is <code>argmax</code>/<code>argmin</code>.  It can be implemented as <code>Zip(Count(), ...)</code> (see also <code>add_skipmissing!</code> above) composed with <a href="../../manual/#Transducers.ScanEmit"><code>ScanEmit</code></a>:</p><div><pre><code class="language-julia">xf_argmax(xf_filter = NotA(Missing)) =
    Zip(Count(), xf_filter) |&gt; ScanEmit(argmax_step, (0, typemin(Int)))
#                                                     |
#                                              initial state (see below)</code></pre></div><p>where <code>argmax_step</code> passed to <code>ScanEmit</code> is defined as:</p><div><pre><code class="language-julia">#                     ,--- current state
#                     |
#                     |              ,-- input
#                     |              |
function argmax_step((argmax, max), (index, value))
    argmax, max = value &gt; max ? (index, value) : (argmax, max)
    return argmax, (argmax, max)
    #       \        \
    #        \        \__ next state
    #         \
    #          \__ output
end</code></pre></div><p>As <a href="../../manual/#Transducers.ScanEmit"><code>ScanEmit</code></a> is one of the most complex (and powerful) transducer, it may require some comments on how above code works:</p><ul><li><p>The state <code>(argmax, max)</code> is initialized to <code>(0, typemin(Int))</code> in <code>xf_argmax</code>.  This is the first value passed to the first argument <code>(argmax, max)</code> of <code>argmax_step</code>.</p></li><li><p>The upstream transducer <code>Zip(Count(), xf_filter)</code> provides <code>(index, value)</code>-pair which becomes the input (the second argument) of <code>argmax_step</code>.</p></li><li><p>Function <code>argmax_step</code> must return a pair.  The first item becomes the output of <code>ScanEmit</code>.  In this case that&#39;s the index of the largest item seen so far.</p></li><li><p>The second item in the returned pair is fed back to <code>argmax_step</code> in the next call.</p></li></ul><p>We have the argmax function by extracting the last output of <code>xf_argmax</code>:</p><div><pre><code class="language-julia">mapfoldl(xf_argmax(), right, [1, 3, missing, 2])</code></pre><pre><code class="language-none">2</code></pre></div><p>Side note: We use <code>typemin(Int)</code> as the initial value of <code>max</code> for simplicity.  In practice, it should be <code>typemin(eltype(input_array))</code>.</p><p>We can use filter other than <code>NotA(Missing)</code>.  For example, to find the index of the largest odd value:</p><div><pre><code class="language-julia">mapfoldl(xf_argmax(Filter(isodd)), right, [1, 4, 3, 2])</code></pre><pre><code class="language-none">3</code></pre></div><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p><footer><hr/><a class="previous" href="../../internals/"><span class="direction">Previous</span><span class="title">Internals</span></a><a class="next" href="../words/"><span class="direction">Next</span><span class="title">Parallel word count</span></a></footer></article></body></html>
