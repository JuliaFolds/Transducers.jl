<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial: Parallelism · Transducers.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Transducers.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../parallelism/">Parallelism</a></li><li><a class="tocitem" href="../../manual/">Manual</a></li><li><a class="tocitem" href="../../interface/">Interface</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../tutorial_missings/">Tutorial: Missing values</a></li><li class="is-active"><a class="tocitem" href>Tutorial: Parallelism</a><ul class="internal"><li><a class="tocitem" href="#Quick-examples-1"><span>Quick examples</span></a></li><li><a class="tocitem" href="#When-can-I-use-reduce-and-dreduce?-1"><span>When can I use <code>reduce</code> and <code>dreduce</code>?</span></a></li><li><a class="tocitem" href="#Example:-parallel-collect-1"><span>Example: parallel <code>collect</code></span></a></li><li><a class="tocitem" href="#Example:-ad-hoc-histogram-1"><span>Example: ad-hoc histogram</span></a></li><li><a class="tocitem" href="#Example:-early-termination-1"><span>Example: early termination</span></a></li></ul></li><li><a class="tocitem" href="../empty_result_handling/">Empty result handling</a></li><li><a class="tocitem" href="../words/">Parallel word count</a></li><li><a class="tocitem" href="../transducers/">Writing transducers</a></li><li><a class="tocitem" href="../reducibles/">Writing reducibles</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Tutorial: Parallelism</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial: Parallelism</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/tkf/Transducers.jl/blob/master/examples/tutorial_parallel.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="tutorial-parallel-1"><a class="docs-heading-anchor" href="#tutorial-parallel-1">Parallel processing tutorial</a><a class="docs-heading-anchor-permalink" href="#tutorial-parallel-1" title="Permalink"></a></h1><p>See also: <a href="../../parallelism/#overview-parallel-1">Overview of parallel processing in Transducers.jl</a></p><h2 id="Quick-examples-1"><a class="docs-heading-anchor" href="#Quick-examples-1">Quick examples</a><a class="docs-heading-anchor-permalink" href="#Quick-examples-1" title="Permalink"></a></h2><h3 id="Sequential-processing-1"><a class="docs-heading-anchor" href="#Sequential-processing-1">Sequential processing</a><a class="docs-heading-anchor-permalink" href="#Sequential-processing-1" title="Permalink"></a></h3><pre><code class="language-julia">using Transducers

xs = randn(10_000_000)
foldl(+, Map(sin), xs)</code></pre><pre><code class="language-none">-2340.292974385676</code></pre><h3 id="Thread-based-parallelism-1"><a class="docs-heading-anchor" href="#Thread-based-parallelism-1">Thread-based parallelism</a><a class="docs-heading-anchor-permalink" href="#Thread-based-parallelism-1" title="Permalink"></a></h3><p>Just replace <code>foldl</code> with <code>reduce</code>, to make use of multiple cores:</p><pre><code class="language-julia">reduce(+, Map(sin), xs)</code></pre><pre><code class="language-none">-2340.2929743860864</code></pre><p>(In my laptop (4 core machine) I start seeing some speedup around <code>length(xs) ≥ 100_000</code> for this transducers and reducing function.)</p><h3 id="Process-based-parallelism-1"><a class="docs-heading-anchor" href="#Process-based-parallelism-1">Process-based parallelism</a><a class="docs-heading-anchor-permalink" href="#Process-based-parallelism-1" title="Permalink"></a></h3><pre><code class="language-julia">using Distributed
addprocs(4)

dreduce(+, Map(sin), xs)</code></pre><pre><code class="language-none">-2340.2929743858017</code></pre><p>(Note: there is likely no speedup for light-weight computation and large input data like this, when using <code>dreduce</code>.)</p><h2 id="When-can-I-use-reduce-and-dreduce?-1"><a class="docs-heading-anchor" href="#When-can-I-use-reduce-and-dreduce?-1">When can I use <code>reduce</code> and <code>dreduce</code>?</a><a class="docs-heading-anchor-permalink" href="#When-can-I-use-reduce-and-dreduce?-1" title="Permalink"></a></h2><h3 id="Requirement-1:-Associative-reducing-step-function-1"><a class="docs-heading-anchor" href="#Requirement-1:-Associative-reducing-step-function-1">Requirement 1: Associative reducing step function</a><a class="docs-heading-anchor-permalink" href="#Requirement-1:-Associative-reducing-step-function-1" title="Permalink"></a></h3><p>Parallel reductions such as <a href="../../manual/#Base.reduce"><code>reduce</code></a> and <a href="../../manual/#Transducers.dreduce"><code>dreduce</code></a> requires <em>associative</em> <a href="../../#Glossary-1">reducing step function</a>. Recall that <a href="https://en.wikipedia.org/wiki/Associative_property">associativity</a> means that the <em>grouping</em> of evaluations of binary operator does not matter:</p><pre><code class="language-julia">op = +  # for example
a, b, c = 1, 2, 3  # for example

@assert op(op(a, b), c) == op(a, op(b, c))</code></pre><p>Given this property, computations like <code>a + b + c + d</code> can be done with different &quot;groupings&quot;:</p><pre><code class="language-none">  a + b + c + d

= ((a + b) + c) + d                +
                                  / \
                                 +   d
                                / \
                               +   c           foldl-like grouping
                              / \
                             a   b

= (a + b) + (c + d)                +
                                  / \
                                 /   \
                                /     \        reduce-like grouping
                               +       +
                              / \     / \
                             a   b   c   d</code></pre><p>Notice that, in the last grouping, computation of <code>c + d</code> does not have to wait for the result of <code>a + b</code>.  This is why we need associativity for parallel execution.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Do not confuse associativity with <em>commutativity</em> <code>op(a, b) = op(b, a)</code>.  For example, matrix multiplication <code>*(::Matrix, ::Matrix)</code> is associative but <em>not</em> commutative in general. However, since <code>reduce</code> only requires associativity, it is valid to use <code>reduce(*, xf, matrices)</code>.</p></div></div><p>As reducing function <code>+</code> is associative, it can be used with <code>reduce</code> (and <code>dreduce</code>):</p><pre><code class="language-julia">reduce(+, Map(identity), 1:10; init = 0, basesize = 1)</code></pre><pre><code class="language-none">55</code></pre><p>and the result is the same as the sequential version:</p><pre><code class="language-julia">foldl(+, Map(identity), 1:10; init = 0)</code></pre><pre><code class="language-none">55</code></pre><p>Note: <code>basesize</code> is for forcing <code>reduce</code> to avoid falling back to <code>foldl</code> for small length container such as <code>1:10</code>.</p><p>On the other hand, binary function <code>-</code> is not associative.  Thus, <code>reduce</code> cannot be used instead of <code>foldl</code> (they produce different result):</p><pre><code class="language-julia">reduce(-, Map(identity), 1:10; init = 0, basesize = 1)</code></pre><pre><code class="language-none">-5</code></pre><pre><code class="language-julia">foldl(+, Map(identity), 1:10; init = 0)</code></pre><pre><code class="language-none">55</code></pre><h3 id="Requirement-2:-stateless-transducers-1"><a class="docs-heading-anchor" href="#Requirement-2:-stateless-transducers-1">Requirement 2: stateless transducers</a><a class="docs-heading-anchor-permalink" href="#Requirement-2:-stateless-transducers-1" title="Permalink"></a></h3><p>Parallel reduction only work with stateless transducers <a href="../../manual/#Transducers.Map"><code>Map</code></a>, <a href="../../manual/#Transducers.Filter"><code>Filter</code></a>, <a href="../../manual/#Transducers.Cat"><code>Cat</code></a>, etc. and you will get an error when using stateful transducers such as <code>Scan</code> with <code>reduce</code> or <code>dreduce</code>:</p><pre><code class="language-julia">reduce(+, Scan(+), 1:10; basesize = 1)</code></pre><pre><code class="language-none">ERRPR: Stateful transducer Scan(+) does not support `combine`</code></pre><p>Stateful transducers cannot be used with <code>reduce</code> because it is impossible to start processing input collection from the middle when the transducers need to know all previous elements (= stateful).</p><p><a href="../../manual/#Transducers.ScanEmit"><code>ScanEmit</code></a> is a stateful transducer but it is assumed that it is used in a context that outputs can be treated as stateless (see: <a href="../words/#parallel-word-count-1">Splitting a string into words and counting them in parallel</a>).</p><h2 id="Example:-parallel-collect-1"><a class="docs-heading-anchor" href="#Example:-parallel-collect-1">Example: parallel <code>collect</code></a><a class="docs-heading-anchor-permalink" href="#Example:-parallel-collect-1" title="Permalink"></a></h2><p>Suppose (pretend) there is a compute-heavy transducer:</p><pre><code class="language-julia">xf_compute = Filter(!ismissing) |&gt; Map(x -&gt; x^2)</code></pre><p>Transducers.jl supports applying this to an input container and then collecting the results into another container.  It can be done sequentially (<a href="../../manual/#Base.collect"><code>collect</code></a>, <a href="../../manual/#Base.copy"><code>copy</code></a>, etc.) and in parallel using threads (<a href="../../manual/#Transducers.tcollect"><code>tcollect</code></a>, <a href="../../manual/#Transducers.tcopy"><code>tcopy</code></a>) or using multiple processes (<a href="../../manual/#Transducers.dcollect"><code>dcollect</code></a>, <a href="../../manual/#Transducers.dcopy"><code>dcopy</code></a>).  For example:</p><pre><code class="language-julia">xs = [abs(x) &gt; 1 ? missing : x for x in randn(10_000)]
y1 = collect(xf_compute, xs)</code></pre><p>Doing this in parallel is as easy as using <code>tcollect</code> or <code>dcollect</code>. However, it is easy to do this manually, too:</p><pre><code class="language-julia">using BangBang: append!!
using StaticArrays: SVector

y2 = reduce(append!!, xf_compute |&gt; Map(SVector), xs; init = Union{}[])
@assert y1 == y2</code></pre><p>This code illustrates the common pattern in parallel processing:</p><ol><li><p>Put a result from the transducer in a &quot;singleton solution&quot;. Here, it is a <code>SVector</code>.</p></li><li><p>Then &quot;merge&quot; the (singleton) solution into the exsiting one. This is done by <code>append!!</code> in the above example.</p></li></ol><p>Due to symmetry in the signature of the reducing step function <code>op</code> used for <code>reduce</code> (e.g., <code>+</code> and <code>append!!</code>; when ignoring mutation for <code>append!!</code>), it can be used for merging the singleton solutions directly passed from transducers as well as the &quot;chunks&quot; of results (e.g., <code>a + b</code> and <code>c + d</code> in the illustration above).  This is why <code>append!!</code> is used for parallel <code>collect</code> instead of <code>push!!</code>.</p><p>Reducing step function <code>op</code> for <code>reduce</code> often requires explicit initial value (i.e., keyword argument <code>init</code>).  In above example, omitting <code>init</code> would produce a long <code>SVector</code> that is impractical use; that&#39;s why <code>init = Union{}[]</code> is required.  Note that passing <code>Vector</code> to <code>init</code> of <code>reduce</code> is usually a wrong choice.  However, since <code>Vector{Union{}}</code> cannot have any element (as there is no object of type <code>Union{}</code>), <code>Union{}[]</code> is an exception and a good initial value to indicate that output vector should use the &quot;smallest&quot; <code>eltype</code> required.  That is to say, <code>append!!</code> widens the vector &quot;just enough&quot; to fit the resulting elements.</p><p>For generic containers (e.g., various table types), use <a href="https://tkf.github.io/BangBang.jl/dev/#BangBang.NoBang.singletonof-Union{Tuple{T},%20Tuple{Type{T},Any}}%20where%20T"><code>BangBang.Empty</code></a> as the empty initial value.</p><h2 id="Example:-ad-hoc-histogram-1"><a class="docs-heading-anchor" href="#Example:-ad-hoc-histogram-1">Example: ad-hoc histogram</a><a class="docs-heading-anchor-permalink" href="#Example:-ad-hoc-histogram-1" title="Permalink"></a></h2><p>Following example counts number of occurrence of each leading digit in a distribution of random numbers.  First, let&#39;s create &quot;singleton solutions&quot; using transducers:</p><pre><code class="language-julia">xf = Map(abs) |&gt;
    Filter(x -&gt; x &gt; 1) |&gt;
    Map() do x
        y = digits(floor(Int, x))[end]
        Dict(y =&gt; 1)
    end</code></pre><p>The singleton solutions can be merged using <code>merge!(+, a, b)</code>.  Note that we need to cover the &quot;edge cases&quot; where the first and/or second arguments are the initial values.  Note that passing <code>init = Dict{Int,Int}()</code> to <code>reduce</code> is not correct as multiple tasks would share and try to mutate the same dictionary this way.  One option is to use <a href="../../manual/#Transducers.OnInit"><code>init = OnInit(Dict{Int,Int})</code></a>.  Another option is to use <a href="https://tkf.github.io/InitialValues.jl/dev/#InitialValues.asmonoid"><code>asmonoid</code></a> for handling the initial values:</p><pre><code class="language-julia">using InitialValues: asmonoid
merge₊! = asmonoid((a, b) -&gt; merge!(+, a, b))</code></pre><p>Let&#39;s try this with some random data:</p><pre><code class="language-julia">xs = 1_000_000 * randn(10_000_000)
counts1 = reduce(merge₊!, xf, xs)</code></pre><p>Compare the result with <code>foldl</code>:</p><pre><code class="language-julia">counts2 = foldl(merge₊!, xf, xs)
@assert counts1 == counts2</code></pre><p>Hopefully the result is close to the <a href="https://en.wikipedia.org/wiki/Benford%27s_law">Benford&#39;s law - Wikipedia</a>:</p><pre><code class="language-julia">let n = sum(values(counts1))
    sort!(keys(counts1) .=&gt; values(counts1) ./ n)
end</code></pre><pre><code class="language-none">9-element Array{Pair{Int64,Float64},1}:
 1 =&gt; 0.3594109594109594  
 2 =&gt; 0.1289192289192289  
 3 =&gt; 0.0864905864905865  
 4 =&gt; 0.08106238106238106 
 5 =&gt; 0.07738827738827739 
 6 =&gt; 0.07341567341567341 
 7 =&gt; 0.06907636907636908 
 8 =&gt; 0.06452906452906453 
 9 =&gt; 0.059707459707459706</code></pre><p>Since we are counting only nine elements, it is actually better to use fixed-size container such as a tuple in this case:</p><pre><code class="language-julia">xf2 = Map(abs) |&gt;
    Filter(x -&gt; x &gt; 1) |&gt;
    Map() do x
        y = digits(floor(Int, x))[end]
        ntuple(i -&gt; i == y, 9)
    end

counts3 = reduce(xf2, xs; init=ntuple(_ -&gt; 0, 9)) do a, b
    map(+, a, b)
end
@assert Dict(zip(1:9, counts3)) == counts1</code></pre><p>Note that, as tuples are immutable, it is valid to pass it as <code>init</code> of <code>reduce</code>.</p><h2 id="Example:-early-termination-1"><a class="docs-heading-anchor" href="#Example:-early-termination-1">Example: early termination</a><a class="docs-heading-anchor-permalink" href="#Example:-early-termination-1" title="Permalink"></a></h2><p>Find the <em>first</em> element that is multiple of three:</p><pre><code class="language-julia">reduce(Map(x -&gt; x % 3 == 0 ? x : nothing), 1:10; init = nothing, basesize = 1) do a, b
    c = something(a, b, Some(nothing))

    # # Uncomment for demo:
    # c == 3 &amp;&amp; sleep(0.1)  # give other tasks a chance to finish first
    # c === nothing || @show c

    c === nothing ? nothing : reduced(c)
end</code></pre><pre><code class="language-none">3</code></pre><p>This snippet always returns <code>3</code>, even though the reductions for <code>c = 6</code> and <code>c = 9</code> may finish first.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial_missings/">« Tutorial: Missing values</a><a class="docs-footer-nextpage" href="../empty_result_handling/">Empty result handling »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 14 December 2019 05:35">Saturday 14 December 2019</span>. Using Julia version 1.3.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
