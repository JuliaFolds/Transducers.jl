<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Parallel word count · Transducers.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Transducers.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><a class="toctext" href="../../manual/">Manual</a></li><li><a class="toctext" href="../../interface/">Interface</a></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../tutorial_missings/">Tutorial: Missing values</a></li><li><a class="toctext" href="../empty_result_handling/">Empty result handling</a></li><li class="current"><a class="toctext" href>Parallel word count</a><ul class="internal"><li><a class="toctext" href="#String-splitting-transducer-1">String-splitting transducer</a></li><li><a class="toctext" href="#Word-counting-transducer-1">Word-counting transducer</a></li></ul></li><li><a class="toctext" href="../primes/">Prime sieve</a></li><li><a class="toctext" href="../transducers/">Writing transducers</a></li><li><a class="toctext" href="../reducibles/">Writing reducibles</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Examples</li><li><a href>Parallel word count</a></li></ul><a class="edit-page" href="https://github.com/tkf/Transducers.jl/blob/master/examples/words.jl"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Parallel word count</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Splitting-a-string-into-words-and-counting-them-in-parallel-1" href="#Splitting-a-string-into-words-and-counting-them-in-parallel-1">Splitting a string into words and counting them in parallel</a></h1><p>We start from the parallel algorithm presented in Guy Steele&#39;s 2009 ICFP talk <a href="https://vimeo.com/6624203">(video)</a>.  It splits a space-separated string into list of strings (words).  The repeating theme in the talk was to build &quot;singleton solutions&quot; and then merge them together using an associative function.  We will follow this guideline and slightly extend the algorithm.</p><p>It is highly recommended to just watch the talk for understanding the algorithm.  However, we briefly describe how it works.</p><p>When a certain contiguous region of a string is processed, we either already have seen at least one space or not.  These two states are tracked using following two types.  If there is no space so far, we only have a chunk of a possibly larger word (see example below):</p><pre><code class="language-julia">struct Chunk
    s::String
end</code></pre><p>If there are one or more spaces, (possibly zero) words that are already determined and left/right &quot;chunks&quot; have to be tracked separately:</p><pre><code class="language-julia">struct Segment
    l::String
    A::Vector{String}
    r::String
end</code></pre><p>Here is an example taken from the talk:</p><pre><code class="language-none">Segment(&quot;Here&quot;, [&quot;is&quot;, &quot;a&quot;], &quot;&quot;)
   |
   |       Segment(&quot;lian&quot;, [], &quot;string&quot;)
 __|_____            _|______
|        |          |        |
Here is a sesquipedalian string of words
          |________|          |________|
   Chunk(&quot;sesquipeda&quot;)        Segment(&quot;g&quot;, [&quot;of&quot;], &quot;words&quot;)</code></pre><p>We then need a way to merge two results which can independently in one of the above two states.</p><pre><code class="language-julia">⊕(x::Chunk, y::Chunk) = Chunk(x.s * y.s)
⊕(x::Chunk, y::Segment) = Segment(x.s * y.l, y.A, y.r)
⊕(x::Segment, y::Chunk) = Segment(x.l, x.A, x.r * y.s)
⊕(x::Segment, y::Segment) =
    Segment(x.l,
            append!(append!(x.A, maybewordv(x.r * y.l)), y.A),
            y.r)

maybewordv(s::String) = isempty(s) ? String[] : [s]</code></pre><p>Input is a sequence of <code>Char</code>s.  Each of them has to be converted into a &quot;singleton solution&quot; which can be merged with already aggregated (or another singleton) solution with <code>⊕</code>:</p><pre><code class="language-julia">segmentorchunk(c::Char) = c == &#39; &#39; ? Segment(&quot;&quot;, [], &quot;&quot;) : Chunk(string(c))</code></pre><p>Putting them together, we get:</p><pre><code class="language-julia">function collectwords(s::String)
    g = mapfoldl(segmentorchunk, ⊕, s; init=Segment(&quot;&quot;, [], &quot;&quot;))
    if g isa Char
        return maybewordv(g.s)
    else
        return append!(append!(maybewordv(g.l), g.A), maybewordv(g.r))
    end
end</code></pre><p>Let&#39;s run a few tests covering some edge cases:</p><pre><code class="language-julia">using Test
@testset begin
    @test collectwords(&quot;This is a sample&quot;) == [&quot;This&quot;, &quot;is&quot;, &quot;a&quot;, &quot;sample&quot;]
    @test collectwords(&quot; Here is another sample &quot;) == [&quot;Here&quot;, &quot;is&quot;, &quot;another&quot;, &quot;sample&quot;]
    @test collectwords(&quot;JustOneWord&quot;) == [&quot;JustOneWord&quot;]
    @test collectwords(&quot; &quot;) == []
    @test collectwords(&quot;&quot;) == []
end</code></pre><pre><code class="language-none">Test Summary: | Pass  Total
test set      |    5      5</code></pre><h2><a class="nav-anchor" id="String-splitting-transducer-1" href="#String-splitting-transducer-1">String-splitting transducer</a></h2><p>Let&#39;s try to make it re-usable by packaging it into transducers.</p><pre><code class="language-julia">using Transducers</code></pre><p>Rather than accumulating words into a vector, we are going to write a transducer that &quot;emits&quot; a word as soon as it is ready.  The downstream transducer may choose to record everything or only aggregate, e.g., reduced statistics.  To this end, we replace <code>Segment</code> in the original algorithm to</p><pre><code class="language-julia">struct Vacant
    l::String
    r::String
end</code></pre><p>and output the words in the &quot;middle&quot; without accumulating it.  We use <a href="../../manual/#Transducers.ScanEmit"><code>ScanEmit</code></a> which requires an operator/function like <code>⊕</code> above but returning a pair of output and next state.  This function (<code>extract</code> below) must have the signature <code>(S, S) -&gt; (O, S)</code> where <code>S</code> is the type for accumulated state and input and <code>O</code> is the output type.</p><pre><code class="language-julia">extract(x::Chunk, y::Chunk) = (), Chunk(x.s * y.s)
extract(x::Chunk, y::Vacant) = (), Vacant(x.s * y.l, y.r)
extract(x::Vacant, y::Chunk) = (), Vacant(x.l, x.r * y.s)
extract(x::Vacant, y::Vacant) = maybewordt(x.r * y.l), Vacant(x.l, y.r)

maybewordt(s) = isempty(s) ? () : (s,)</code></pre><p><code>maybewordt(x.r * y.l)</code> in <code>extract(x::Vacant, y::Vacant)</code> is the &quot;emission&quot;.</p><p>The words at the beginning and/or the end are not handled by <code>extract</code>.  This must be handled separately:</p><pre><code class="language-julia">lastword(x::Chunk) = maybewordt(x.s)
lastword(x::Vacant) = (maybewordt(x.r)..., maybewordt(x.l)...)

vacantorchunk(c::Char) = c == &#39; &#39; ? Vacant(&quot;&quot;, &quot;&quot;) : Chunk(string(c))

wordsxf = Map(vacantorchunk) |&gt; ScanEmit(extract, Chunk(&quot;&quot;), lastword) |&gt; Cat()</code></pre><pre><code class="language-none">Map(vacantorchunk) |&gt;
    ScanEmit(extract, Chunk(&quot;&quot;), lastword) |&gt;
    Cat()</code></pre><p>Test:</p><pre><code class="language-julia">@testset begin
    @test collect(wordsxf, &quot;This is a sample&quot;) == [&quot;is&quot;, &quot;a&quot;, &quot;sample&quot;, &quot;This&quot;]
    @test collect(wordsxf, &quot; Here is another sample &quot;) == [&quot;Here&quot;, &quot;is&quot;, &quot;another&quot;, &quot;sample&quot;]
    @test collect(wordsxf, &quot;JustOneWord&quot;) == [&quot;JustOneWord&quot;]
    @test collect(wordsxf, &quot; &quot;) == []
    @test collect(wordsxf, &quot;&quot;) == []
end</code></pre><pre><code class="language-none">Test Summary: | Pass  Total
test set      |    5      5</code></pre><p>Side note: In the first example, the first word <code>This</code> comes last. This is actually expected since both <code>.l</code> and <code>.r</code> are flushed in <code>lastword</code> which is called at the very end.  Here, <code>This</code> is stored in <code>.l</code> field.  If the order of the words is important, there are many possible fixes.  For example, <code>extract</code> and <code>lastword</code> can bundle information about the origin of the word (left vs middle-or-right).  Alternatively, perhaps the easiest solution is to insert a space in the beginning of input data.</p><h2><a class="nav-anchor" id="Word-counting-transducer-1" href="#Word-counting-transducer-1">Word-counting transducer</a></h2><p>We can pipe the resulting words into various transducers.</p><pre><code class="language-julia">processcount(word) = Base.ImmutableDict(word =&gt; 1)
countxf = wordsxf |&gt; Map(processcount)</code></pre><pre><code class="language-none">Map(vacantorchunk) |&gt;
    ScanEmit(extract, Chunk(&quot;&quot;), lastword) |&gt;
    Cat() |&gt;
    Map(processcount)</code></pre><p>Transducer <code>countxf</code> constructs a &quot;singleton solution&quot; as a dictionary which then accumulated with the associative reducing step function <code>mergecont!</code>:</p><pre><code class="language-julia">mergecont!(a, b) = merge!(+, a, b)
mergecont!(a) = a</code></pre><p>Note that the unary form is required for the completion. Alternatively, we can use <a href="../../manual/#Transducers.Completing"><code>Completing((a, b) -&gt; merge!(+, a, b))</code></a> instead of <code>mergecont!</code>.  Putting the transducer and reducing function together, we get:</p><pre><code class="language-julia">countwords(s; kwargs...) =
    mapreduce(Map(Char) |&gt; countxf,
              mergecont!,
              transcode(UInt8, s);
              init = CopyInit(Dict{String,Int}()),
              kwargs...)</code></pre><p>Side note: Since <a href="../../manual/#Base.mapreduce"><code>mapreduce</code></a> does not support string, the input string is converted to a <code>Vector{UInt8}</code> first by <code>transcode</code>. That&#39;s why there is <code>Map(Char) |&gt;</code> before <code>countxf</code>.  Of course, this is not valid for UTF-8 in general.</p><p>Side note 2: We use <a href="../../manual/#Transducers.CopyInit"><code>CopyInit</code></a> to create a fresh initial state for each sub-reduce to avoid overwriting mutable data between threads.</p><p>Let&#39;s run some tests with different number of threads:</p><pre><code class="language-julia">@testset for nthreads in [1, 2, 4]
    @test countwords(&quot;This is a sample&quot;, nthreads=nthreads) ==
        Dict(&quot;This&quot; =&gt; 1, &quot;is&quot; =&gt; 1, &quot;a&quot; =&gt; 1, &quot;sample&quot; =&gt; 1)
    @test countwords(&quot; Here is another sample &quot;, nthreads=nthreads) ==
        Dict(&quot;Here&quot; =&gt; 1, &quot;is&quot; =&gt; 1, &quot;another&quot; =&gt; 1, &quot;sample&quot; =&gt; 1)
    @test countwords(&quot;JustOneWord&quot;, nthreads=nthreads) ==
        Dict(&quot;JustOneWord&quot; =&gt; 1)
    @test countwords(&quot; &quot;, nthreads=nthreads) == Dict()
    @test countwords(&quot;&quot;, nthreads=nthreads) == Dict()
    @test countwords(&quot;aaa bb aaa aaa bb bb aaa&quot;, nthreads=nthreads) ==
        Dict(&quot;aaa&quot; =&gt; 4, &quot;bb&quot; =&gt; 3)
end</code></pre><pre><code class="language-none">Test Summary: | Pass  Total
nthreads = 1  |    6      6
Test Summary: | Pass  Total
nthreads = 2  |    6      6
Test Summary: | Pass  Total
nthreads = 4  |    6      6</code></pre><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p><footer><hr/><a class="previous" href="../empty_result_handling/"><span class="direction">Previous</span><span class="title">Empty result handling</span></a><a class="next" href="../primes/"><span class="direction">Next</span><span class="title">Prime sieve</span></a></footer></article></body></html>
