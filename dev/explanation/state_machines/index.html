<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>State machines · Transducers.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Transducers.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../../reference/manual/">Manual</a></li><li><a class="tocitem" href="../../reference/interface/">Interface</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/tutorial_missings/">Tutorial: Missing values</a></li><li><a class="tocitem" href="../../tutorials/tutorial_parallel/">Tutorial: Parallelism</a></li><li><a class="tocitem" href="../../tutorials/words/">Parallel word count</a></li></ul></li><li><span class="tocitem">How-to guides</span><ul><li><a class="tocitem" href="../../howto/upgrade-to-ixf/">Upgrade to new <code>|&gt;</code> of Transducers.jl 0.4.39</a></li><li><a class="tocitem" href="../../howto/empty_result_handling/">Empty result handling</a></li><li><a class="tocitem" href="../../howto/transducers/">Writing transducers</a></li><li><a class="tocitem" href="../../howto/reducibles/">Writing reducibles</a></li><li><a class="tocitem" href="../../howto/useful_patterns/">Useful patterns</a></li></ul></li><li><span class="tocitem">Explanation</span><ul><li><a class="tocitem" href="../../parallelism/">Parallelism</a></li><li><a class="tocitem" href="../comparison_to_iterators/">Comparison to iterators</a></li><li><a class="tocitem" href="../glossary/">Glossary</a></li><li class="is-active"><a class="tocitem" href>State machines</a><ul class="internal"><li><a class="tocitem" href="#Consecutive(N;-step-1)"><span><code>Consecutive(N; step = 1)</code></span></a></li><li><a class="tocitem" href="#WordsXF()"><span><code>WordsXF()</code></span></a></li><li><a class="tocitem" href="#ReducePartitionBy(f,-rf,-[init])"><span><code>ReducePartitionBy(f, rf, [init])</code></span></a></li><li><a class="tocitem" href="#ReduceSplitBy(f,-rf,-init)"><span><code>ReduceSplitBy(f, rf, init)</code></span></a></li><li><a class="tocitem" href="#tail-call-function-barrier"><span>Tail-call &quot;function-barrier&quot; pattern</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Explanation</a></li><li class="is-active"><a href>State machines</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>State machines</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaFolds/Transducers.jl/blob/master/docs/src/explanation/state_machines.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Accumulator-type-transitions-as-state-machines"><a class="docs-heading-anchor" href="#Accumulator-type-transitions-as-state-machines">Accumulator type transitions as state machines</a><a id="Accumulator-type-transitions-as-state-machines-1"></a><a class="docs-heading-anchor-permalink" href="#Accumulator-type-transitions-as-state-machines" title="Permalink"></a></h1><p>Some stateful transducers encode the &quot;phase&quot; of reduction as the type of the accumulator (its private state) to achieve efficient composable reductions. This is frequently true especially for parallelizable transducers (i.e., monoid transformations). See the linked docstrings for how each transducer works.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Here, we use the words <em>accumulator</em> and <em>private state</em> interchangeably. However, note that the state shown in the following diagrams only represent a single component in the &quot;composite&quot; accumulator as in <code>acc</code> of <a href="../../reference/interface/#Transducers.__foldl__"><code>__foldl__(rf, acc, xs)</code></a>. For example, for a reducing function</p><pre><code class="language-julia">rf = (Consecutive(1, 1) ⨟ ReducePartitionBy(f, rf1))&#39;(rf2)</code></pre><p>composed of two transducers and one bottom <a href="../glossary/#glossary-rf">reducing function</a> <code>rf2</code>, the accumulator <code>acc</code> of it has the type transition that is a composition of <code>Consecutive</code>, <code>ReducePartitionBy</code>, and <code>rf2</code>.</p></div></div><h2 id="Consecutive(N;-step-1)"><a class="docs-heading-anchor" href="#Consecutive(N;-step-1)"><code>Consecutive(N; step = 1)</code></a><a id="Consecutive(N;-step-1)-1"></a><a class="docs-heading-anchor-permalink" href="#Consecutive(N;-step-1)" title="Permalink"></a></h2><p><a href="../../reference/manual/#Transducers.Consecutive"><code>Consecutive</code></a> with <code>step = 1</code> first accumulate <code>N-1</code> elements and then start emitting tuples of size <code>N</code>. The private state of the transducer (in each base case) can be illustrated as follows.</p><p><img src="../SingleStepConsecutive.svg" alt/></p><p>For <code>Consecutive(N; step = 1)</code> transducer, the types of the private state are <code>Buffer{0}</code> (initial value), <code>Buffer{1}</code>, <code>Buffer{2}</code>, ..., <code>Buffer{N-2}</code>, and <code>Buffer{N-1}</code>, defined as:</p><pre><code class="language-julia">Left{K} = NTuple{K,Any}
Right{K} = NTuple{K,Any}
Buffer{K} = Tuple{Left{K}, Right{K}}  # K = 0, 1, ..., N-1</code></pre><p>The <code>Right{K}</code> component of <code>Buffer</code> tuple keeps the most recent <code>K</code> elements this transducer received. Once the state reaches to the type <code>Buffer{N-1}</code>, this transducer start emitting an <code>N</code>-tuple for each iteration (as indicated in the edge label <code>NTuple{N,Any}</code>). The loop with the accumulator of type <code>Buffer{N-1}</code> is the major component of the loop (i.e., it is used <span>$O(\mathrm{length(xs)})$</span> times when reducing an input collection <span>$\mathrm{xs}$</span>). The &quot;main loop&quot; accumulators such as <code>Buffer{N-1}</code> are marked by the double circles. The accumulator types used only for <span>$O(1)$</span> times are marked by the single circles and called <em>prelude</em> (ref <a href="../internals/#Transducers.is_prelude"><code>is_prelude</code></a>). See <a href="#tail-call-function-barrier">tail-call &quot;function-barrier&quot; pattern</a> for how this information is used to generate efficient reductions.</p><p>The <code>Left{K}</code> component of <code>Buffer</code> tuple keeps the first <code>K</code> elements observed in this base case; this is used only in the parallel reduction, for combining to the base case left to this base case.</p><p>The private state of <a href="../../reference/manual/#Transducers.Consecutive"><code>Consecutive</code></a> with <code>step &gt; 1</code> additionally contains the counter. It does not contain <code>Left</code> since it cannot be used for parallel reductions.</p><h2 id="WordsXF()"><a class="docs-heading-anchor" href="#WordsXF()"><code>WordsXF()</code></a><a id="WordsXF()-1"></a><a class="docs-heading-anchor-permalink" href="#WordsXF()" title="Permalink"></a></h2><p><a href="../../tutorials/words/#parallel-word-count">Parallel word count tutorial</a> explains how to build a transducer <code>WordsXF</code> that can be used to split words in parallel, in a composable manner. The following diagram shows the transition of its accumulator type. It emits <code>String</code> only after it reaches <code>Vacant</code>, if a word followed by a space is observed (hence <code>Union</code>). See also the definition of <code>extract(::Vacant, ::Vacant)</code> in the tutorial.</p><p><img src="../WordsXF.svg" alt/></p><h2 id="ReducePartitionBy(f,-rf,-[init])"><a class="docs-heading-anchor" href="#ReducePartitionBy(f,-rf,-[init])"><code>ReducePartitionBy(f, rf, [init])</code></a><a id="ReducePartitionBy(f,-rf,-[init])-1"></a><a class="docs-heading-anchor-permalink" href="#ReducePartitionBy(f,-rf,-[init])" title="Permalink"></a></h2><p>The private state of <a href="../../reference/manual/#Transducers.ReducePartitionBy"><code>ReducePartitionBy</code></a> starts as an <code>Unseen()</code> and then transition to <code>Chunk</code> at the first iteration. It then stays as a <code>Chunk</code> until the result of <code>f(x)</code> for input element <code>x</code> changes for the first time; at this point the state stays as a <code>Vacant</code> that holds the accumulators of <code>rf</code> for the first (left most) chunk <em>and</em> the current chunk. When the value of <code>f(x)</code> is changed for the second time or later, the accumulator of <code>rf</code> is <a href="../../reference/interface/#Transducers.complete"><code>complete</code></a>ed and emitted to the inner reducing function. This is denoted as by the edge label <code>R?</code> in the diagram. The question mark <code>?</code> is for indicating that the result of type <code>R</code> is not emitted for every iteration; it&#39;s only when <code>f(x)</code> is changed.</p><p><img src="../ReducePartitionBy.svg" alt/></p><p>The <code>Vacant</code> state keeps the first (pre-<code>complete</code>) accumulator of <code>rf</code> so that it can be <a href="../../reference/interface/#Transducers.combine"><code>combine</code></a>ed to the base case left to the current base case.</p><h2 id="ReduceSplitBy(f,-rf,-init)"><a class="docs-heading-anchor" href="#ReduceSplitBy(f,-rf,-init)"><code>ReduceSplitBy(f, rf, init)</code></a><a id="ReduceSplitBy(f,-rf,-init)-1"></a><a class="docs-heading-anchor-permalink" href="#ReduceSplitBy(f,-rf,-init)" title="Permalink"></a></h2><p>The private state of <a href="../internals/#Transducers.ReduceSplitBy"><code>ReduceSplitBy</code></a> starts as a <code>PreChunk</code> and stays as a <code>Chunk</code> until <code>f(x)</code> is true for the input element <code>x</code>. It may jump directly into <code>PreVacant</code> if <code>f(x)</code> is true for the first input element <code>x</code>. From <code>PreVacant</code>, the state is changed to <code>Vacant</code> unless <code>f(x)</code> is true. Each time <code>f(x)</code> is evaluated to true, the accumulator of <code>rf</code> is <a href="../../reference/interface/#Transducers.complete"><code>complete</code></a>ed and its result (of type <code>R</code>) is emitted.</p><p><img src="../ReduceSplitBy.svg" alt/></p><h2 id="tail-call-function-barrier"><a class="docs-heading-anchor" href="#tail-call-function-barrier">Tail-call &quot;function-barrier&quot; pattern</a><a id="tail-call-function-barrier-1"></a><a class="docs-heading-anchor-permalink" href="#tail-call-function-barrier" title="Permalink"></a></h2><p>To improve the type stability of the &quot;main loop&quot; (the transition between the double circles), it is often beneficial to unroll the initial transitions (the single circles). Schematically, we compose code like below:</p><pre><code class="language-julia"># Given:
rf      # reducing function
acc     # accumulator
iter    # input collection
istate  # iterator state

@assert is_prelude(acc)
T1 = typeof(acc)
while true
    y = iterate(iter, istate)
    y === nothing &amp;&amp; return acc
    (x, istate) = y
    acc = rf(acc, x)
    acc isa T1 || break
end

@assert is_prelude(acc)
T2 = typeof(acc)
while true
    y = iterate(iter, istate)
    y === nothing &amp;&amp; return acc
    (x, istate) = y
    acc = rf(acc, x)
    acc isa T2 || break
end

# ... and so on ...

@assert is_prelude(acc)
TN = typeof(acc)
while true
    y = iterate(iter, istate)
    y === nothing &amp;&amp; return acc
    (x, istate) = y
    acc = rf(acc, x)
    acc isa TN || break
end

# Now suppose we are out of the &quot;prelude chain&quot;:
@assert !is_prelude(acc)

# ...then loop like usual:
while true
    y = iterate(iter, istate)
    y === nothing &amp;&amp; return acc
    (x, istate) = y
    acc = rf(acc, x)
end</code></pre><p>Note that this code snippet is only for explaining the concept. For example, it is not possible to know how many <code>while</code> loops to generate <em>a priori</em>. It also assumes that the transition of the prelude accumulator which is not the case (see, e.g., <code>ReduceSplitBy</code>). Instead, several <a href="../../reference/interface/#Transducers.__foldl__"><code>__foldl__</code></a> methods implement this strategy using what we call <em>tail-call function-barrier</em> pattern (ref: <a href="https://github.com/JuliaFolds/Transducers.jl/blob/427f3d0bd964a62fce29c62b42b7e9d6d8c33ced/src/processes.jl#L208-L215">an example</a>).</p><p>For a previous discussion on this strategy, see also: <a href="https://discourse.julialang.org/t/tail-call-optimization-and-function-barrier-based-accumulation-in-loops/25831">Tail-call optimization and function-barrier -based accumulation in loops - Internals &amp; Design - JuliaLang</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../glossary/">« Glossary</a><a class="docs-footer-nextpage" href="../internals/">Internals »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 21 April 2021 07:02">Wednesday 21 April 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
