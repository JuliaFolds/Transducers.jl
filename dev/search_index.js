var documenterSearchIndex = {"docs": [

{
    "location": "#",
    "page": "Home",
    "title": "Home",
    "category": "page",
    "text": ""
},

{
    "location": "#Transducers-for-Julia-1",
    "page": "Home",
    "title": "Transducers for Julia",
    "category": "section",
    "text": "DocTestSetup = quote\n    using Transducers\nendTransducers are transformations of sequence of input that can be composed very efficiently.  The interface used by transducers naturally describes a wide range of processes that is expressible as a succession of steps. Furthermore, transducers can be defined without specifying the details of the input and output (collections, streams, channels, etc.)  and therefore achieves a full reusability.  Transducers are introduced by Rich Hickey, the creator of the Clojure language. His Strange Loop talk is a great introduction to the idea of transducers.Transducers.jl is an implementation of the transducers in Julia. Aiming to satisfy high-performance needs of Julia users, Transducers.jl uses a formulation that is pure [pure] and aiding type-stability.[pure]: ...although not pure in the strong sense as Base.@pure."
},

{
    "location": "#Installation-1",
    "page": "Home",
    "title": "Installation",
    "category": "section",
    "text": "]add https://github.com/tkf/Transducers.jl"
},

{
    "location": "#Examples-1",
    "page": "Home",
    "title": "Examples",
    "category": "section",
    "text": "If you are familiar with iterators (see also Base.Iterators and IterTools.jl) it would look very familiar to you:julia> using Transducers\n\njulia> collect(Map(x -> 2x), 1:3)  # double each element\n3-element Array{Int64,1}:\n 2\n 4\n 6\n\njulia> collect(Filter(iseven), 1:6)  # collect only evens\n3-element Array{Int64,1}:\n 2\n 4\n 6\n\njulia> collect(MapCat(x -> 1:x), 1:3)  # concatenate mapped results\n6-element Array{Int64,1}:\n 1\n 1\n 2\n 1\n 2\n 3\nTransducers can be composed (without, unlike iterators, referring to the input):julia> xf = Filter(iseven) |> Map(x -> 2x)\n       collect(xf, 1:6)\n3-element Array{Int64,1}:\n  4\n  8\n 12An efficient way to use transducers is combination with mapfoldl.  This computation is done without creating any intermediate lazy object and compiles to a single loop:julia> mapfoldl(xf, +, 1:6)\n24"
},

{
    "location": "#Difference-to-iterators-1",
    "page": "Home",
    "title": "Difference to iterators",
    "category": "section",
    "text": "How mapfoldl and foldl are used illustrates the difference between iterators and transducers.  Implementation of the above computation in iterator would be:f(x) = 2x\nimap = Base.Iterators.Generator  # like `map`, but returns an iterator\nmapfoldl(f, +, filter(iseven, input), init=0)\nfoldl(+, imap(f, filter(iseven, input)))  # equivalent\n#        ______________________________\n#        composition occurs at input partCompare it to how transducers are used:mapfoldl(Filter(iseven) |> Map(f), +, input, init=0)\n#        ________________________\n#        composition occurs at computation partAlthough this is just a syntactic difference, it is reflected in the actual code generated by those two frameworks.  The code for iterator would be lowered to:function map_filter_iterators(xs, init)\n    ret = iterate(xs)\n    ret === nothing && return\n    acc = init\n    @goto filter\n    local state, x\n    while true\n        while true                                    # input\n            ret = iterate(xs, state)                  #\n            ret === nothing && return acc             #\n            @label filter                             #\n            x, state = ret                            #\n            iseven(x) && break             # filter   :\n        end                                #          :\n        y = 2x              # imap         :          :\n        acc += y    # +     :              :          :\n    end             # :     :              :          :\n    #                 + <-- imap <-------- filter <-- input\n    return acc\nendNotice that the iteration of input is the inner most block, followed by filter, imap, and then finally +.  Iterators are described as pull-based; an outer iterator (say imap) has to \"pull\" an item from the inner iterator (filter in above example). It is reflected in the lowered code above.On the other hand, the code using transducers is lowered to:function map_filter_transducers(xs, init)\n    acc = init\n    #              input -> Filter --> Map --> +\n    for x in xs  # input    :          :       :\n        if iseven(x)  #     Filter     :       :\n            y = 2x    #                Map     :\n            acc += y  #                        +\n        end\n    end\n    return acc\nend\n\nxs = [6, 8, 1, 4, 5, 6, 6, 7, 9, 9, 7, 8, 6, 8, 2, 5, 2, 4, 3, 7]\n@assert map_filter_iterators(xs, 0) == map_filter_transducers(xs, 0)Notice that the iteration of input is at the outer most block while + is in the inner most block.  Transducers passed to mapfoldl appears in the block between them in the order they are composed.  An outer transducer (say Filter) \"pushes\" arbitrary number of items to the inner transducer (Map in above example). Note that Filter can choose to not push an item (i.e., push zero item) when the predicate returns false.  This push-based nature of the transducers allows the generation of very natural and efficient code.  To put it another way, the transducers and transducible processes own the loop.As a consequence, computations requiring to expand an item into a sequence can be processed efficiently.  Consider the following example:julia> xf = Map(x -> 1:x) |> Filter(iseven ∘ sum) |> Cat()\n       mapfoldl(xf, *, 1:10)\n29262643200This is lowered to a nested for loops:function map_filter_cat_transducers(xs, init)\n    acc = init\n    for x in xs\n        y1 = 1:x                # Map\n        if iseven(sum(y1))      # Filter\n            for y2 in y1        # Cat\n                acc *= y2       # *\n            end\n        end\n    end\n    return acc\nend\n\n@assert mapfoldl(xf, *, 1:10) == map_filter_cat_transducers(1:10, 1)It is not straightforward to implement an iterator like Cat that can output more than one items at a time.  Such an iterator has to track the state of the inner (y1 in above) and outer (xs in above) iterators and conditionally invoke the outer iterator once the inner iterator terminates.  This generates a complicated code and the compiler would have hard time optimizing it."
},

{
    "location": "#List-of-transducers-1",
    "page": "Home",
    "title": "List of transducers",
    "category": "section",
    "text": "Here is the list of pre-defined transducers:import Markdown\nimport Transducers\nMarkdown.MD(Transducers.TransducerLister())"
},

{
    "location": "#Glossary-1",
    "page": "Home",
    "title": "Glossary",
    "category": "section",
    "text": "mapfoldl(xf, step, input, init=...)\n#   |    |   |     |\n#   |    |   |     `-- reducible\n#   |    |   |\n#   |    |   `-- \"bottom\" (inner most) reducing function\n#   |    |\n#   |    `-- transducer\n#   |\n#   `-- transducible processReducing function or Reducing step (function): A reducing function combines result-so-far with the input.  It in a narrow sense is a \"callable\" op of the signature op(::X, ::Y) :: X (or op(::X, ::X) :: X in case for mapreduce) or schematically:\n(textresult-so-far textinput) mapsto textresult-so-far\nIt is the function that can be passed to the classic (non-Transducers.jl) Base.foldl or Base.reduce.  It is sometimes referred to as a step or op.  In Transducers.jl, next(rf, ::X, ::Y) :: X is used instead of a \"bare\" callable.  Furthermore, a reducing function in a loose sense also includes other interfaces such as start(rf, ::X) and complete(rf, ::X).\nTransducer: A transducer transforms a reducing function into a new reducing function.  It is sometimes referred to as a xf or xform.  A transducer can be composed of many sub-transducers; the syntax in Transducers.jl is xf = xf₁ |> xf₂ |> ... |> xfₙ.  The composed transducers are applied to the \"bottom\" reducing function from right to left, i.e., schematically, a new reducing function mathrmrf is obtained from the \"bottom\" reducing function mathrmstep by\nmathrmrf =\nmathrmxf_1(mathrmxf_2((mathrmxf_n(mathrmstep))))\nGiven a composition xf₁ |> xf₂, transducer xf₂ is said to be the inner transducer of xf₁ |> xf₂.  Likewise, mathrmxf_2(mathrmrf) is an inner reducing function of mathrmxf_1(mathrmxf_2(mathrmrf)).\nReducible collection (or just Reducible): Any object that can be passed to mapfoldl and alike is reducible.  A reducible collection knows how to apply reducing function to its elements.  Iterators are automatically reducible as this is the canonical fallback implementation.\nTransducible process: A function that can reduce reducible collections using transducers is a transducible process.  Examples are mapfoldl and mapreduce.  Find more in Transducible processes."
},

{
    "location": "#Links-1",
    "page": "Home",
    "title": "Links",
    "category": "section",
    "text": "\"Transducers\" by Rich Hickey - YouTube\nRich Hickey - Inside Transducers - YouTube\nCppCon 2015: Juan Pedro Bolívar Puente “Transducers: from Clojure to C++\" - YouTube"
},

{
    "location": "manual/#",
    "page": "Manual",
    "title": "Manual",
    "category": "page",
    "text": ""
},

{
    "location": "manual/#Transducers-and-Transducible-processes-1",
    "page": "Manual",
    "title": "Transducers and Transducible processes",
    "category": "section",
    "text": "Pages = [\"manual.md\"]\nOrder = [:function, :type]"
},

{
    "location": "manual/#Base.mapfoldl",
    "page": "Manual",
    "title": "Base.mapfoldl",
    "category": "function",
    "text": "mapfoldl(xf, step, itr; init) :: T\ntransduce(xf, step, init, itr) :: Union{T, Reduced{T}}\n\nCompose transducer xf with reducing step function step and reduce itr using it.\n\nwarning: Warning\ntransduce differs from mapfoldl as Reduced{T} is returned if the transducer xf or step aborts the reduction.\n\nThis API is modeled after transduce in Clojure.\n\nArguments\n\nxf::Transducer: A transducer.\nstep: A callable which accepts 1 and 2 arguments.  If it only accepts 2 arguments, wrap it by Completing to add complete protocol.\ninit: An initial value fed to the first argument to reducing step function step.\nitr: An iterable.\n\nExamples\n\njulia> using Transducers\n\njulia> function step_demo(state, input)\n           @show state, input\n           state + input\n       end;\n\njulia> function step_demo(state)\n           println(\"Finishing with state = \", state)\n           state\n       end;\n\njulia> mapfoldl(Filter(isodd), step_demo, 1:4, init=0.0)\n(state, input) = (0.0, 1)\n(state, input) = (1.0, 3)\nFinishing with state = 4.0\n4.0\n\n\n\n\n\n"
},

{
    "location": "manual/#Transducers.transduce",
    "page": "Manual",
    "title": "Transducers.transduce",
    "category": "function",
    "text": "mapfoldl(xf, step, itr; init) :: T\ntransduce(xf, step, init, itr) :: Union{T, Reduced{T}}\n\nSee mapfoldl.\n\n\n\n\n\n"
},

{
    "location": "manual/#Base.foldl",
    "page": "Manual",
    "title": "Base.foldl",
    "category": "function",
    "text": "foldl(step, xf::Transducer, itr; init)\nfoldl(step, ed::Eduction; init)\n\nThe first form is a shorthand for mapfoldl(xf, Completing(step), itr; init). It is intended to be used with do block.  It is also equivalent to foldl(step, eduction(xf, itr); init).\n\nExamples\n\njulia> using Transducers\n\njulia> foldl(Filter(isodd), 1:4, init=0.0) do state, input\n           @show state, input\n           state + input\n       end\n(state, input) = (0.0, 1)\n(state, input) = (1.0, 3)\n4.0\n\n\n\n\n\n"
},

{
    "location": "manual/#Base.foreach",
    "page": "Manual",
    "title": "Base.foreach",
    "category": "function",
    "text": "foreach(eff, xf::Transducer, itr)\nforeach(eff, ed::Eduction)\n\nFeed the results of xf processing items in itr into a unary function eff which is used primary for a side-effect.  It is equivalent to foreach(eff, eduction(xf, coll)).  Note that\n\nforeach(eduction(xf, coll)) do x\n    ...\nend\n\ncan be more efficient than\n\nfor x in eduction(xf, coll)\n    ...\nend\n\nas the former does not have to translate the transducer protocol to the iterator protocol.\n\nExamples\n\njulia> using Transducers\n\njulia> foreach(eduction(Filter(isodd), 1:4)) do input\n           @show input\n       end\ninput = 1\ninput = 3\n\n\n\n\n\n"
},

{
    "location": "manual/#Base.mapreduce",
    "page": "Manual",
    "title": "Base.mapreduce",
    "category": "function",
    "text": "mapreduce(xf, step, itr; init) :: T\n\nPossibly parallel version of mapfoldl.  The \"bottom\" reduction function step(::T, ::T) :: T must be associative and init must be its identity element.\n\nTransducers composing xf must be stateless and non-terminating (e.g., Map, Filter, Cat, etc.) except for ScanEmit.  Note that Scan is not supported (although possible in theory).\n\nSee mapfoldl.\n\n\n\n\n\n"
},

{
    "location": "manual/#Transducers.eduction",
    "page": "Manual",
    "title": "Transducers.eduction",
    "category": "function",
    "text": "eduction(xf::Transducer, coll)\n\nCreate a iterable and reducible object.\n\nIterable.\nReducible; i.e., it can be handled by transduce efficiently.\n\nThis API is modeled after eduction in Clojure.\n\nExamples\n\njulia> using Transducers\n\njulia> for x in eduction(Filter(isodd) |> Take(3), 1:1000)\n           @show x\n       end\nx = 1\nx = 3\nx = 5\n\n\n\n\n\n"
},

{
    "location": "manual/#Base.map!",
    "page": "Manual",
    "title": "Base.map!",
    "category": "function",
    "text": "map!(xf::Transducer, dest, src)\n\nFeed src to transducer xf, storing the result in dest. Collections dest and src must have the same shape.  Transducer xf may contain filtering transducers.  If some entries src are skipped, the corresponding entries in dest will be unchanged. Transducer xf must not contain any expansive transducers such as MapCat.\n\nSee also copy!.\n\nExamples\n\njulia> using Transducers\n\njulia> xs = collect(1:5)\n       ys = zero(xs)\n       map!(Filter(isodd), ys, xs)\n5-element Array{Int64,1}:\n 1\n 0\n 3\n 0\n 5\n\njulia> ans === ys\ntrue\n\n\n\n\n\n"
},

{
    "location": "manual/#Base.copy!",
    "page": "Manual",
    "title": "Base.copy!",
    "category": "function",
    "text": "copy!(xf::Transducer, dest, src)\n\nFeed src to transducer xf, storing the result in dest. Collections dest and src may have the same shape.  Source src must be iterable.  Destination dest must implement empty! and push!.\n\nSee also map!.\n\nExamples\n\njulia> using Transducers\n\njulia> copy!(PartitionBy(x -> x ÷ 3) |> Map(sum), Int[], 1:10)\n4-element Array{Int64,1}:\n  3\n 12\n 21\n 19\n\n\n\n\n\n"
},

{
    "location": "manual/#Base.append!",
    "page": "Manual",
    "title": "Base.append!",
    "category": "function",
    "text": "append!(xf::Transducer, dest, src)\n\nThis API is modeled after into in Clojure.\n\nExamples\n\njulia> using Transducers\n\njulia> append!(Drop(2), [-1, -2], 1:5)\n5-element Array{Int64,1}:\n -1\n -2\n  3\n  4\n  5\n\n\n\n\n\n"
},

{
    "location": "manual/#Base.collect",
    "page": "Manual",
    "title": "Base.collect",
    "category": "function",
    "text": "collect(xf::Transducer, itr)\n\nProcess an iterable itr using a transducer xf and collect the result into a Vector.\n\nExamples\n\njulia> using Transducers\n\njulia> collect(Interpose(missing), 1:3)\n5-element Array{Union{Missing, Int64},1}:\n 1\n  missing\n 2\n  missing\n 3\n\n\n\n\n\n"
},

{
    "location": "manual/#Base.Channel",
    "page": "Manual",
    "title": "Base.Channel",
    "category": "type",
    "text": "Channel(xf::Transducer, itr; kwargs...)\nChannel(ed::Eduction; kwargs...)\n\nPipe items from an iterable itr processed by the transducer xf through a channel.  Channel(xf, itr) and Channel(eduction(xf, itr)) are equivalent.  Note that itr itself can be a Channel.\n\nKeyword arguments are passed to Channel(function; kwargs...). ctype is inferred from xf if not specified.\n\nExamples\n\njulia> using Transducers\n\njulia> ch1 = Channel(Filter(isodd), 1:5);\n\njulia> ch2 = Channel(Map(x -> 2x - 1), ch1);\n\njulia> ed = eduction(Map(x -> 1:x), ch2);\n\njulia> ch3 = Channel(Cat(), ed);\n\njulia> typeof(ch1) === typeof(ch2) === typeof(ch3) === Channel{Int}\ntrue\n\njulia> foreach(PartitionBy(isequal(1)), ch3) do input\n           @show input\n       end\ninput = [1, 1]\ninput = [2, 3, 4, 5]\ninput = [1]\ninput = [2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\n\n\n"
},

{
    "location": "manual/#Transducible-processes-1",
    "page": "Manual",
    "title": "Transducible processes",
    "category": "section",
    "text": "mapfoldl\ntransduce\nfoldl\nforeach\nmapreduce\neduction\nmap!\ncopy!\nappend!\ncollect\nChannel"
},

{
    "location": "manual/#Transducers.Cat",
    "page": "Manual",
    "title": "Transducers.Cat",
    "category": "type",
    "text": "Cat()\n\nConcatenate/flatten nested iterators.\n\nThis API is modeled after cat in Clojure.\n\nExamples\n\njulia> using Transducers\n\njulia> collect(Cat(), [[1, 2], [3], [4, 5]]) == 1:5\ntrue\n\n\n\n\n\n"
},

{
    "location": "manual/#Transducers.Count",
    "page": "Manual",
    "title": "Transducers.Count",
    "category": "type",
    "text": "Count([start[, step]])\n\nGenerate a sequence start, start + step, start + step + step, and so on.\n\nNote that input is ignored.  To use the input in the downstream reduction steps, use TeeZip or Zip.\n\nstart defaults to 1 and step defaults to oneunit(start).\n\nSee also: Iterators.countfrom. Enumerate\n\nExamples\n\njulia> using Transducers\n\njulia> collect(TeeZip(Count()), -3:-1)\n3-element Array{Tuple{Int64,Int64},1}:\n (-3, 1)\n (-2, 2)\n (-1, 3)\n\njulia> using Dates\n\njulia> collect(TeeZip(Count(Day(1))) |> Map(xs -> *(xs...)), 1:3)\n3-element Array{Day,1}:\n 1 day\n 4 days\n 9 days\n\n\n\n\n\n"
},

{
    "location": "manual/#Transducers.Dedupe",
    "page": "Manual",
    "title": "Transducers.Dedupe",
    "category": "type",
    "text": "Dedupe()\n\nDe-duplicate consecutive items.\n\nThis API is modeled after dedupe in Clojure.\n\nExamples\n\njulia> using Transducers\n\njulia> collect(Dedupe(), [1, 1, 2, 1, 3, 3, 2])\n5-element Array{Int64,1}:\n 1\n 2\n 1\n 3\n 2\n\n\n\n\n\n"
},

{
    "location": "manual/#Transducers.Distinct",
    "page": "Manual",
    "title": "Transducers.Distinct",
    "category": "type",
    "text": "Distinct()\n\nPass only unseen item to the inner reducing step.\n\nThis API is modeled after distinct in Clojure.\n\nExamples\n\njulia> using Transducers\n\njulia> collect(Distinct(), [1, 1, 2, 1, 3, 3, 2])\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\n\n\n\n\n"
},

{
    "location": "manual/#Transducers.Drop",
    "page": "Manual",
    "title": "Transducers.Drop",
    "category": "type",
    "text": "Drop(n)\n\nDrop first n items.\n\nThis API is modeled after drop in Clojure.\n\nExamples\n\njulia> using Transducers\n\njulia> collect(Drop(3), 1:5)\n2-element Array{Int64,1}:\n 4\n 5\n\n\n\n\n\n"
},

{
    "location": "manual/#Transducers.DropLast",
    "page": "Manual",
    "title": "Transducers.DropLast",
    "category": "type",
    "text": "DropLast(n)\n\nDrop last n items.\n\nThis API is modeled after drop-last in Clojure.\n\nExamples\n\njulia> using Transducers\n\njulia> collect(DropLast(2), 1:5)\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\njulia> collect(DropLast(2), 1:1)\n0-element Array{Int64,1}\n\njulia> collect(DropLast(2), 1:0)\n0-element Array{Int64,1}\n\n\n\n\n\n"
},

{
    "location": "manual/#Transducers.DropWhile",
    "page": "Manual",
    "title": "Transducers.DropWhile",
    "category": "type",
    "text": "DropWhile(pred)\n\nDrop items while pred returns true consecutively.  It becomes a no-op after pred returns a false.\n\nThis API is modeled after drop-while in Clojure.\n\nExamples\n\njulia> using Transducers\n\njulia> collect(DropWhile(x -> x < 3), [1:5; 1:2])\n5-element Array{Int64,1}:\n 3\n 4\n 5\n 1\n 2\n\n\n\n\n\n"
},

{
    "location": "manual/#Transducers.Enumerate",
    "page": "Manual",
    "title": "Transducers.Enumerate",
    "category": "type",
    "text": "Enumerate([start[, step]])\n\nTransducer variant of Base.enumerate. The start and step arguments are optional and have the same meaning as in Count.\n\nExamples\n\njulia> using Transducers\n\njulia> collect(Enumerate(), [\"A\", \"B\", \"C\"])\n3-element Array{Tuple{Int64,String},1}:\n (1, \"A\")\n (2, \"B\")\n (3, \"C\")\n\njulia> start=2; step=3;\n\njulia> collect(Enumerate(start, step), [\"A\", \"B\", \"C\"])\n3-element Array{Tuple{Int64,String},1}:\n (2, \"A\")\n (5, \"B\")\n (8, \"C\")\n\n\n\n\n\n\n"
},

{
    "location": "manual/#Transducers.Filter",
    "page": "Manual",
    "title": "Transducers.Filter",
    "category": "type",
    "text": "Filter(pred)\n\nSkip items for which pred is evaluated to false.\n\nThis API is modeled after filter in Clojure.\n\nExamples\n\njulia> using Transducers\n\njulia> collect(Filter(iseven), 1:3)\n1-element Array{Int64,1}:\n 2\n\n\n\n\n\n"
},

{
    "location": "manual/#Transducers.FlagFirst",
    "page": "Manual",
    "title": "Transducers.FlagFirst",
    "category": "type",
    "text": "FlagFirst()\n\nOutput (isfirst, input) where isfirst::Bool is true only for the first iteration and input is the original input.\n\nSee also: IterTools.flagfirst\n\nExamples\n\njulia> using Transducers\n\njulia> collect(FlagFirst(), 1:3)\n3-element Array{Tuple{Bool,Int64},1}:\n (true, 1)\n (false, 2)\n (false, 3)\n\n\n\n\n\n"
},

{
    "location": "manual/#Transducers.GetIndex",
    "page": "Manual",
    "title": "Transducers.GetIndex",
    "category": "type",
    "text": "GetIndex(array)\nGetIndex{inbounds}(array)\n\nTransform an integer input i to array[i].\n\nExamples\n\njulia> using Transducers\n\njulia> collect(GetIndex(1:10), [2, 3, 4])\n3-element Array{Int64,1}:\n 2\n 3\n 4\n\njulia> collect(GetIndex{true}(1:10), [2, 3, 4])\n3-element Array{Int64,1}:\n 2\n 3\n 4\n\n\n\n\n\n"
},

{
    "location": "manual/#Transducers.Inject",
    "page": "Manual",
    "title": "Transducers.Inject",
    "category": "type",
    "text": "Inject(iterator)\n\nInject the output from iterator to the stream processed by the inner reduction step.\n\nExamples\n\njulia> using Transducers\n\njulia> collect(Inject(Iterators.cycle(\"hello\")), 1:8)\n8-element Array{Tuple{Int64,Char},1}:\n (1, \'h\')\n (2, \'e\')\n (3, \'l\')\n (4, \'l\')\n (5, \'o\')\n (6, \'h\')\n (7, \'e\')\n (8, \'l\')\n\njulia> collect(Inject(Iterators.repeated([1 2])), 1:4)\n4-element Array{Tuple{Int64,Array{Int64,2}},1}:\n (1, [1 2])\n (2, [1 2])\n (3, [1 2])\n (4, [1 2])\n\njulia> collect(Inject(Iterators.product(1:2, 3:5)), 1:100)\n6-element Array{Tuple{Int64,Tuple{Int64,Int64}},1}:\n (1, (1, 3))\n (2, (2, 3))\n (3, (1, 4))\n (4, (2, 4))\n (5, (1, 5))\n (6, (2, 5))\n\n\n\n\n\n"
},

{
    "location": "manual/#Transducers.Interpose",
    "page": "Manual",
    "title": "Transducers.Interpose",
    "category": "type",
    "text": "Interpose(sep)\n\nInterleave input items with a sep.\n\nThis API is modeled after interpose in Clojure.\n\nExamples\n\njulia> using Transducers\n\njulia> collect(Interpose(missing), 1:3)\n5-element Array{Union{Missing, Int64},1}:\n 1\n  missing\n 2\n  missing\n 3\n\n\n\n\n\n"
},

{
    "location": "manual/#Transducers.Iterated",
    "page": "Manual",
    "title": "Transducers.Iterated",
    "category": "type",
    "text": "Iterated(f, init[, T::Type])\n\nGenerate a sequence init, f(init), f(f(init)), f(f(f(init))), and so on.\n\nNote that input is ignored.  To use the input in the downstream reduction steps, use TeeZip or Zip.\n\nUse the third argument T to specify the output type of f.\n\nAn Initializer object can be passed to init for creating a dedicated (possibly mutable) state for each fold.\n\nSee also: Scan, ScanEmit.\n\nThe idea is taken from IterTools.iterated\n\nExamples\n\njulia> using Transducers\n\njulia> collect(Iterated(x -> 2x, 1), 1:5)\n5-element Array{Int64,1}:\n  1\n  2\n  4\n  8\n 16\n\njulia> collect(TeeZip(Iterated(x -> 2x, 1)), 1:5)\n5-element Array{Tuple{Int64,Int64},1}:\n (1, 1)\n (2, 2)\n (3, 4)\n (4, 8)\n (5, 16)\n\n\n\n\n\n"
},

{
    "location": "manual/#Transducers.Keep",
    "page": "Manual",
    "title": "Transducers.Keep",
    "category": "type",
    "text": "Keep(f)\n\nPass non-nothing output of f to the inner reducing step.\n\nThis API is modeled after keep in Clojure.\n\nExamples\n\njulia> using Transducers\n\njulia> xf = Keep() do x\n           if x < 3\n               x + 1\n           end\n       end;\n\njulia> collect(xf, 1:5)\n2-element Array{Int64,1}:\n 2\n 3\n\n\n\n\n\n"
},

{
    "location": "manual/#Transducers.Map",
    "page": "Manual",
    "title": "Transducers.Map",
    "category": "type",
    "text": "Map(f)\n\nApply unary function f to each input and pass the result to the inner reducing step.\n\nThis API is modeled after map in Clojure.\n\nExamples\n\njulia> using Transducers\n\njulia> collect(Map(x -> 2x), 1:3)\n3-element Array{Int64,1}:\n 2\n 4\n 6\n\n\n\n\n\n"
},

{
    "location": "manual/#Transducers.MapCat",
    "page": "Manual",
    "title": "Transducers.MapCat",
    "category": "type",
    "text": "MapCat(f)\n\nConcatenate output of f which is expected to return an iterable.\n\nThis API is modeled after mapcat in Clojure.\n\nExamples\n\njulia> using Transducers\n\njulia> collect(MapCat(x -> 1:x), 1:3)\n6-element Array{Int64,1}:\n 1\n 1\n 2\n 1\n 2\n 3\n\n\n\n\n\n"
},

{
    "location": "manual/#Transducers.MapSplat",
    "page": "Manual",
    "title": "Transducers.MapSplat",
    "category": "type",
    "text": "MapSplat(f)\n\nLike Map(f) but calls f(input...) for each input and then pass the result to the inner reducing step.\n\nExamples\n\njulia> using Transducers\n\njulia> collect(MapSplat(*), zip(1:3, 10:10:30))\n3-element Array{Int64,1}:\n 10\n 40\n 90\n\n\n\n\n\n"
},

{
    "location": "manual/#Transducers.NotA",
    "page": "Manual",
    "title": "Transducers.NotA",
    "category": "type",
    "text": "NotA(T)\n\nSkip items of type T.  Unlike Filter(!ismissing), downstream transducers can have a correct type information for NotA(Missing).\n\nSee also: OfType\n\nExamples\n\njulia> using Transducers\n\njulia> collect(NotA(Missing), [1, missing, 2])\n2-element Array{Int64,1}:\n 1\n 2\n\njulia> collect(Filter(!ismissing), [1, missing, 2])  # see the eltype below\n2-element Array{Union{Missing, Int64},1}:\n 1\n 2\n\n\n\n\n\n"
},

{
    "location": "manual/#Transducers.OfType",
    "page": "Manual",
    "title": "Transducers.OfType",
    "category": "type",
    "text": "OfType(T)\n\nInclude only items of type T.\n\nSee also: NotA\n\nExamples\n\njulia> using Transducers\n\njulia> collect(OfType(Int), [1, missing, 2])\n2-element Array{Int64,1}:\n 1\n 2\n\njulia> collect(Filter(!ismissing), [1, missing, 2])  # see the eltype below\n2-element Array{Union{Missing, Int64},1}:\n 1\n 2\n\n\n\n\n\n"
},

{
    "location": "manual/#Transducers.Partition",
    "page": "Manual",
    "title": "Transducers.Partition",
    "category": "type",
    "text": "Partition(size, step = size, flush = false)\nPartition(size; step = size, flush = false)\n\nSliding window of width size and interval step.\n\nwarning: Warning\nThe vector passed to the inner reducing function is valid only during its immediate reduction step.  It must be reduced immediately or copied.\n\nThis API is modeled after partition-all in Clojure.\n\nExamples\n\njulia> using Transducers\n\njulia> collect(Partition(3) |> Map(copy), 1:8)\n2-element Array{Array{Int64,1},1}:\n [1, 2, 3]\n [4, 5, 6]\n\njulia> collect(Partition(3; flush=true) |> Map(copy), 1:8)\n3-element Array{Array{Int64,1},1}:\n [1, 2, 3]\n [4, 5, 6]\n [7, 8]\n\njulia> collect(Partition(3; step=1) |> Map(copy), 1:8)\n6-element Array{Array{Int64,1},1}:\n [1, 2, 3]\n [2, 3, 4]\n [3, 4, 5]\n [4, 5, 6]\n [5, 6, 7]\n [6, 7, 8]\n\n\n\n\n\n"
},

{
    "location": "manual/#Transducers.PartitionBy",
    "page": "Manual",
    "title": "Transducers.PartitionBy",
    "category": "type",
    "text": "PartitionBy(f)\n\nGroup input sequence into chunks in which f returns a same value consecutively.\n\nwarning: Warning\nThe vector passed to the inner reducing function is valid only during its immediate reduction step.  It must be reduced immediately or copied.\n\nThis API is modeled after partition-by in Clojure.\n\nExamples\n\njulia> using Transducers\n\njulia> collect(PartitionBy(x -> (x + 1) ÷ 3) |> Map(copy), 1:9)\n4-element Array{Array{Int64,1},1}:\n [1]\n [2, 3, 4]\n [5, 6, 7]\n [8, 9]\n\n\n\n\n\n"
},

{
    "location": "manual/#Transducers.Replace",
    "page": "Manual",
    "title": "Transducers.Replace",
    "category": "type",
    "text": "Replace(assoc)\n\nReplace each input with the value in the associative container assoc (e.g., a dictionary, array, string) if it matches with a key/index. Otherwise output the input as-is.\n\nThis API is modeled after replace in Clojure.\n\nExamples\n\njulia> using Transducers\n\njulia> collect(Replace(Dict(\'a\' => \'A\')), \"abc\")\n3-element Array{Char,1}:\n \'A\'\n \'b\'\n \'c\'\n\njulia> collect(Replace([:a, :b, :c]), 0:4)\n5-element Array{Union{Int64, Symbol},1}:\n 0\n  :a\n  :b\n  :c\n 4\n\njulia> collect(Replace(\"abc\"), 0:4)\n5-element Array{Union{Char, Int64},1}:\n 0\n  \'a\'\n  \'b\'\n  \'c\'\n 4\n\n\n\n\n\n"
},

{
    "location": "manual/#Transducers.Scan",
    "page": "Manual",
    "title": "Transducers.Scan",
    "category": "type",
    "text": "Scan(f, [init])\n\nAccumulate input with binary function f and pass the accumulated result so far to the inner reduction step.\n\nThe inner reducing step receives the sequence y₁, y₂, y₃, ..., yₙ, ... when the sequence x₁, x₂, x₃, ..., xₙ, ... is fed to Scan(f).\n\ny₁ = f(init, x₁)\ny₂ = f(y₁, x₂)\ny₃ = f(y₂, x₃)\n...\nyₙ = f(yₙ₋₁, xₙ)\n\nThis is a generalized version of the prefix sum also known as cumulative sum, inclusive scan, or scan.\n\nNote that the associativity of f is not required when the transducer is used in a process that gurantee an order, such as mapfoldl.\n\nUnless f is a function with known identity element such as +, *, min, max, and append!, the initial state init must be provided.\n\nAn Initializer object can be passed to init for creating a dedicated (possibly mutable) state for each fold.\n\nSee also: ScanEmit, Iterated.\n\nExamples\n\njulia> using Transducers\n\njulia> collect(Scan(*), 1:3)\n3-element Array{Int64,1}:\n 1\n 2\n 6\n\njulia> collect(Map(x -> x + im) |> Scan(*), 1:3)\n3-element Array{Complex{Int64},1}:\n 1 + 1im\n 1 + 3im\n 0 + 10im\n\njulia> collect(Scan(*, 10), 1:3)\n3-element Array{Int64,1}:\n 10\n 20\n 60\n\n\n\n\n\n"
},

{
    "location": "manual/#Transducers.ScanEmit",
    "page": "Manual",
    "title": "Transducers.ScanEmit",
    "category": "type",
    "text": "ScanEmit(f, init[, onlast])\n\nAccumulate input x with a function f with the call signature (u, x) -> (y, u) and pass the result y to the inner reduction step.\n\nThe inner reducing step receives the sequence y₁, y₂, y₃, ..., yₙ, ... computed as follows\n\nu₀ = init\ny₁, u₁ = f(u₀, x₁)\ny₂, u₂ = f(u₁, x₂)\ny₃, u₃ = f(u₂, x₃)\n...\nyₙ, uₙ = f(uₙ₋₁, xₙ)\n...\nyₒₒ = onlast(uₒₒ)\n\nwhen the sequence x₁, x₂, x₃, ..., xₙ, ... is fed to ScanEmit(f).\n\nAn Initializer object can be passed to init for creating a dedicated (possibly mutable) state for each fold.\n\nSee also: ScanEmit, Iterated.\n\nExamples\n\njulia> using Transducers\n\njulia> collect(ScanEmit(tuple, 0), 1:3)\n3-element Array{Int64,1}:\n 0\n 1\n 2\n\n\n\n\n\n"
},

{
    "location": "manual/#Transducers.SetIndex",
    "page": "Manual",
    "title": "Transducers.SetIndex",
    "category": "type",
    "text": "SetIndex(array)\nSetIndex{inbounds}(array)\n\nPerform array[i] = v for each input pair (i, v).\n\nExamples\n\njulia> using Transducers\n\njulia> ys = zeros(3);\n\njulia> mapfoldl(SetIndex(ys), first ∘ tuple, [(1, 11.1), (3, 33.3)], init=nothing)\n\njulia> ys\n3-element Array{Float64,1}:\n 11.1\n  0.0\n 33.3\n\n\n\n\n\n"
},

{
    "location": "manual/#Transducers.Take",
    "page": "Manual",
    "title": "Transducers.Take",
    "category": "type",
    "text": "Take(n)\n\nTake n items from the input sequence.\n\nThis API is modeled after take in Clojure.\n\nExamples\n\njulia> using Transducers\n\njulia> collect(Take(2), 1:10)\n2-element Array{Int64,1}:\n 1\n 2\n\njulia> collect(Take(5), 1:2)\n2-element Array{Int64,1}:\n 1\n 2\n\n\n\n\n\n"
},

{
    "location": "manual/#Transducers.TakeLast",
    "page": "Manual",
    "title": "Transducers.TakeLast",
    "category": "type",
    "text": "TakeLast(n)\n\nTake last n items from the input sequence.\n\nExamples\n\njulia> using Transducers\n\njulia> collect(TakeLast(2), 1:10)\n2-element Array{Int64,1}:\n  9\n 10\n\njulia> collect(TakeLast(5), 1:2)\n2-element Array{Int64,1}:\n 1\n 2\n\n\n\n\n\n"
},

{
    "location": "manual/#Transducers.TakeNth",
    "page": "Manual",
    "title": "Transducers.TakeNth",
    "category": "type",
    "text": "TakeNth(n)\n\nOutput every n item to the inner reducing step.\n\nThis API is modeled after take-nth in Clojure.\n\nExamples\n\njulia> using Transducers\n\njulia> collect(TakeNth(3), 1:9)\n3-element Array{Int64,1}:\n 1\n 4\n 7\n\n\n\n\n\n"
},

{
    "location": "manual/#Transducers.TakeWhile",
    "page": "Manual",
    "title": "Transducers.TakeWhile",
    "category": "type",
    "text": "TakeWhile(pred)\n\nTake items while pred returns true.  Abort the reduction when pred returns false for the first time.\n\nThis API is modeled after take-while in Clojure.\n\nExamples\n\njulia> using Transducers\n\njulia> collect(TakeWhile(x -> x < 3), [1, 2, 3, 1, 2])\n2-element Array{Int64,1}:\n 1\n 2\n\n\n\n\n\n"
},

{
    "location": "manual/#Transducers.TeeZip",
    "page": "Manual",
    "title": "Transducers.TeeZip",
    "category": "type",
    "text": "TeeZip(xform::Transducer)\n\nBranch input into two \"flows\", inject one into xform and then merge the output of xform with the original input.\n\nTo illustrate how it works, consider the following usage\n\nxf0 |> TeeZip(xf1) |> xf2\n\nwhere xf0, xf1, and xf2 are some transducers.  Schematically, the output yn from xfn flows as follows:\n\nxf0      xf1                       xf2\n---- y0 ------ y1 ---.-- (y0, y1) ----->\n      |              |\n       `-------------\'\n    \"Tee\"          \"Zip\"\n\nExamples\n\njulia> using Transducers\n\njulia> collect(TeeZip(Filter(isodd) |> Map(x -> x + 1)), 1:5)\n3-element Array{Tuple{Int64,Int64},1}:\n (1, 2)\n (3, 4)\n (5, 6)\n\n\n\n\n\n"
},

{
    "location": "manual/#Transducers.Zip-Tuple",
    "page": "Manual",
    "title": "Transducers.Zip",
    "category": "method",
    "text": "Zip(xforms...)\n\nZip outputs of transducers xforms in a tuple and pass it to the inner reduction step.\n\nwarning: Warning\nHead transducers drive tail transducers.  Be careful when using it with transducers other than Map, especially the contractive ones like PartitionBy and the expansive ones like MapCat.\n\nExamples\n\njulia> using Transducers\n\njulia> collect(Zip(Map(identity), Map(x -> 10x), Map(x -> 100x)), 1:3)\n3-element Array{Tuple{Int64,Int64,Int64},1}:\n (1, 10, 100)\n (2, 20, 200)\n (3, 30, 300)\n\n\n\n\n\n"
},

{
    "location": "manual/#Transducers-1",
    "page": "Manual",
    "title": "Transducers",
    "category": "section",
    "text": "Modules = [Transducers]\nPrivate = false\nFilter = Transducers.is_transducer_type"
},

{
    "location": "manual/#Transducers.Completing",
    "page": "Manual",
    "title": "Transducers.Completing",
    "category": "type",
    "text": "Completing(function)\n\nWrap a function to add a no-op complete protocol.  Use it when passing a function without 1-argument arity to transduce etc.\n\nThis API is modeled after completing in Clojure.\n\n\n\n\n\n"
},

{
    "location": "manual/#Transducers.Initializer",
    "page": "Manual",
    "title": "Transducers.Initializer",
    "category": "type",
    "text": "Initializer(f[, ReturnType])\n\nWrap a factory function to create an initial value for transducible processes (e.g., mapfoldl) and \"stateful\" transducers (e.g., Scan).\n\nInitializer must be used whenever using in-place reduction with mapreduce.\n\nExamples\n\njulia> using Transducers\n\njulia> xf1 = Scan(push!, [])\nScan(push!, Any[])\n\njulia> mapfoldl(xf1, right, 1:3)\n3-element Array{Any,1}:\n 1\n 2\n 3\n\njulia> xf1\nScan(push!, Any[1, 2, 3])\n\nNotice that the array is stored in xf1 and mutated in-place.  As a result, second run of mapfoldl contains the results from the first run:\n\njulia> mapfoldl(xf1, right, 10:11)\n5-element Array{Any,1}:\n  1\n  2\n  3\n 10\n 11\n\nThis may not be desired.  To avoid this behavior, create an Initializer object which takes a factory function to create a new initial value.\n\njulia> xf2 = Scan(push!, Initializer(() -> []))\nScan(push!, Initializer{##9#10,Array{Any,1}}(##9#10()))\n\njulia> mapfoldl(xf2, right, 1:3)\n3-element Array{Any,1}:\n 1\n 2\n 3\n\njulia> mapfoldl(xf2, right, 10:11)\n2-element Array{Any,1}:\n 10\n 11\n\nKeyword argument init for transducible processes also accept an Initializer:\n\njulia> mapfoldl(Map(identity), push!, \"abc\"; init=Initializer(() -> Char[]))\n3-element Array{Char,1}:\n \'a\'\n \'b\'\n \'c\'\n\n\n\n\n\n"
},

{
    "location": "manual/#Transducers.right",
    "page": "Manual",
    "title": "Transducers.right",
    "category": "function",
    "text": "right([l, ]r) -> r\n\nIt is simply defined as\n\nright(l, r) = r\nright(r) = r\n\nThis function is meant to be used as step argument for mapfoldl etc. for extracting the last output of the transducers.  Note that init for right is set to nothing if not provided.\n\nExamples\n\njulia> using Transducers\n\njulia> mapfoldl(Take(5), right, 1:10)\n5\n\njulia> mapfoldl(Drop(5), right, 1:3) === nothing\ntrue\n\njulia> mapfoldl(Drop(5), right, 1:3; init=0)  # using `init` as the default value\n0\n\n\n\n\n\n"
},

{
    "location": "manual/#Miscellaneous-1",
    "page": "Manual",
    "title": "Miscellaneous",
    "category": "section",
    "text": "Completing\nInitializer\nright"
},

{
    "location": "interface/#",
    "page": "Interface",
    "title": "Interface",
    "category": "page",
    "text": ""
},

{
    "location": "interface/#Transducer-interface-1",
    "page": "Interface",
    "title": "Transducer interface",
    "category": "section",
    "text": ""
},

{
    "location": "interface/#Transducers.Transducer",
    "page": "Interface",
    "title": "Transducers.Transducer",
    "category": "type",
    "text": "Transducer\n\nThe abstract type for transducers.\n\n\n\n\n\n"
},

{
    "location": "interface/#Transducers.AbstractFilter",
    "page": "Interface",
    "title": "Transducers.AbstractFilter",
    "category": "type",
    "text": "AbstractFilter <: Transducer\n\nThe abstract type for filter-like transducers.  outtype is appropriately defined for child types.\n\n\n\n\n\n"
},

{
    "location": "interface/#Transducers.R_",
    "page": "Interface",
    "title": "Transducers.R_",
    "category": "type",
    "text": "Transducers.R_{X}\n\nWhen defining a transducer type X, it is often required to dispatch on type rf::R_{X} (Reducing Function) which bundles the current transducer rf.xform::X and the inner reducing function rf.inner::R_.\n\nconst R_{X} = Reduction{<:X}\n\n\n\n\n\n"
},

{
    "location": "interface/#Transducers.start",
    "page": "Interface",
    "title": "Transducers.start",
    "category": "function",
    "text": "Transducers.start(rf::R_{X}, state)\n\nThis is an optional interface for a transducer.  Default implementation just calls start of the inner reducing function; i.e.,\n\nstart(rf::Reduction, result) = start(rf.inner, result)\n\nIf the transducer X is stateful, it can \"bundle\" its private state with state (so that next function can be \"pure\").\n\nstart(rf::R_{X}, result) = wrap(rf, PRIVATE_STATE, start(rf.inner, result))\n\nSee Take, PartitionBy, etc. for real-world examples.\n\nSide notes: There is no related API in Clojure\'s Transducers. Transducers.jl uses it to implement stateful transducers using \"pure\" functions.  The idea is based on a slightly different approach taken in C++ Transducer library atria.\n\n\n\n\n\n"
},

{
    "location": "interface/#Transducers.next",
    "page": "Interface",
    "title": "Transducers.next",
    "category": "function",
    "text": "Transducers.next(rf::R_{X}, state, input)\n\nThis is the only required interface.  It takes the following form (if start is not defined):\n\nnext(rf::R_{X}, result, input) =\n    # code calling next(rf.inner, result, possibly_modified_input)\n\nSee Map, Filter, Cat, etc. for real-world examples.\n\n\n\n\n\n"
},

{
    "location": "interface/#Transducers.complete",
    "page": "Interface",
    "title": "Transducers.complete",
    "category": "function",
    "text": "Transducers.complete(rf::R_{X}, state)\n\nThis is an optional interface for a transducer.  If transducer X has some internal state, this is the last chance to \"flush\" the result.\n\nSee PartitionBy, etc. for real-world examples.\n\nIf both complete(rf::R_{X}, state) and start(rf::R_{X}, state) are defined, complete must unwarp state before returning state to the outer reducing function.  If complete is not defined for R_{X}, this happens automatically.\n\n\n\n\n\n"
},

{
    "location": "interface/#Transducers.outtype",
    "page": "Interface",
    "title": "Transducers.outtype",
    "category": "function",
    "text": "outtype(xf::Transducer, intype)\n\nOutput item type for the transducer xf when the input type is intype.\n\n\n\n\n\n"
},

{
    "location": "interface/#Core-interface-for-transducers-1",
    "page": "Interface",
    "title": "Core interface for transducers",
    "category": "section",
    "text": "Transducers.Transducer\nTransducers.AbstractFilter\nTransducers.R_\nTransducers.start\nTransducers.next\nTransducers.complete\nTransducers.outtype"
},

{
    "location": "interface/#Transducers.wrap",
    "page": "Interface",
    "title": "Transducers.wrap",
    "category": "function",
    "text": "wrap(rf::R_{X}, state, iresult)\n\nPack private state for reducing function rf (or rather the transducer X) with the result iresult returned from the inner reducing function rf.inner.  This packed result is typically passed to the outer reducing function.\n\nThis is intended to be used only in start.  Inside next, use wrapping.\n\nConsider a reducing step constructed as\n\nrf = Reduction(xf₁ |> xf₂ |> xf₃, f, intype)\n\nwhere each xfₙ is a stateful transducer and hence needs a private state stateₙ.  Then, calling start(rf, result)) is equivalent to\n\nwrap(rf,\n     state₁,                     # private state for xf₁\n     wrap(rf.inner,\n          state₂,                # private state for xf₂\n          wrap(rf.inner.inner,\n               state₃,           # private state for xf₃\n               result)))\n\nor equivalently\n\nresult₃ = result\nresult₂ = wrap(rf.inner.inner, state₃, result₃)\nresult₁ = wrap(rf.inner,       state₂, result₂)\nresult₀ = wrap(rf,             state₁, result₁)\n\nThe inner most step function receives the original result as the first argument while transducible processes such as mapfoldl only sees the outer-most \"tree\" result₀ during the reduction.  The whole tree is unwraped during the complete phase.\n\nSee wrapping, unwrap, and start.\n\n\n\n\n\n"
},

{
    "location": "interface/#Transducers.unwrap",
    "page": "Interface",
    "title": "Transducers.unwrap",
    "category": "function",
    "text": "unwrap(rf, result)\n\nUnwrap wraped result to a private state and inner result. Following identity holds:\n\nunwrap(rf, wrap(rf, state, iresult)) == (state, iresult)\n\nThis is intended to be used only in complete.  Inside next, use wrapping.\n\n\n\n\n\n"
},

{
    "location": "interface/#Transducers.wrapping",
    "page": "Interface",
    "title": "Transducers.wrapping",
    "category": "function",
    "text": "wrapping(f, rf, result)\n\nFunction f must take two argument state and iresult, and return a tuple (state, iresult).  This is intended to be used only in next, possibly with a do block.\n\nnext(rf::R_{MyTransducer}, result, input) =\n    wrapping(rf, result) do my_state, iresult\n        # code calling `next(rf.inner, iresult, possibly_modified_input)`\n        return my_state, iresult  # possibly modified\n    end\n\nSee wrap, unwrap, and next.\n\n\n\n\n\n"
},

{
    "location": "interface/#Helpers-for-stateful-transducers-1",
    "page": "Interface",
    "title": "Helpers for stateful transducers",
    "category": "section",
    "text": "Transducers.wrap\nTransducers.unwrap\nTransducers.wrapping"
},

{
    "location": "interface/#Transducers.__foldl__",
    "page": "Interface",
    "title": "Transducers.__foldl__",
    "category": "function",
    "text": "__foldl__(rf, init, reducible::T)\n\nLeft fold a reducible with reducing function rf and initial value init.  This is primary an API for overloading when the reducible \"container\" or \"context\" (e.g., I/O stream) of type T can provide a better reduction mechanism than the default iterator-based one.\n\nFor a simple iterable type MyType, a valid implementation is:\n\nfunction __foldl__(rf, val, itr::MyType)\n    for x in itr\n        val = next(rf, val, x)\n        @return_if_reduced complete(rf, val)\n    end\n    return complete(rf, val)\nend\n\nalthough in this case default __foldl__ can handle MyType and thus there is no need for defining it.  In general, defining __foldl__ is useful only when there is a better way to go over items in reducible than Base.iterate.\n\nSee also: @return_if_reduced.\n\n\n\n\n\n"
},

{
    "location": "interface/#Transducers.@return_if_reduced",
    "page": "Interface",
    "title": "Transducers.@return_if_reduced",
    "category": "macro",
    "text": "@return_if_reduced complete(rf, val)\n\nIt transforms the given expression to:\n\nval isa Reduced && return ensure_reduced(complete(rf, unreduced(val)))\n\nThat is to say, if val is Reduced, unpack it, call complete, re-pack into Reduced, and then finally return it.\n\nExamples\n\njulia> using Transducers: @return_if_reduced\n\njulia> @macroexpand @return_if_reduced complete(rf, val)\n:(val isa Transducers.Reduced && return (Transducers.ensure_reduced)(complete(rf, (Transducers.unreduced)(val))))\n\n\n\n\n\n"
},

{
    "location": "interface/#Interface-for-reducibles-1",
    "page": "Interface",
    "title": "Interface for reducibles",
    "category": "section",
    "text": "Transducers.__foldl__\nTransducers.@return_if_reduced"
},

{
    "location": "internals/#",
    "page": "Internals",
    "title": "Internals",
    "category": "page",
    "text": ""
},

{
    "location": "internals/#Transducers.simple_transduce",
    "page": "Internals",
    "title": "Transducers.simple_transduce",
    "category": "function",
    "text": "simple_transduce(xform, step, init, coll)\n\nSimplified version of transduce.  For simple transducers Julia may be able to emit a good code.  This function exists only for performance tuning.\n\n\n\n\n\n"
},

{
    "location": "internals/#Transducers.foldl_nocomplete",
    "page": "Internals",
    "title": "Transducers.foldl_nocomplete",
    "category": "function",
    "text": "foldl_nocomplete(rf, init, coll)\n\nCall __foldl__ without calling complete.\n\n\n\n\n\n"
},

{
    "location": "internals/#Internals-1",
    "page": "Internals",
    "title": "Internals",
    "category": "section",
    "text": "Transducers.simple_transduce\nTransducers.foldl_nocomplete"
},

{
    "location": "examples/words/#",
    "page": "Parallel word count",
    "title": "Parallel word count",
    "category": "page",
    "text": "EditURL = \"https://github.com/tkf/Transducers.jl/blob/master/examples/words.jl\""
},

{
    "location": "examples/words/#Splitting-a-string-into-words-and-counting-them-in-parallel-1",
    "page": "Parallel word count",
    "title": "Splitting a string into words and counting them in parallel",
    "category": "section",
    "text": "We start from the parallel algorithm presented in Guy Steele\'s 2009 ICFP talk (video).  It splits a space-separated string into list of strings (words).  The repeating theme in the talk was to build \"singleton solutions\" and then merge them together using an associative function.  We will follow this guideline and slightly extend the algorithm.It is highly recommended to just watch the talk for understanding the algorithm.  However, we briefly describe how it works.When a certain contiguous region of a string is processed, we either already have seen at least one space or not.  These two states are tracked using following two types.  If there is no space so far, we only have a chunk of a possibly larger word (see example below):struct Chunk\n    s::String\nendIf there are one or more spaces, (possibly zero) words that are already determined and left/right \"chunks\" have to be tracked separately:struct Segment\n    l::String\n    A::Vector{String}\n    r::String\nendHere is an example taken from the talk:Segment(\"Here\", [\"is\", \"a\"], \"\")\n   |\n   |       Segment(\"lian\", [], \"string\")\n __|_____            _|______\n|        |          |        |\nHere is a sesquipedalian string of words\n          |________|          |________|\n   Chunk(\"sesquipeda\")        Segment(\"g\", [\"of\"], \"words\")We then need a way to merge two results which can independently in one of the above two states.⊕(x::Chunk, y::Chunk) = Chunk(x.s * y.s)\n⊕(x::Chunk, y::Segment) = Segment(x.s * y.l, y.A, y.r)\n⊕(x::Segment, y::Chunk) = Segment(x.l, x.A, x.r * y.s)\n⊕(x::Segment, y::Segment) =\n    Segment(x.l,\n            append!(append!(x.A, maybewordv(x.r * y.l)), y.A),\n            y.r)\n\nmaybewordv(s::String) = isempty(s) ? String[] : [s]\nnothing  # hideInput is a sequence of Chars.  Each of them has to be converted into a \"singleton solution\" which can be merged with already aggregated (or another singleton) solution with ⊕:segmentorchunk(c::Char) = c == \' \' ? Segment(\"\", [], \"\") : Chunk(string(c))\nnothing  # hidePutting them together, we get:function collectwords(s::String)\n    g = mapfoldl(segmentorchunk, ⊕, s; init=Segment(\"\", [], \"\"))\n    if g isa Char\n        return maybewordv(g.s)\n    else\n        return append!(append!(maybewordv(g.l), g.A), maybewordv(g.r))\n    end\nend\nnothing  # hideLet\'s run a few tests covering some edge cases:using Test\n@testset begin\n    @test collectwords(\"This is a sample\") == [\"This\", \"is\", \"a\", \"sample\"]\n    @test collectwords(\" Here is another sample \") == [\"Here\", \"is\", \"another\", \"sample\"]\n    @test collectwords(\"JustOneWord\") == [\"JustOneWord\"]\n    @test collectwords(\" \") == []\n    @test collectwords(\"\") == []\nend\nnothing  # hide"
},

{
    "location": "examples/words/#String-splitting-transducer-1",
    "page": "Parallel word count",
    "title": "String-splitting transducer",
    "category": "section",
    "text": "Let\'s try to make it re-usable by packaging it into transducers.using TransducersRather than accumulating words into a vector, we are going to write a transducer that \"emits\" a word as soon as it is ready.  The downstream transducer may choose to record everything or only aggregate, e.g., reduced statistics.  To this end, we replace Segment in the original algorithm tostruct Vacant\n    l::String\n    r::String\nendand output the words in the \"middle\" without accumulating it.  We use ScanEmit which requires an operator/function like ⊕ above but returning a pair of output and next state.  This function (extract below) must have the signature (S, S) -> (O, S) where S is the type for accumulated state and input and O is the output type.extract(x::Chunk, y::Chunk) = (), Chunk(x.s * y.s)\nextract(x::Chunk, y::Vacant) = (), Vacant(x.s * y.l, y.r)\nextract(x::Vacant, y::Chunk) = (), Vacant(x.l, x.r * y.s)\nextract(x::Vacant, y::Vacant) = maybewordt(x.r * y.l), Vacant(x.l, y.r)\n\nmaybewordt(s) = isempty(s) ? () : (s,)\nnothing  # hidemaybewordt(x.r * y.l) in extract(x::Vacant, y::Vacant) is the \"emission\".The words at the beginning and/or the end are not handled by extract.  This must be handled separately:lastword(x::Chunk) = maybewordt(x.s)\nlastword(x::Vacant) = (maybewordt(x.r)..., maybewordt(x.l)...)\n\nvacantorchunk(c::Char) = c == \' \' ? Vacant(\"\", \"\") : Chunk(string(c))\n\nwordsxf = Map(vacantorchunk) |> ScanEmit(extract, Chunk(\"\"), lastword) |> Cat()Test:@testset begin\n    @test collect(wordsxf, \"This is a sample\") == [\"is\", \"a\", \"sample\", \"This\"]\n    @test collect(wordsxf, \" Here is another sample \") == [\"Here\", \"is\", \"another\", \"sample\"]\n    @test collect(wordsxf, \"JustOneWord\") == [\"JustOneWord\"]\n    @test collect(wordsxf, \" \") == []\n    @test collect(wordsxf, \"\") == []\nend\nnothing  # hideSide note: In the first example, the first word This comes last. This is actually expected since both .l and .r are flushed in lastword which is called at the very end.  Here, This is stored in .l field.  If the order of the words is important, there are many possible fixes.  For example, extract and lastword can bundle information about the origin of the word (left vs middle-or-right).  Alternatively, perhaps the easiest solution is to insert a space in the beginning of input data."
},

{
    "location": "examples/words/#Word-counting-transducer-1",
    "page": "Parallel word count",
    "title": "Word-counting transducer",
    "category": "section",
    "text": "We can pipe the resulting words into various transducers.processcount(word) = Base.ImmutableDict(word => 1)\ncountxf = wordsxf |> Map(processcount)Transducer countxf constructs a \"singleton solution\" as a dictionary which then accumulated with the associative reducing step function mergecont!:mergecont!(a, b) = merge!(+, a, b)\nmergecont!(a) = a\nnothing  # hideNote that the unary form is required for the completion. Alternatively, we can use Completing((a, b) -> merge!(+, a, b)) instead of mergecont!.  Putting the transducer and reducing function together, we get:countwords(s; kwargs...) =\n    mapreduce(Map(Char) |> countxf,\n              mergecont!,\n              transcode(UInt8, s);\n              init = Initializer(Dict{String,Int}),\n              kwargs...)\nnothing  # hideSide note: Since mapreduce does not support string, the input string is converted to a Vector{UInt8} first by transcode. That\'s why there is Map(Char) |> before countxf.  Of course, this is not valid for UTF-8 in general.Side note 2: We use Initializer to create a fresh initial state for each sub-reduce to avoid overwriting mutable data between threads.Let\'s run some tests with different number of threads:@testset for nthreads in [1, 2, 4]\n    @test countwords(\"This is a sample\", nthreads=nthreads) ==\n        Dict(\"This\" => 1, \"is\" => 1, \"a\" => 1, \"sample\" => 1)\n    @test countwords(\" Here is another sample \", nthreads=nthreads) ==\n        Dict(\"Here\" => 1, \"is\" => 1, \"another\" => 1, \"sample\" => 1)\n    @test countwords(\"JustOneWord\", nthreads=nthreads) ==\n        Dict(\"JustOneWord\" => 1)\n    @test countwords(\" \", nthreads=nthreads) == Dict()\n    @test countwords(\"\", nthreads=nthreads) == Dict()\n    @test countwords(\"aaa bb aaa aaa bb bb aaa\", nthreads=nthreads) ==\n        Dict(\"aaa\" => 4, \"bb\" => 3)\nend\nnothing  # hideThis page was generated using Literate.jl."
},

{
    "location": "examples/primes/#",
    "page": "Prime sieve",
    "title": "Prime sieve",
    "category": "page",
    "text": "EditURL = \"https://github.com/tkf/Transducers.jl/blob/master/examples/primes.jl\""
},

{
    "location": "examples/primes/#Prime-sieve-1",
    "page": "Prime sieve",
    "title": "Prime sieve",
    "category": "section",
    "text": "Transducer prime_xf below produces a sequence of prime numbers given a sequence of integers 2, 3, 4, and so on.if !@isdefined isnothing          # hide\n    isnothing(x) = x === nothing  # hide\nend                               # hide\n\nusing Transducers\n\nsieve(xf, x) =\n    if mapreduce(xf, right, (x,)) === nothing\n        nothing, xf\n    else\n        x, xf |> Filter(n -> n % x != 0)\n    end\n\nprime_xf = ScanEmit(sieve, Map(identity)) |> Filter(!isnothing)\n\nprimes = begin  # hide\ncollect(prime_xf, 2:10)\nend  # hide@assert primes == [2, 3, 5, 7]  # hideThe usage of transducers in prime_xf here is somewhat unconventional; it builds a transducer inside a transducer.  That is to say, the state of ScanEmit is itself a transducer (initialized as the identity transducer Map(identity)).  The step function sieve for ScanEmit then appends a transducer to filter out numbers divisible by a prime number when a prime number is found (i.e., a number is not filtered out by existing filter transducer).See: right, ScanEmit, Map, Filter, mapreduce, collectnote: Side notes\nThis is inspired by the prime sieve implemented using communicating sequential processes (CSP) written in Newsqueak by Doug McIlroy and also ported to Go (See also Google Tech Talk by Rob Pike). But, once I\'ve written this, I\'m not sure if I needed to know about CSP to implement this.  CSP and transducers probably do not relate much.  However, I thought this was a somewhat interesting intersection (and I wanted to give credit to them anyway).This page was generated using Literate.jl."
},

{
    "location": "examples/transducers/#",
    "page": "Writing transducers",
    "title": "Writing transducers",
    "category": "page",
    "text": "EditURL = \"https://github.com/tkf/Transducers.jl/blob/master/examples/transducers.jl\""
},

{
    "location": "examples/transducers/#How-to-write-transducers-1",
    "page": "Writing transducers",
    "title": "How to write transducers",
    "category": "section",
    "text": "Transducers don\'t export public interface for implementing transducers (and reducible collections).  Let\'s import some handy ones:using Transducers\nusing Transducers: Transducer, R_, next"
},

{
    "location": "examples/transducers/#Stateless-transducer-1",
    "page": "Writing transducers",
    "title": "Stateless transducer",
    "category": "section",
    "text": "Let\'s write manually what Filter(x -> x isa Int) |> Map(x -> x + 1) would do:struct AddOneIfInt <: Transducer end\n\nfunction Transducers.next(rf::R_{AddOneIfInt}, result, input)\n    if input isa IntOutput input + 1 is passed to the \"inner\" reducing step:        next(rf.inner, result, input + 1)\n    elseFiltering out is done by \"doing nothing\"; return result-so-far as-is:        result\n    end\nendIneed, for integer collection, it increments input by one:addone_out1 = begin  # hide\ncollect(AddOneIfInt(), 1:5)\nend  # hideNon integer elements are filtered out:collect(AddOneIfInt(), Any[3, nothing, 2.0, missing, 5])Notice that output eltype is Any; it can be fixed by defining outtype:Transducers.outtype(::AddOneIfInt, _intype) = Int\n\naddone_out2 = begin  # hide\ncollect(AddOneIfInt(), 1:5)\nend  # hide"
},

{
    "location": "examples/transducers/#Stateful-transducer-1",
    "page": "Writing transducers",
    "title": "Stateful transducer",
    "category": "section",
    "text": "AddOneIfInt is a stateless transducer which is very easy to implement.  A stateful transducer needs a bit more code.using Transducers: start, complete, InType, wrap, unwrap, wrapping\nusing RandomLet\'s define a transducer that spits out a random past element from the buffer:struct RandomRecall <: Transducer\n    history::Int\n    seed::Int\nend\nRandomRecall() = RandomRecall(3, 0)\nnothing  # hideA stateful transducer needs to implement Transducers.start to \"allocate\" its private state.  Here, the private state is a buffer and a random number generator state rng:function Transducers.start(rf::R_{RandomRecall}, result)\n    buffer = InType(rf)[]\n    rng = MersenneTwister(rf.xform.seed)\n    private_state = (buffer, rng)\n    return wrap(rf, private_state, start(rf.inner, result))\nendStateful transducer needs to unwrap its private state inside Transducers.next and then re-wrap it.  There is a helper function Transducers.wrapping does that with the do block:function Transducers.next(rf::R_{RandomRecall}, result, input)\n    wrapping(rf, result) do (buffer, rng), iresultPickup a random element to be passed to the inner reducing function. Replace it with the new incoming one in the buffer:        if length(buffer) < rf.xform.history\n            push!(buffer, input)\n            iinput = rand(rng, buffer)\n        else\n            i = rand(rng, 1:length(buffer))\n            iinput = buffer[i]\n            buffer[i] = input\n        endCall the inner reducing function.  Note that iresult unwrapped by Transducers.wrapping must be passed to next:        iresult = next(rf.inner, iresult, iinput)\n        return (buffer, rng), iresult\n    end\nend\n\nTransducers.outtype(::RandomRecall, intype) = intypeIndeed, it picks up some random elements from the past elements:recall_out1 = begin  # hide\ncollect(RandomRecall(), 1:5)\nend  # hideWith slightly more complex transducer:collect(Filter(isodd) |> RandomRecall() |> Filter(x -> x > 10) |> Take(5), 1:100)Another overloadable API is Transducers.complete.  It is invoked at the end of each transducible process.  It is useful for, e.g., flushing buffer.function Transducers.complete(rf::R_{RandomRecall}, result)\n    (buffer, _), iresult = unwrap(rf, result)\n    for x in bufferNote that inner next can be called more than one time inside next and complete:        iresult = next(rf.inner, iresult, x)\n    endcomplete for inner reducing function must be called exactly once:    return complete(rf.inner, iresult)\nendThis then adds 3 (= RandomRecall().history) more elements to the output:recall_out2 = begin  # hide\ncollect(RandomRecall(), 1:5)\nend  # hideThis page was generated using Literate.jl."
},

{
    "location": "examples/reducibles/#",
    "page": "Writing reducibles",
    "title": "Writing reducibles",
    "category": "page",
    "text": "EditURL = \"https://github.com/tkf/Transducers.jl/blob/master/examples/reducibles.jl\""
},

{
    "location": "examples/reducibles/#How-to-make-your-data-type-reducible-1",
    "page": "Writing reducibles",
    "title": "How to make your data type reducible",
    "category": "section",
    "text": "Let\'s see how to make a vector-of-vector a reducible collection; i.e., a type that can be fed to mapfoldl.struct VecOfVec{T}\n    vectors::Vector{Vector{T}}\nendWe need next and complete to invoke the reducing function rf and @return_if_reduced to support early termination.using Transducers\nusing Transducers: next, complete, @return_if_reducedSupporting mapfoldl and similar only requires Transducers.__foldl__:function Transducers.__foldl__(rf, val, vov::VecOfVec)\n    for vector in vov.vectors\n        for x in vector\n            val = next(rf, val, x)\n            @return_if_reduced complete(rf, val)\n        end\n    end\n    return complete(rf, val)\nendNote that it\'s often a good idea to implement Base.eltype:Base.eltype(::VecOfVec{T}) where {T} = TIt can be then used as the input to the transducers:vov = VecOfVec(collect.([1:n for n in 1:3]))\ncollect(Map(identity), vov)Transducers.@return_if_reduced above is used to support terminating transducer like Take.collect(Take(3), vov)More complex example:collect(PartitionBy(isequal(1)) |> Map(copy) |> TeeZip(Map(sum)), vov)Notice that writing Transducers.__foldl__ is very straightforward comparing to how to define an iterator:function Base.iterate(vov::VecOfVec, state=nothing)\n    if state === nothing\n        i, j = 1, 1\n    else\n        i, j = state\n    end\n    i > length(vov.vectors) && return nothingIf j is in bound, we are iterating the same sub-vector:    vi = vov.vectors[i]\n    if j <= length(vi)\n        return vi[j], (i, j + 1)\n    endOtherwise, find the next non-empty sub-vector and start iterating it:    for k in i + 1:length(vov.vectors)\n        vk = vov.vectors[k]\n        if !isempty(vk)\n            return vk[1], (k, 2)  # i=k, j=2\n        end\n    end\n    return nothing\nend\n\nBase.length(vov::VecOfVec) = sum(length, vov.vectors)\n\ncollect(vov)This page was generated using Literate.jl."
},

]}
