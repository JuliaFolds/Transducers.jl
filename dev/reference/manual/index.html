<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Manual · Transducers.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Transducers.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Reference</span><ul><li class="is-active"><a class="tocitem" href>Manual</a><ul class="internal"><li><a class="tocitem" href="#Transducible-processes"><span>Transducible processes</span></a></li><li><a class="tocitem" href="#Transducers"><span>Transducers</span></a></li><li><a class="tocitem" href="#combinators"><span>Other reducing function combinators</span></a></li><li><a class="tocitem" href="#Early-termination"><span>Early termination</span></a></li><li><a class="tocitem" href="#Miscellaneous"><span>Miscellaneous</span></a></li><li><a class="tocitem" href="#Deprecated"><span>Deprecated</span></a></li></ul></li><li><a class="tocitem" href="../interface/">Interface</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/tutorial_missings/">Tutorial: Missing values</a></li><li><a class="tocitem" href="../../tutorials/tutorial_parallel/">Tutorial: Parallelism</a></li><li><a class="tocitem" href="../../tutorials/words/">Parallel word count</a></li></ul></li><li><span class="tocitem">How-to guides</span><ul><li><a class="tocitem" href="../../howto/upgrade-to-ixf/">Upgrade to new <code>|&gt;</code> of Transducers.jl 0.4.39</a></li><li><a class="tocitem" href="../../howto/empty_result_handling/">Empty result handling</a></li><li><a class="tocitem" href="../../howto/transducers/">Writing transducers</a></li><li><a class="tocitem" href="../../howto/reducibles/">Writing reducibles</a></li></ul></li><li><span class="tocitem">Explanation</span><ul><li><a class="tocitem" href="../../parallelism/">Parallelism</a></li><li><a class="tocitem" href="../../explanation/comparison_to_iterators/">Comparison to iterators</a></li><li><a class="tocitem" href="../../explanation/glossary/">Glossary</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>Manual</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Manual</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaFolds/Transducers.jl/blob/master/docs/src/reference/manual.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Transducers-and-Transducible-processes"><a class="docs-heading-anchor" href="#Transducers-and-Transducible-processes">Transducers and Transducible processes</a><a id="Transducers-and-Transducible-processes-1"></a><a class="docs-heading-anchor-permalink" href="#Transducers-and-Transducible-processes" title="Permalink"></a></h1><ul><li><a href="#BangBang.append!!"><code>BangBang.append!!</code></a></li><li><a href="#Base.:∘"><code>Base.:∘</code></a></li><li><a href="#Base.adjoint"><code>Base.adjoint</code></a></li><li><a href="#Base.append!"><code>Base.append!</code></a></li><li><a href="#Base.collect"><code>Base.collect</code></a></li><li><a href="#Base.copy"><code>Base.copy</code></a></li><li><a href="#Base.copy!"><code>Base.copy!</code></a></li><li><a href="#Base.foldl"><code>Base.foldl</code></a></li><li><a href="#Base.foreach"><code>Base.foreach</code></a></li><li><a href="#Base.map!"><code>Base.map!</code></a></li><li><a href="#Base.mapfoldl"><code>Base.mapfoldl</code></a></li><li><a href="#Base.mapreduce"><code>Base.mapreduce</code></a></li><li><a href="#Base.reduce"><code>Base.reduce</code></a></li><li><a href="#Transducers.Zip-Tuple"><code>Transducers.Zip</code></a></li><li><a href="#Transducers.append_unordered!"><code>Transducers.append_unordered!</code></a></li><li><a href="#Transducers.channel_unordered"><code>Transducers.channel_unordered</code></a></li><li><a href="#Transducers.dcollect"><code>Transducers.dcollect</code></a></li><li><a href="#Transducers.dcopy"><code>Transducers.dcopy</code></a></li><li><a href="#Transducers.dreduce"><code>Transducers.dreduce</code></a></li><li><a href="#Transducers.dtransduce"><code>Transducers.dtransduce</code></a></li><li><a href="#Transducers.eduction"><code>Transducers.eduction</code></a></li><li><a href="#Transducers.ifunreduced"><code>Transducers.ifunreduced</code></a></li><li><a href="#Transducers.reduced"><code>Transducers.reduced</code></a></li><li><a href="#Transducers.reducingfunction"><code>Transducers.reducingfunction</code></a></li><li><a href="#Transducers.right"><code>Transducers.right</code></a></li><li><a href="#Transducers.setinput"><code>Transducers.setinput</code></a></li><li><a href="#Transducers.tcollect"><code>Transducers.tcollect</code></a></li><li><a href="#Transducers.tcopy"><code>Transducers.tcopy</code></a></li><li><a href="#Transducers.transduce"><code>Transducers.transduce</code></a></li><li><a href="#Transducers.unreduced"><code>Transducers.unreduced</code></a></li><li><a href="#Transducers.withprogress"><code>Transducers.withprogress</code></a></li><li><a href="#Base.Channel"><code>Base.Channel</code></a></li><li><a href="#Transducers.AdHocFoldable"><code>Transducers.AdHocFoldable</code></a></li><li><a href="#Transducers.Broadcasting"><code>Transducers.Broadcasting</code></a></li><li><a href="#Transducers.Cat"><code>Transducers.Cat</code></a></li><li><a href="#Transducers.Completing"><code>Transducers.Completing</code></a></li><li><a href="#Transducers.CopyInit"><code>Transducers.CopyInit</code></a></li><li><a href="#Transducers.Count"><code>Transducers.Count</code></a></li><li><a href="#Transducers.Dedupe"><code>Transducers.Dedupe</code></a></li><li><a href="#Transducers.Drop"><code>Transducers.Drop</code></a></li><li><a href="#Transducers.DropLast"><code>Transducers.DropLast</code></a></li><li><a href="#Transducers.DropWhile"><code>Transducers.DropWhile</code></a></li><li><a href="#Transducers.Enumerate"><code>Transducers.Enumerate</code></a></li><li><a href="#Transducers.Filter"><code>Transducers.Filter</code></a></li><li><a href="#Transducers.FlagFirst"><code>Transducers.FlagFirst</code></a></li><li><a href="#Transducers.GetIndex"><code>Transducers.GetIndex</code></a></li><li><a href="#Transducers.GroupBy"><code>Transducers.GroupBy</code></a></li><li><a href="#Transducers.Inject"><code>Transducers.Inject</code></a></li><li><a href="#Transducers.Interpose"><code>Transducers.Interpose</code></a></li><li><a href="#Transducers.Iterated"><code>Transducers.Iterated</code></a></li><li><a href="#Transducers.Keep"><code>Transducers.Keep</code></a></li><li><a href="#Transducers.Map"><code>Transducers.Map</code></a></li><li><a href="#Transducers.MapCat"><code>Transducers.MapCat</code></a></li><li><a href="#Transducers.MapSplat"><code>Transducers.MapSplat</code></a></li><li><a href="#Transducers.NotA"><code>Transducers.NotA</code></a></li><li><a href="#Transducers.OfType"><code>Transducers.OfType</code></a></li><li><a href="#Transducers.OnInit"><code>Transducers.OnInit</code></a></li><li><a href="#Transducers.Partition"><code>Transducers.Partition</code></a></li><li><a href="#Transducers.PartitionBy"><code>Transducers.PartitionBy</code></a></li><li><a href="#Transducers.ProductRF"><code>Transducers.ProductRF</code></a></li><li><a href="#Transducers.ReduceIf"><code>Transducers.ReduceIf</code></a></li><li><a href="#Transducers.Reduced"><code>Transducers.Reduced</code></a></li><li><a href="#Transducers.Replace"><code>Transducers.Replace</code></a></li><li><a href="#Transducers.Scan"><code>Transducers.Scan</code></a></li><li><a href="#Transducers.ScanEmit"><code>Transducers.ScanEmit</code></a></li><li><a href="#Transducers.SetIndex"><code>Transducers.SetIndex</code></a></li><li><a href="#Transducers.TCat"><code>Transducers.TCat</code></a></li><li><a href="#Transducers.Take"><code>Transducers.Take</code></a></li><li><a href="#Transducers.TakeLast"><code>Transducers.TakeLast</code></a></li><li><a href="#Transducers.TakeNth"><code>Transducers.TakeNth</code></a></li><li><a href="#Transducers.TakeWhile"><code>Transducers.TakeWhile</code></a></li><li><a href="#Transducers.TeeRF"><code>Transducers.TeeRF</code></a></li><li><a href="#Transducers.Transducer-Tuple{OnlineStatsBase.OnlineStat}"><code>Transducers.Transducer</code></a></li><li><a href="#Transducers.Transducer"><code>Transducers.Transducer</code></a></li><li><a href="#Transducers.Transducer-Tuple{Union{Base.Generator, Base.Iterators.Filter, Base.Iterators.Flatten}}"><code>Transducers.Transducer</code></a></li><li><a href="#Transducers.Unique"><code>Transducers.Unique</code></a></li><li><a href="#Transducers.ZipSource"><code>Transducers.ZipSource</code></a></li></ul><h2 id="Transducible-processes"><a class="docs-heading-anchor" href="#Transducible-processes">Transducible processes</a><a id="Transducible-processes-1"></a><a class="docs-heading-anchor-permalink" href="#Transducible-processes" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Transducers.transduce" href="#Transducers.transduce"><code>Transducers.transduce</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">transduce(xf, step, init, reducible) :: Union{T, Reduced{T}}</code></pre><p>See <a href="#Base.foldl"><code>foldl</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/processes.jl#LL354-L358">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.foldl" href="#Base.foldl"><code>Base.foldl</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">foldl(step, xf::Transducer, reducible; init, simd) :: T
foldl(step, ed::Eduction; init, simd) :: T
transduce(xf, step, init, reducible; simd) :: Union{T, Reduced{T}}</code></pre><p>Compose transducer <code>xf</code> with reducing step function <code>step</code> and reduce <code>itr</code> using it.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>transduce</code> differs from <code>foldl</code> as <code>Reduced{T}</code> is returned if the transducer <code>xf</code> or <code>step</code> aborts the reduction and <code>step</code> is <em>not</em> automatically wrapped by <a href="#Transducers.Completing"><code>Completing</code></a>.</p></div></div><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/transduce"><code>transduce</code> in Clojure</a>.</p><p>For parallel versions, see <a href="#Base.reduce"><code>reduce</code></a> and <a href="#Transducers.dreduce"><code>dreduce</code></a>.</p><p>See also: <a href="../../howto/empty_result_handling/#Empty-result-handling">Empty result handling</a>.</p><p><strong>Arguments</strong></p><ul><li><code>xf::Transducer</code>: A transducer.</li><li><code>step</code>: A callable which accepts 1 and 2 arguments.  If it only accepts 2 arguments, wrap it with <a href="#Transducers.Completing"><code>Completing</code></a> to &quot;add&quot; 1-argument form (i.e., <a href="../interface/#Transducers.complete"><code>complete</code></a> protocol).</li><li><code>reducible</code>: A reducible object (array, dictionary, any iterator, etc.).</li><li><code>init</code>: An initial value fed to the first argument to reducing step function <code>step</code>.  This argument can be omitted for well know binary operations like <code>+</code> or <code>*</code>.  Supported binary operations are listed in InitialValues.jl documentation.  When <code>Init</code> (not the result of <code>Init</code>, such as <code>Init(*)</code>) is given, it is automatically &quot;instantiated&quot; as <code>Init(step)</code> (where <code>step</code> is appropriately unwrapped if <code>step</code> is a <code>Completing</code>).  See <a href="../../howto/empty_result_handling/#Empty-result-handling">Empty result handling</a> in the manual for more information.</li><li><code>simd</code>: If <code>true</code> or <code>:ivdep</code>, enable SIMD using <code>Base.@simd</code>.  If <code>:ivdep</code>, use <code>@simd ivdep for ... end</code> variant.  Read Julia manual of <code>Base.@simd</code> to understand when it is appropriate to use this option.  For example, <code>simd = :ivdep</code> <em>must not</em> be used with stateful transducer like <a href="#Transducers.Scan"><code>Scan</code></a>.  This option has no effect if <code>false</code> (default).</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; foldl(Filter(isodd), 1:4, init=0.0) do state, input
           @show state, input
           state + input
       end
(state, input) = (0.0, 1)
(state, input) = (1.0, 3)
4.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/processes.jl#LL299-L351">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.foreach" href="#Base.foreach"><code>Base.foreach</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">foreach(eff, xf::Transducer, reducible; simd)
foreach(eff, ed::Eduction; simd)</code></pre><p>Feed the results of <code>xf</code> processing items in <code>reducible</code> into a unary function <code>eff</code>.  This is useful when the primary computation at the bottom is the side-effect.  It is also equivalent to <code>foreach(eff, eduction(xf, coll))</code>.  Note that</p><pre><code class="language-julia">foreach(eduction(xf, coll)) do x
    ...
end</code></pre><p>can be more efficient than</p><pre><code class="language-julia">for x in eduction(xf, coll)
    ...
end</code></pre><p>as the former does not have to translate the transducer protocol to the iterator protocol.</p><p><code>foreach</code> supports all constructs in the native <code>for</code> loop as well as the enhancements <sup class="footnote-reference"><a id="citeref-julia_issue_22891" href="#footnote-julia_issue_22891">[julia_issue_22891]</a></sup> to <code>break</code> with a value (<code>break D(x)</code> below) and append the <code>else</code> clause (<code>E(x)</code> below).</p><p>This native <code>for</code> loop</p><pre><code class="language-julia">ans = for x in xs
    A(x)
    B(x) &amp;&amp; break
    C(x) &amp;&amp; break D(x)
else
    E(x)
end</code></pre><p>can be written as</p><pre><code class="language-julia">ans = foreach(Map(identity), xs) do x
    A(x)
    B(x) &amp;&amp; return reduced()
    C(x) &amp;&amp; return reduced(D(x))
    x  # required for passing `x` to `E(x)` below
end |&gt; ifunreduced() do x
    E(x)
end</code></pre><p>See: <a href="#Base.mapfoldl"><code>mapfoldl</code></a>, <a href="#Transducers.reduced"><code>reduced</code></a>, <a href="#Transducers.ifunreduced"><code>ifunreduced</code></a>.</p><div class="admonition is-compat"><header class="admonition-header">Transducers.jl 0.3</header><div class="admonition-body"><p><code>foreach</code> is changed to return what the <code>do</code> block (<code>eff</code> function) returns as-is in version 0.3.  This was required for supporting &quot;for-else&quot; (<code>|&gt; ifunreduced</code>).  Previously, it only supported break-with-value and always applied <code>unreduced</code> before it returns.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; foreach(eduction(Filter(isodd), 1:4)) do input
           @show input
       end
input = 1
input = 3
3

julia&gt; foreach(Filter(!ismissing), [1, missing, 2, 3]) do input
           @show input
           if iseven(input)
               return reduced()
           end
       end
input = 1
input = 2
Reduced(nothing)</code></pre><p>It is often useful to append <a href="#Transducers.unreduced"><code>|&gt; unreduced</code></a> to unwrap <code>Reduced</code> in the final result (note that <code>|&gt;</code> here is the standard function application, not the transducer composition).</p><pre><code class="language-julia-repl">julia&gt; foreach(Filter(!ismissing), [1, missing, 2, 3]) do input
           reduced(&quot;got $input&quot;)
       end |&gt; unreduced
&quot;got 1&quot;</code></pre><p>Combination of break-with-value and for-else is useful for triggering action after (e.g.) some kind of membership testing failed:</p><pre><code class="language-julia-repl">julia&gt; has2(xs) = foreach(Filter(!ismissing), xs) do input
           input == 2 &amp;&amp; reduced(true)
       end |&gt; ifunreduced() do input
           @show input
           false
       end;

julia&gt; has2([1, missing, 2, 3])
true

julia&gt; has2([1, missing])
input = false
false</code></pre><p>However, note the output <code>input = false</code> in the last example.  This is because how <code>&amp;&amp;</code> works in Julia</p><pre><code class="language-julia-repl">julia&gt; false &amp;&amp; &quot;otherwise&quot;
false</code></pre><p>Thus, pure membership testing functions like <code>has2</code> above can be written in a more concise manner:</p><pre><code class="language-julia-repl">julia&gt; simpler_has2(xs) = foreach(Filter(!ismissing), xs) do input
           input == 2 &amp;&amp; reduced(true)
       end |&gt; unreduced;

julia&gt; simpler_has2([1, missing, 2, 3])
true

julia&gt; simpler_has2([1, missing])
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/processes.jl#LL863-L1005">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.reduce" href="#Base.reduce"><code>Base.reduce</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">reduce(step, xf, reducible; [init, simd, basesize, stoppable]) :: T</code></pre><p>Thread-based parallelization of <a href="#Base.foldl"><code>foldl</code></a>.  The &quot;bottom&quot; reduction function <code>step(::T, ::T) :: T</code> must be associative and <code>init</code> must be its identity element.</p><p>Transducers composing <code>xf</code> must be stateless (e.g., <a href="#Transducers.Map"><code>Map</code></a>, <a href="#Transducers.Filter"><code>Filter</code></a>, <a href="#Transducers.Cat"><code>Cat</code></a>, etc.) except for <a href="#Transducers.ScanEmit"><code>ScanEmit</code></a>. Note that <a href="#Transducers.Scan"><code>Scan</code></a> is not supported (although possible in theory).  Early termination requires Julia ≥ 1.3.</p><p>Use <a href="#Transducers.tcollect"><code>tcollect</code></a> or <a href="#Transducers.tcopy"><code>tcopy</code></a> to collect results into a container.</p><p>See also: <a href="../../tutorials/tutorial_parallel/#tutorial-parallel">Parallel processing tutorial</a>, <a href="#Base.foldl"><code>foldl</code></a>, <a href="#Transducers.dreduce"><code>dreduce</code></a>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>basesize::Integer = amount(reducible) ÷ nthreads()</code>: A size of chunk in <code>reducible</code> that is processed by each worker.  A smaller size may be required when:<ul><li>computation time for processing each item fluctuates a lot</li><li>computation can be terminated by <a href="#Transducers.reduced"><code>reduced</code></a> or transducers using it, such as <a href="#Transducers.ReduceIf"><code>ReduceIf</code></a></li></ul></li><li><code>stoppable::Bool</code>: [This option usually does not have to be set manually.]  Transducers.jl&#39;s <code>reduce</code> executed in the &quot;stoppable&quot; mode used for optimizing reduction with <a href="#Transducers.reduced"><code>reduced</code></a> has a slight overhead if <code>reduced</code> is not used.  This mode can be disabled by passing <code>stoppable = false</code>.  It is usually automatically detected and set appropriately.  Note that this option is purely for optimization and does not affect the result value.</li><li>For other keyword arguments, see <a href="#Base.foldl"><code>foldl</code></a>.</li></ul><div class="admonition is-compat"><header class="admonition-header">Transducers.jl 0.4.23</header><div class="admonition-body"><p>Keyword option <code>stoppable</code> requires at least Transducers.jl 0.4.23.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; reduce(+, 1:3 |&gt; Map(exp) |&gt; Map(log))
6.0

julia&gt; using BangBang: append!!

julia&gt; reduce(append!!, Map(x -&gt; 1:x), 1:2; basesize=1, init=Union{}[])
3-element Array{Int64,1}:
 1
 1
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/reduce.jl#LL1-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.dreduce" href="#Transducers.dreduce"><code>Transducers.dreduce</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dreduce(step, xform::Transducer, array; [init, simd, basesize, threads_basesize, pool])</code></pre><p>Distributed.jl-based parallelization of <a href="#Base.foldl"><code>foldl</code></a>.  Input collection must be indexable.</p><p>Unlike <a href="#Base.reduce"><code>reduce</code></a>, early termination by <a href="#Transducers.reduced"><code>reduced</code></a> is not supported yet.</p><p>Use <a href="#Transducers.dcollect"><code>dcollect</code></a> or <a href="#Transducers.dcopy"><code>dcopy</code></a> to collect results into a container.</p><p>See also: <a href="../../tutorials/tutorial_parallel/#tutorial-parallel">Parallel processing tutorial</a>, <a href="#Base.foldl"><code>foldl</code></a>, <a href="#Base.reduce"><code>reduce</code></a>.</p><div class="admonition is-compat"><header class="admonition-header">Transducers.jl 0.4.3</header><div class="admonition-body"><p>New in version 0.4.3.</p></div></div><p><strong>Keyword Arguments</strong></p><ul><li><code>pool::AbstractWorkerPool</code>: Passed to <code>Distributed.remotecall</code>.</li><li><code>basesize::Integer = amount(array) ÷ nworkers()</code>: A size of chunk in <code>array</code> that is processed by each worker.  A smaller size may be required when computation time for processing each item can fluctuate a lot.</li><li><code>threads_basesize::Integer = basesize ÷ nthreads()</code>: A size of chunk in <code>array</code> that is processed by each task in each worker process. The default setting assumes that the number of threads used in all workers are the same.  For heterogeneous setup where each worker process has different number of threads, it may be required to use smaller <code>threads_basesize</code> <em>and</em> <code>basesize</code> to get a good performance.</li><li>For other keyword arguments, see <a href="#Base.foldl"><code>foldl</code></a>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; dreduce(+, 1:3 |&gt; Map(exp) |&gt; Map(log))
6.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/dreduce.jl#LL1-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.dtransduce" href="#Transducers.dtransduce"><code>Transducers.dtransduce</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dtransduce(xform::Transducer, step, init, array; [simd, basesize, threads_basesize, pool])</code></pre><p>See <a href="#Transducers.dreduce"><code>dreduce</code></a> and <a href="#Transducers.transduce"><code>transduce</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/dreduce.jl#LL47-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.eduction" href="#Transducers.eduction"><code>Transducers.eduction</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">eduction(xf::Transducer, coll)
xf(coll)
coll |&gt; xf</code></pre><p>Create a iterable and reducible object.</p><ul><li><a href="https://docs.julialang.org/en/v1/manual/interfaces/#man-interface-iteration-1">Iterable</a>.</li><li>Reducible; i.e., it can be handled by <a href="#Transducers.transduce"><code>transduce</code></a> efficiently.</li></ul><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/eduction"><code>eduction</code> in Clojure</a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Even though <code>eduction</code> returns an iterable, it is highly recommended to use the <code>foldl</code>-based method provided by Transducers.jl when the performance is important.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; for x in 1:1000 |&gt; Filter(isodd) |&gt; Take(3)  # slow
           @show x
       end
x = 1
x = 3
x = 5

julia&gt; foreach(1:1000 |&gt; Filter(isodd) |&gt; Take(3)) do x  # better
           @show x
       end;
x = 1
x = 3
x = 5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/processes.jl#LL526-L562">source</a></section><section><div><pre><code class="language-none">eduction(iterator::Iterators.Generator)
eduction(iterator::Iterators.Filter)
eduction(iterator::Iterators.Flatten)</code></pre><p>Convert an <code>iterator</code> to an eduction.  The iterators that are typically used in the generator comprehensions are supported.</p><div class="admonition is-compat"><header class="admonition-header">Transducers.jl 0.3</header><div class="admonition-body"><p>New in version 0.3.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; iter = (y for x in 1:10 if x % 2 == 0 for y in (x, x + 1));

julia&gt; ed = eduction(iter);

julia&gt; collect(iter) == collect(ed)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/comprehensions.jl#LL7-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.map!" href="#Base.map!"><code>Base.map!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">map!(xf::Transducer, dest, src; simd)</code></pre><p>Feed <code>src</code> to transducer <code>xf</code>, storing the result in <code>dest</code>. Collections <code>dest</code> and <code>src</code> must have the same shape.  Transducer <code>xf</code> may contain filtering transducers.  If some entries <code>src</code> are skipped, the corresponding entries in <code>dest</code> will be unchanged. Transducer <code>xf</code> must not contain any expansive transducers such as <a href="#Transducers.MapCat"><code>MapCat</code></a>.</p><p>See also <a href="#Base.copy!"><code>copy!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; xs = collect(1:5)
       ys = zero(xs)
       map!(Filter(isodd), ys, xs)
5-element Array{Int64,1}:
 1
 0
 3
 0
 5

julia&gt; ans === ys
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/processes.jl#LL769-L798">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copy!" href="#Base.copy!"><code>Base.copy!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">copy!(xf::Transducer, dest, src)</code></pre><p>Feed <code>src</code> to transducer <code>xf</code>, storing the result in <code>dest</code>. Collections <code>dest</code> and <code>src</code> may have the same shape.  Source <code>src</code> must be iterable.  Destination <code>dest</code> must implement <code>empty!</code> and <code>push!</code>.</p><p>See also <a href="#Base.map!"><code>map!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; copy!(opcompose(PartitionBy(x -&gt; x ÷ 3), Map(sum)), Int[], 1:10)
4-element Array{Int64,1}:
  3
 12
 21
 19</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/processes.jl#LL829-L850">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copy" href="#Base.copy"><code>Base.copy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">copy(xf::Transducer, T, foldable) :: Union{T, Empty{T}}
copy(xf::Transducer, foldable::T) :: Union{T, Empty{T}}
copy([T,] eduction::Eduction) :: Union{T, Empty{T}}</code></pre><p>Process <code>foldable</code> with a transducer <code>xf</code> and then create a container of type <code>T</code> filled with the result.  Return <a href="https://juliafolds.github.io/BangBang.jl/dev/#BangBang.NoBang.Empty"><code>BangBang.Empty{T}</code></a> if the transducer does not produce anything.  (This is because there is no consistent interface to create an empty container given its type and not all containers support creating an empty container.)</p><p>For parallel versions, see <a href="#Transducers.tcopy"><code>tcopy</code></a> and <a href="#Transducers.dcopy"><code>dcopy</code></a>.</p><div class="admonition is-compat"><header class="admonition-header">Transducers.jl 0.4.4</header><div class="admonition-body"><p>New in version 0.4.4.</p></div></div><div class="admonition is-compat"><header class="admonition-header">Transducers.jl 0.4.8</header><div class="admonition-body"><p><code>copy</code> now accepts eductions.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers
       using BangBang: Empty

julia&gt; copy(Map(x -&gt; x =&gt; x^2), Dict, 2:2)
Dict{Int64,Int64} with 1 entry:
  2 =&gt; 4

julia&gt; @assert copy(Filter(_ -&gt; false), Set, 1:1) === Empty(Set)

julia&gt; using TypedTables

julia&gt; @assert copy(Map(x -&gt; (a=x, b=x^2)), Table, 1:1) == Table(a=[1], b=[1])

julia&gt; using StructArrays

julia&gt; @assert copy(Map(x -&gt; (a=x, b=x^2)), StructVector, 1:1) == StructVector(a=[1], b=[1])

julia&gt; using DataFrames

julia&gt; @assert copy(
           Map(x -&gt; (A = x.a + 1, B = x.b + 1)),
           DataFrame(a = [1], b = [2]),
       ) == DataFrame(A = [2], B = [3])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/processes.jl#LL707-L755">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.tcopy" href="#Transducers.tcopy"><code>Transducers.tcopy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">tcopy(xf::Transducer, T, reducible; basesize) :: Union{T, Empty{T}}
tcopy(xf::Transducer, reducible::T; basesize) :: Union{T, Empty{T}}
tcopy([T,] itr; basesize) :: Union{T, Empty{T}}</code></pre><p>Thread-based parallel version of <a href="#Base.copy"><code>copy</code></a>. Keyword arguments are passed to <a href="#Base.reduce"><code>reduce</code></a>.</p><p>See also: <a href="../../tutorials/tutorial_parallel/#tutorial-parallel">Parallel processing tutorial</a> (especially <a href="../../tutorials/tutorial_parallel/#tutorial-parallel-collect">Example: parallel <code>collect</code></a>).</p><div class="admonition is-compat"><header class="admonition-header">Transducers.jl 0.4.5</header><div class="admonition-body"><p>New in version 0.4.5.</p></div></div><div class="admonition is-compat"><header class="admonition-header">Transducers.jl 0.4.8</header><div class="admonition-body"><p><code>tcopy</code> now accepts iterator comprehensions and eductions.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; tcopy(Map(x -&gt; x =&gt; x^2), Dict, 2:2)
Dict{Int64,Int64} with 1 entry:
  2 =&gt; 4

julia&gt; using TypedTables

julia&gt; @assert tcopy(Map(x -&gt; (a=x,)), Table, 1:1) == Table(a=[1])

julia&gt; using StructArrays

julia&gt; @assert tcopy(Map(x -&gt; (a=x,)), StructVector, 1:1) == StructVector(a=[1])</code></pre><p><code>tcopy</code> works with iterator comprehensions and eductions (unlike <a href="#Base.copy"><code>copy</code></a>, there is no need for manual conversion with <a href="#Transducers.eduction"><code>eduction</code></a>):</p><pre><code class="language-julia-repl">julia&gt; table = StructVector(a = [1, 2, 3], b = [5, 6, 7]);

julia&gt; @assert tcopy(
           (A = row.a + 1, B = row.b - 1) for row in table if isodd(row.a)
       ) == StructVector(A = [2, 4], B = [4, 6])

julia&gt; @assert tcopy(
           DataFrame,
           (A = row.a + 1, B = row.b - 1) for row in table if isodd(row.a)
       ) == DataFrame(A = [2, 4], B = [4, 6])

julia&gt; @assert table |&gt;
           Filter(row -&gt; isodd(row.a)) |&gt; Map(row -&gt; (A = row.a + 1, B = row.b - 1)) |&gt;
           tcopy == StructVector(A = [2, 4], B = [4, 6])</code></pre><p>If you have <a href="#Transducers.Cat"><code>Cat</code></a> or <a href="#Transducers.MapCat"><code>MapCat</code></a> at the end of the transducer, consider using <a href="#Base.reduce"><code>reduce</code></a> directly:</p><pre><code class="language-julia-repl">julia&gt; using Transducers
       using DataFrames

julia&gt; @assert tcopy(
           DataFrame,
           1:2 |&gt; Map(x -&gt; DataFrame(a = [x])) |&gt; MapCat(eachrow);
           basesize = 1,
       ) == DataFrame(a = [1, 2])

julia&gt; using BangBang: Empty, append!!

julia&gt; @assert reduce(
           append!!,
           Map(x -&gt; DataFrame(a = [x])),
           1:2;
           basesize = 1,
           # init = Empty(DataFrame),
       ) == DataFrame(a = [1, 2])</code></pre><p>Note that above snippet assumes that it is OK to mutate the dataframe returned by the transducer.  Use <code>init = Empty(DataFrame)</code> if this is not the case.</p><p>This approach of using <code>reduce</code> works with other containers; e.g., with <code>TypedTables.Table</code>:</p><pre><code class="language-julia-repl">julia&gt; using TypedTables

julia&gt; @assert reduce(
           append!!,
           Map(x -&gt; Table(a = [x])),
           1:2;
           basesize = 1,
           # init = Empty(Table),
       ) == Table(a = [1, 2])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/reduce.jl#LL336-L435">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.dcopy" href="#Transducers.dcopy"><code>Transducers.dcopy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dcopy(xf::Transducer, T, reducible; [basesize, threads_basesize]) :: Union{T, Empty{T}}
dcopy(xf::Transducer, reducible::T; [basesize, threads_basesize]) :: Union{T, Empty{T}}
dcopy([T,] itr; [basesize, threads_basesize]) :: Union{T, Empty{T}}</code></pre><p>Distributed.jl-based parallel version of <a href="#Base.copy"><code>copy</code></a>.  Keyword arguments are passed to <a href="#Transducers.dreduce"><code>dreduce</code></a>.  For examples, see <a href="#Transducers.tcopy"><code>tcopy</code></a>.</p><p>See also: <a href="../../tutorials/tutorial_parallel/#tutorial-parallel">Parallel processing tutorial</a> (especially <a href="../../tutorials/tutorial_parallel/#tutorial-parallel-collect">Example: parallel <code>collect</code></a>).</p><div class="admonition is-compat"><header class="admonition-header">Transducers.jl 0.4.5</header><div class="admonition-body"><p>New in version 0.4.5.</p></div></div><div class="admonition is-compat"><header class="admonition-header">Transducers.jl 0.4.8</header><div class="admonition-body"><p><code>dcopy</code> now accepts iterator comprehensions and eductions.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/dreduce.jl#LL84-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.append!" href="#Base.append!"><code>Base.append!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">append!(xf::Transducer, dest, src) -&gt; dest</code></pre><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/into"><code>into</code> in Clojure</a>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The performance of <code>append!(dest, src::Eduction)</code> is poor. Use <code>append!!</code> instead if two-argument form is preferred.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; append!(Drop(2), [-1, -2], 1:5)
5-element Array{Int64,1}:
 -1
 -2
  3
  4
  5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/processes.jl#LL603-L624">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BangBang.append!!" href="#BangBang.append!!"><code>BangBang.append!!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">BangBang.append!!(xf::Transducer, dest, src) -&gt; dest′
BangBang.append!!(dest, src::Eduction) -&gt; dest′</code></pre><p>Mutate-or-widen version of <a href="#Base.append!"><code>append!</code></a>.</p><div class="admonition is-compat"><header class="admonition-header">Transducers.jl 0.4.4</header><div class="admonition-body"><p>New in version 0.4.4.</p></div></div><div class="admonition is-compat"><header class="admonition-header">Transducers.jl 0.4.37</header><div class="admonition-body"><p>Performance optimization for <code>append!!(dest, src::Eduction)</code> requires version 0.4.37.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers, BangBang

julia&gt; append!!(opcompose(Drop(2), Map(x -&gt; x + 0.0)), [-1, -2], 1:5)
5-element Array{Float64,1}:
 -1.0
 -2.0
  3.0
  4.0
  5.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/processes.jl#LL628-L655">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.collect" href="#Base.collect"><code>Base.collect</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">collect(xf::Transducer, itr) :: Vector
collect(ed::Eduction) :: Vector</code></pre><p>Process an iterable <code>itr</code> using a transducer <code>xf</code> and collect the result into a <code>Vector</code>.</p><p>For parallel versions, see <a href="#Transducers.tcollect"><code>tcollect</code></a> and <a href="#Transducers.dcollect"><code>dcollect</code></a>.</p><div class="admonition is-compat"><header class="admonition-header">Transducers.jl 0.4.8</header><div class="admonition-body"><p><code>collect</code> now accepts eductions.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(Interpose(missing), 1:3)
5-element Array{Union{Missing, Int64},1}:
 1
  missing
 2
  missing
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/processes.jl#LL669-L694">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.tcollect" href="#Transducers.tcollect"><code>Transducers.tcollect</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">tcollect(xf::Transducer, reducible; basesize) :: Union{Vector, Empty{Vector}}
tcollect(itr; basesize) :: Union{Vector, Empty{Vector}}</code></pre><p>Thread-based parallel version of <a href="#Base.collect"><code>collect</code></a>. This is just a short-hand notation of <code>tcopy(xf, Vector, reducible)</code>. Use <a href="#Transducers.tcopy"><code>tcopy</code></a> to get a container other than a <code>Vector</code>.</p><p>See also: <a href="../../tutorials/tutorial_parallel/#tutorial-parallel">Parallel processing tutorial</a> (especially <a href="../../tutorials/tutorial_parallel/#tutorial-parallel-collect">Example: parallel <code>collect</code></a>).</p><div class="admonition is-compat"><header class="admonition-header">Transducers.jl 0.4.5</header><div class="admonition-body"><p>New in version 0.4.5.</p></div></div><div class="admonition is-compat"><header class="admonition-header">Transducers.jl 0.4.8</header><div class="admonition-body"><p><code>tcollect</code> now accepts iterator comprehensions and eductions.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; tcollect(Map(x -&gt; x^2), 1:2)
2-element Array{Int64,1}:
 1
 4

julia&gt; tcollect(x^2 for x in 1:2)
2-element Array{Int64,1}:
 1
 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/reduce.jl#LL471-L504">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.dcollect" href="#Transducers.dcollect"><code>Transducers.dcollect</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dcollect(xf::Transducer, reducible; [basesize, threads_basesize]) :: Union{Vector, Empty{Vector}}
dcollect(itr; [basesize, threads_basesize]) :: Union{Vector, Empty{Vector}}</code></pre><p>Distributed.jl-based parallel version of <a href="#Base.collect"><code>collect</code></a>. This is just a short-hand notation of <code>dcopy(xf, Vector, reducible)</code>. Use <a href="#Transducers.dcopy"><code>dcopy</code></a> to get a container other than a <code>Vector</code>.</p><p>See also: <a href="../../tutorials/tutorial_parallel/#tutorial-parallel">Parallel processing tutorial</a> (especially <a href="../../tutorials/tutorial_parallel/#tutorial-parallel-collect">Example: parallel <code>collect</code></a>).</p><div class="admonition is-compat"><header class="admonition-header">Transducers.jl 0.4.5</header><div class="admonition-body"><p>New in version 0.4.5.</p></div></div><div class="admonition is-compat"><header class="admonition-header">Transducers.jl 0.4.8</header><div class="admonition-body"><p><code>dcollect</code> now accepts iterator comprehensions and eductions.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/dreduce.jl#LL118-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Channel" href="#Base.Channel"><code>Base.Channel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Channel(xf::Transducer, itr; kwargs...)
Channel(ed::Eduction; kwargs...)</code></pre><p>Pipe items from an iterable <code>itr</code> processed by the transducer <code>xf</code> through a channel.  <code>Channel(xf, itr)</code> and <code>Channel(eduction(xf, itr))</code> are equivalent.  Note that <code>itr</code> itself can be a <code>Channel</code>.</p><p>Keyword arguments are passed to <code>Channel(function; kwargs...)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; ch1 = Channel(Filter(isodd), 1:5);

julia&gt; ch2 = Channel(Map(x -&gt; 2x - 1), ch1);

julia&gt; ed = eduction(Map(x -&gt; 1:x), ch2);

julia&gt; ch3 = Channel(Cat(), ed);

julia&gt; foreach(PartitionBy(isequal(1)), ch3) do input
           @show input
       end;
input = [1, 1]
input = [2, 3, 4, 5]
input = [1]
input = [2, 3, 4, 5, 6, 7, 8, 9]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/processes.jl#LL1052-L1082">source</a></section></article><h3 id="Experimental-transducible-processes"><a class="docs-heading-anchor" href="#Experimental-transducible-processes">Experimental transducible processes</a><a id="Experimental-transducible-processes-1"></a><a class="docs-heading-anchor-permalink" href="#Experimental-transducible-processes" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Transducers.channel_unordered" href="#Transducers.channel_unordered"><code>Transducers.channel_unordered</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">channel_unordered(xf, input; eltype, size, ntasks, basesize) :: Channel{eltype}
channel_unordered(itr; eltype, size, ntasks, basesize) :: Channel{eltype}</code></pre><p>Provide elements in <code>input</code> processed by a transducer <code>xf</code> through a <code>Channel</code>.</p><p>Unary method <code>channel_unordered(itr)</code> produces a <code>Channel</code> that provides elements in the input iterator <code>itr</code> with possibly different order.  Iterator comprehensions and <a href="#Transducers.eduction"><code>eduction</code></a>s can be passed as the input <code>itr</code>.</p><p>Use <a href="#Transducers.append_unordered!"><code>append_unordered!</code></a> to send outputs to an existing channel.</p><div class="admonition is-compat"><header class="admonition-header">Transducers.jl 0.4.8</header><div class="admonition-body"><p>New in version 0.4.8.</p></div></div><div class="admonition is-compat"><header class="admonition-header">Transducers.jl 0.4.9</header><div class="admonition-body"><p>Unary method <code>channel_unordered(itr)</code> requires Transducers.jl 0.4.9.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This API is experimental.  Backward incompatible change, including the removal of this API, is more likely to occur than other parts of this package.</p></div></div><p><strong>Keyword Arguments</strong></p><ul><li><code>eltype::Type</code>: element type of returned channel</li><li><code>size</code>: The size of <code>Channel</code>. A non-negative <code>Int</code> or <code>Inf</code>.</li><li><code>ntasks::Int</code>: Number of concurrent tasks.  Default to <code>Threads.nthreads()</code>.</li><li><code>basesize</code>: The &quot;batch size&quot; of the processing; i.e., the number of elements to be processed in a single task.  Default to 1.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers: Map, channel_unordered

julia&gt; sort!(collect(channel_unordered(Map(x -&gt; x + 1), 1:3)))
3-element Array{Any,1}:
 2
 3
 4

julia&gt; sort!(collect(channel_unordered(x + 1 for x in 1:3 if isodd(x))))
2-element Array{Any,1}:
 2
 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/unordered.jl#LL221-L268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.append_unordered!" href="#Transducers.append_unordered!"><code>Transducers.append_unordered!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">append_unordered!(output, xf, input; ntasks, basesize)
append_unordered!(output, itr; ntasks, basesize)</code></pre><p>Process <code>input</code> elements through a transducer <code>xf</code> and then <code>push!</code> them into <code>output</code> in undefined order.</p><p>Binary method <code>append_unordered!(output, itr)</code> is like <code>append!(output, itr)</code> but without order guarantee.  Iterator comprehensions and <a href="#Transducers.eduction"><code>eduction</code></a>s can be passed as the input <code>itr</code>.</p><p><code>output</code> (typically a <code>Channel</code>) must implement thread-safe <code>push!(output, x)</code> method.</p><p>See also <a href="#Transducers.channel_unordered"><code>channel_unordered</code></a>.</p><div class="admonition is-compat"><header class="admonition-header">Transducers.jl 0.4.8</header><div class="admonition-body"><p>New in version 0.4.8.</p></div></div><div class="admonition is-compat"><header class="admonition-header">Transducers.jl 0.4.9</header><div class="admonition-body"><p>Binary method <code>append_unordered!(output, itr)</code> requires Transducers.jl 0.4.9.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This API is experimental.  Backward incompatible change, including the removal of this API, is more likely to occur than other parts of this package.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers: Map, append_unordered!

julia&gt; input = Channel(Map(identity), 1:3);

julia&gt; output = Channel{Int}(0);

julia&gt; task = @async try
           append_unordered!(output, Map(x -&gt; x + 1), input)
       finally
           close(output)
       end;

julia&gt; sort!(collect(output))
3-element Array{Int64,1}:
 2
 3
 4

julia&gt; input = Channel(Map(identity), 1:3);

julia&gt; output = Channel{Int}(0);

julia&gt; task = @async try
           append_unordered!(output, (y for x in input if isodd(x) for y in 1:x))
       finally
           close(output)
       end;

julia&gt; sort!(collect(output))
4-element Array{Int64,1}:
 1
 1
 2
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/unordered.jl#LL122-L186">source</a></section></article><h2 id="Transducers"><a class="docs-heading-anchor" href="#Transducers">Transducers</a><a id="Transducers-1"></a><a class="docs-heading-anchor-permalink" href="#Transducers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Transducers.Transducer" href="#Transducers.Transducer"><code>Transducers.Transducer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Transducer</code></pre><p>The abstract type for transducers.</p><p>A transducer <code>xf</code> can be used as both iterator transformation <code>xf(itr)</code> and reducing function transformation <code>xf&#39;(rf)</code>.</p><p>See also <a href="#Base.adjoint"><code>adjoint</code></a> for <code>xf&#39;(rf)</code>.</p><div class="admonition is-compat"><header class="admonition-header">Transducers.jl 0.4.39</header><div class="admonition-body"><p>The call overload <code>xf(rf)</code> requires Transducers.jl 0.4.39 or later.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The call overload <code>xf(rf)</code> requires Julia 1.3 or later. For older Julia versions, use <a href="#Transducers.eduction"><code>eduction</code></a>.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; xs = Map(inv)(2:2:4)
2-element StepRange{Int64,Int64} |&gt;
    Map(inv)

julia&gt; collect(xs)
2-element Array{Float64,1}:
 0.5
 0.25

julia&gt; rf = Map(inv)&#39;(+)
Reduction(
    Map(inv),
    BottomRF(
        +))

julia&gt; rf(1, 4)  # +(1, inv(4))
1.25</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/core.jl#LL203-L242">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:∘" href="#Base.:∘"><code>Base.:∘</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">f ⨟ g
g ∘ f
opcompose(f, g)
compose(g, f)</code></pre><p>Composition of transducers.</p><div class="admonition is-compat"><header class="admonition-header">Transducers.jl 0.4.39</header><div class="admonition-body"><p>Transducers.jl 0.4.39 or later is required for composing transducers with <code>∘</code> and other operators and functions derived from it.</p><p>Transducers written as <code>f |&gt; g |&gt; h</code> in previous versions of Transducers.jl can now be written as <code>f ⨟ g ⨟ h</code> (in Julia 1.5 or later) or <code>opcompose(f, g, h)</code>.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>&quot;op&quot; in <code>opcompose</code> does not stand for <em>operator</em>; it stands for <em>opposite</em>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/core.jl#LL359-L381">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.adjoint" href="#Base.adjoint"><code>Base.adjoint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">xf&#39;</code></pre><p><code>xf&#39;(rf₁)</code> is a shortcut for calling <code>reducingfunction(xf, rf₁)</code>.</p><p>More precisely, adjoint <code>xf′</code> of a transducer <code>xf</code> is a <em>reducing function transform</em> <code>rf₁ -&gt; rf₂</code>.  That is to say, <code>xf&#39;</code> a function that maps a reducing function <code>rf₁</code> to another reducing function <code>rf₂</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; y = Map(inv)&#39;(+)(10, 2)
10.5

julia&gt; y == +(10, inv(2))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/core.jl#LL404-L424">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.Broadcasting" href="#Transducers.Broadcasting"><code>Transducers.Broadcasting</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Broadcasting()</code></pre><p>Broadcast inner reducing function over elements in the input.  Roughly speaking, it transforms the inner reducing function <code>op</code> to <code>op′(a, b) = op.(a, b)</code>.  However, it has a better memory usage and better initial value handling.</p><p>If the input is an array, the array created at the first iteration is reused if it can hold the element types of subsequent iterations. Otherwise, the array type is widen as needed.</p><p>If <code>init</code> passed to the fold function is a lazy &quot;initializer&quot; object such as <a href="#Transducers.OnInit"><code>OnInit</code></a>, it is initialized independently for each item in the first input array.  This makes using <code>Broadcasting</code> for (possibly) in-place functions safe.</p><div class="admonition is-compat"><header class="admonition-header">Transducers.jl 0.4.32</header><div class="admonition-body"><p>New in version 0.4.32.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>Broadcasting</code> transducer is not supported in Julia 1.0.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; foldl(+, Broadcasting(), [[1, 2], [3, 4], 5])
2-element Array{Int64,1}:
  9
 11

julia&gt; foldl(+, Broadcasting(), [(0,), [1], [2.0], [3 + 0im]])
1-element Array{Complex{Float64},1}:
 6.0 + 0.0im

julia&gt; foldl(
           *,
           [[[1], [10, 100]], [[2], [20, 200]], [[3], [30, 300]]] |&gt;
               Broadcasting() |&gt; Broadcasting(),
       )
2-element Array{Array{Int64,1},1}:
 [6]
 [6000, 6000000]</code></pre><p>When processing nested data structure (e.g., array-of-arrays) and mutating accumulator in-place, be careful with sharing the accumulators with each processing of items in the input.  For example, this is a bad example:</p><pre><code class="language-julia-repl">julia&gt; add!(a, b) = a .+= b;

julia&gt; foldl(add!, Broadcasting(), [[[1], [2, 3]], [[4, 5], 6]];
             init = Ref([0, 0]))
2-element Array{Array{Int64,1},1}:
 [13, 15]
 [13, 15]

julia&gt; ans[1] === ans[2]  # they are the same object
true</code></pre><p>Use <code>OnInit</code> to initialize a new array with each item in the input:</p><pre><code class="language-julia-repl">julia&gt; foldl(add!, Broadcasting(), [[[1], [2, 3]], [[4, 5], 6]];
             init = OnInit(() -&gt; [0, 0]))
2-element Array{Array{Int64,1},1}:
 [5, 6]
 [8, 9]

julia&gt; ans == [
           add!(add!([0, 0], [1]), [4, 5]),
           add!(add!([0, 0], [2, 3]), 6),
       ]
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/broadcasting.jl#LL1-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.Cat" href="#Transducers.Cat"><code>Transducers.Cat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Cat()</code></pre><p>Concatenate/flatten nested iterators.</p><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/cat"><code>cat</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(Cat(), [[1, 2], [3], [4, 5]]) == 1:5
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/library.jl#LL130-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.Count" href="#Transducers.Count"><code>Transducers.Count</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Count([start[, step]])</code></pre><p>Generate a sequence <code>start</code>, <code>start + step</code>, <code>start + step + step</code>, and so on.</p><p>Note that input is ignored.  To use the input in the downstream reduction steps, use <a href="#Transducers.Zip-Tuple"><code>Zip</code></a>.</p><p><code>start</code> defaults to 1 and <code>step</code> defaults to <code>oneunit(start)</code>.</p><p>See also: <a href="https://docs.julialang.org/en/v1/base/iterators/"><code>Iterators.countfrom</code></a>. <a href="#Transducers.Enumerate"><code>Enumerate</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(Zip(Map(identity), Count()), -3:-1)
3-element Array{Tuple{Int64,Int64},1}:
 (-3, 1)
 (-2, 2)
 (-1, 3)

julia&gt; using Dates

julia&gt; 1:3 |&gt; Zip(Map(identity), Count(Day(1))) |&gt; MapSplat(*) |&gt; collect ==
       [Day(1), Day(4), Day(9)]
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/library.jl#LL1406-L1436">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.Dedupe" href="#Transducers.Dedupe"><code>Transducers.Dedupe</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Dedupe()</code></pre><p>De-duplicate <em>consecutive</em> items.</p><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/dedupe"><code>dedupe</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(Dedupe(), [1, 1, 2, 1, 3, 3, 2])
5-element Array{Int64,1}:
 1
 2
 1
 3
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/library.jl#LL1072-L1091">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.Drop" href="#Transducers.Drop"><code>Transducers.Drop</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Drop(n)</code></pre><p>Drop first <code>n</code> items.</p><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/drop"><code>drop</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; 1:5 |&gt; Drop(3) |&gt; collect
2-element Array{Int64,1}:
 4
 5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/library.jl#LL576-L592">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.DropLast" href="#Transducers.DropLast"><code>Transducers.DropLast</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DropLast(n)</code></pre><p>Drop last <code>n</code> items.</p><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/drop-last"><code>drop-last</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; 1:5 |&gt; DropLast(2) |&gt; collect
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; 1:1 |&gt; DropLast(2) |&gt; collect == []
true

julia&gt; 1:0 |&gt; DropLast(2) |&gt; collect == []
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/library.jl#LL617-L640">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.DropWhile" href="#Transducers.DropWhile"><code>Transducers.DropWhile</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DropWhile(pred)</code></pre><p>Drop items while <code>pred</code> returns <code>true</code> consecutively.  It becomes a no-op after <code>pred</code> returns a <code>false</code>.</p><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/drop-while"><code>drop-while</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(DropWhile(x -&gt; x &lt; 3), [1:5; 1:2])
5-element Array{Int64,1}:
 3
 4
 5
 1
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/library.jl#LL680-L700">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.Enumerate" href="#Transducers.Enumerate"><code>Transducers.Enumerate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Enumerate([start[, step]])</code></pre><p>Transducer variant of <code>Base.enumerate</code>. The <code>start</code> and <code>step</code> arguments are optional and have the same meaning as in <a href="#Transducers.Count"><code>Count</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(Enumerate(), [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;])
3-element Array{Tuple{Int64,String},1}:
 (1, &quot;A&quot;)
 (2, &quot;B&quot;)
 (3, &quot;C&quot;)

julia&gt; start=2; step=3;

julia&gt; collect(Enumerate(start, step), [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;])
3-element Array{Tuple{Int64,String},1}:
 (2, &quot;A&quot;)
 (5, &quot;B&quot;)
 (8, &quot;C&quot;)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/library.jl#LL1599-L1624">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.Filter" href="#Transducers.Filter"><code>Transducers.Filter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Filter(pred)</code></pre><p>Skip items for which <code>pred</code> is evaluated to <code>false</code>.</p><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/filter"><code>filter</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; 1:3 |&gt; Filter(iseven) |&gt; collect
1-element Array{Int64,1}:
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/library.jl#LL259-L274">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.FlagFirst" href="#Transducers.FlagFirst"><code>Transducers.FlagFirst</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FlagFirst()</code></pre><p>Output <code>(isfirst, input)</code> where <code>isfirst::Bool</code> is <code>true</code> only for the first iteration and <code>input</code> is the original input.</p><p>See also: <a href="https://juliacollections.github.io/IterTools.jl/latest/#flagfirst(xs)-1"><code>IterTools.flagfirst</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(FlagFirst(), 1:3)
3-element Array{Tuple{Bool,Int64},1}:
 (1, 1)
 (0, 2)
 (0, 3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/library.jl#LL717-L737">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.GroupBy" href="#Transducers.GroupBy"><code>Transducers.GroupBy</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GroupBy(key, rf, [init])
GroupBy(key, xf::Transducer, [step = right, [init]])</code></pre><p>Group the input stream by a function <code>key</code> and then fan-out each group of key-value pairs to the reducing function <code>rf</code>.</p><p>For example, if <code>GroupBy</code> is used as in:</p><pre><code class="language-none">xs |&gt; Map(upstream) |&gt; GroupBy(key, rf, init) |&gt; Map(downstream)</code></pre><p>then the &quot;function signatures&quot; would be:</p><pre><code class="language-none">upstream(_) :: V
key(::V) :: K
rf(::Y, ::Pair{K, V}) ::Y
downstream(::Dict{K, Y})</code></pre><p>That is to say,</p><ul><li><p>Ouput of the <code>upstream</code> is fed into the function <code>key</code> that produces the group key (of type <code>K</code>).</p></li><li><p>For each new group key, a new transducible process is started with the initial state <code>init :: Y</code>.  Pass <a href="#Transducers.OnInit"><code>OnInit</code></a> or <a href="#Transducers.CopyInit"><code>CopyInit</code></a> object to <code>init</code> for creating a dedicated (possibly mutable) state for each group.</p></li><li><p>After one &quot;nested&quot; reducing function <code>rf</code> is called, the intermediate result dictionary (of type <code>Dict{K, Y}</code>) accumulating the current and all preceding results is then fed into the <code>downstream</code>.</p></li></ul><p>See also <code>groupreduce</code> in <a href="https://github.com/JuliaData/SplitApplyCombine.jl">SplitApplyCombine.jl</a>.</p><div class="admonition is-compat"><header class="admonition-header">Transducers.jl 0.3</header><div class="admonition-body"><p>New in version 0.3.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers
       using BangBang  # for `push!!`

julia&gt; foldl(right, GroupBy(string, Map(last), push!!), [1, 2, 1, 2, 3])
Transducers.GroupByViewDict{String,Array{Int64,1},…} with 3 entries:
  &quot;1&quot; =&gt; [1, 1]
  &quot;2&quot; =&gt; [2, 2]
  &quot;3&quot; =&gt; [3]</code></pre><p>Note that the reduction stops if one of the group returns a <a href="#Transducers.reduced"><code>reduced</code></a>.  This can be used, for example, to find if there is a group with a sum grater than 3 and stop the computation as soon as it is find:</p><pre><code class="language-julia-repl">julia&gt; result = transduce(
           GroupBy(
               string,
               opcompose(Map(last), Scan(+), ReduceIf(x -&gt; x &gt; 3)),
           ),
           right,
           nothing,
           [1, 2, 1, 2, 3],
       );

julia&gt; result isa Reduced
true

julia&gt; unreduced(result)
Transducers.GroupByViewDict{String,Any,…} with 2 entries:
  &quot;1&quot; =&gt; 2
  &quot;2&quot; =&gt; 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/groupby.jl#LL1-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.Interpose" href="#Transducers.Interpose"><code>Transducers.Interpose</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Interpose(sep)</code></pre><p>Interleave input items with a <code>sep</code>.</p><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/interpose"><code>interpose</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(Interpose(missing), 1:3)
5-element Array{Union{Missing, Int64},1}:
 1
  missing
 2
  missing
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/library.jl#LL1035-L1054">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.Iterated" href="#Transducers.Iterated"><code>Transducers.Iterated</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Iterated(f, init)</code></pre><p>Generate a sequence <code>init</code>, <code>f(init)</code>, <code>f(f(init))</code>, <code>f(f(f(init)))</code>, and so on.</p><p>Note that input is ignored.  To use the input in the downstream reduction steps, use <a href="#Transducers.Zip-Tuple"><code>Zip</code></a>.</p><p>Pass <a href="#Transducers.OnInit"><code>OnInit</code></a> or <a href="#Transducers.CopyInit"><code>CopyInit</code></a> object to <code>init</code> for creating a dedicated (possibly mutable) state for each fold.</p><p>See also: <a href="#Transducers.Scan"><code>Scan</code></a>, <a href="#Transducers.ScanEmit"><code>ScanEmit</code></a>.</p><p>The idea is taken from <a href="https://juliacollections.github.io/IterTools.jl/latest/#IterTools.iterated"><code>IterTools.iterated</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(Iterated(x -&gt; 2x, 1), 1:5)
5-element Array{Int64,1}:
  1
  2
  4
  8
 16

julia&gt; collect(Zip(Map(identity), Iterated(x -&gt; 2x, 1)), 1:5)
5-element Array{Tuple{Int64,Int64},1}:
 (1, 1)
 (2, 2)
 (3, 4)
 (4, 8)
 (5, 16)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/library.jl#LL1356-L1391">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.Keep" href="#Transducers.Keep"><code>Transducers.Keep</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Keep(f)</code></pre><p>Pass non-<code>nothing</code> output of <code>f</code> to the inner reducing step.</p><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/keep"><code>keep</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; xf = Keep() do x
           if x &lt; 3
               x + 1
           end
       end;

julia&gt; collect(xf, 1:5)
2-element Array{Int64,1}:
 2
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/library.jl#LL941-L963">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.Map" href="#Transducers.Map"><code>Transducers.Map</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Map(f)</code></pre><p>Apply unary function <code>f</code> to each input and pass the result to the inner reducing step.</p><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/map"><code>map</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(Map(x -&gt; 2x), 1:3)
3-element Array{Int64,1}:
 2
 4
 6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/library.jl#LL27-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.MapCat" href="#Transducers.MapCat"><code>Transducers.MapCat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MapCat(f)</code></pre><p>Concatenate output of <code>f</code> which is expected to return an iterable.</p><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/mapcat"><code>mapcat</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(MapCat(x -&gt; 1:x), 1:3)
6-element Array{Int64,1}:
 1
 1
 2
 1
 2
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/library.jl#LL152-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.MapSplat" href="#Transducers.MapSplat"><code>Transducers.MapSplat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MapSplat(f)</code></pre><p>Like <code>Map(f)</code> but calls <code>f(input...)</code> for each <code>input</code> and then pass the result to the inner reducing step.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(MapSplat(*), zip(1:3, 10:10:30))
3-element Array{Int64,1}:
 10
 40
 90</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/library.jl#LL55-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.NotA" href="#Transducers.NotA"><code>Transducers.NotA</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NotA(T)</code></pre><p>Skip items of type <code>T</code>.  Unlike <code>Filter(!ismissing)</code>, downstream transducers can have a correct type information for <code>NotA(Missing)</code>.</p><p>See also: <a href="#Transducers.OfType"><code>OfType</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; [1, missing, 2] |&gt; NotA(Missing) |&gt; collect
2-element Array{Int64,1}:
 1
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/library.jl#LL282-L299">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.OfType" href="#Transducers.OfType"><code>Transducers.OfType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OfType(T)</code></pre><p>Include only items of type <code>T</code>.</p><p>See also: <a href="#Transducers.NotA"><code>NotA</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; [1, missing, 2] |&gt; OfType(Int) |&gt; collect
2-element Array{Int64,1}:
 1
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/library.jl#LL312-L328">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.Partition" href="#Transducers.Partition"><code>Transducers.Partition</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Partition(size, step = size, flush = false)
Partition(size; step = size, flush = false)</code></pre><p>Sliding window of width <code>size</code> and interval <code>step</code>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The vector passed to the inner reducing function is valid only during its <em>immediate</em> reduction step.  It must be reduced immediately <em>or</em> copied.</p></div></div><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/partition-all"><code>partition-all</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; 1:8 |&gt; Partition(3) |&gt; Map(copy) |&gt; collect
2-element Array{Array{Int64,1},1}:
 [1, 2, 3]
 [4, 5, 6]

julia&gt; 1:8 |&gt; Partition(3; flush=true) |&gt; Map(copy) |&gt; collect
3-element Array{Array{Int64,1},1}:
 [1, 2, 3]
 [4, 5, 6]
 [7, 8]

julia&gt; 1:8 |&gt; Partition(3; step=1) |&gt; Map(copy) |&gt; collect
6-element Array{Array{Int64,1},1}:
 [1, 2, 3]
 [2, 3, 4]
 [3, 4, 5]
 [4, 5, 6]
 [5, 6, 7]
 [6, 7, 8]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/library.jl#LL753-L787">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.PartitionBy" href="#Transducers.PartitionBy"><code>Transducers.PartitionBy</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PartitionBy(f)</code></pre><p>Group input sequence into chunks in which <code>f</code> returns a same value consecutively.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The vector passed to the inner reducing function is valid only during its <em>immediate</em> reduction step.  It must be reduced immediately <em>or</em> copied.</p></div></div><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/partition-by"><code>partition-by</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; 1:9 |&gt; PartitionBy(x -&gt; (x + 1) ÷ 3) |&gt; Map(copy) |&gt; collect
4-element Array{Array{Int64,1},1}:
 [1]
 [2, 3, 4]
 [5, 6, 7]
 [8, 9]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/library.jl#LL880-L901">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.ReduceIf" href="#Transducers.ReduceIf"><code>Transducers.ReduceIf</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ReduceIf(pred)</code></pre><p>Stop fold when <code>pred(x)</code> returns <code>true</code> for the output <code>x</code> of the upstream transducer.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; foldl(right, ReduceIf(x -&gt; x == 3), 1:10)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/library.jl#LL1642-L1655">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.Replace" href="#Transducers.Replace"><code>Transducers.Replace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Replace(assoc)</code></pre><p>Replace each input with the value in the associative container <code>assoc</code> (e.g., a dictionary, array, string) if it matches with a key/index. Otherwise output the input as-is.</p><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/replace"><code>replace</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(Replace(Dict(&#39;a&#39; =&gt; &#39;A&#39;)), &quot;abc&quot;)
3-element Array{Char,1}:
 &#39;A&#39;
 &#39;b&#39;
 &#39;c&#39;

julia&gt; collect(Replace([:a, :b, :c]), 0:4)
5-element Array{Any,1}:
 0
  :a
  :b
  :c
 4

julia&gt; collect(Replace(&quot;abc&quot;), 0:4)
5-element Array{Any,1}:
 0
  &#39;a&#39;
  &#39;b&#39;
  &#39;c&#39;
 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/library.jl#LL84-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.Scan" href="#Transducers.Scan"><code>Transducers.Scan</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Scan(f, [init = Init])</code></pre><p>Accumulate input with binary function <code>f</code> and pass the accumulated result so far to the inner reduction step.</p><p>The inner reducing step receives the sequence <code>y₁, y₂, y₃, ..., yₙ, ...</code> when the sequence <code>x₁, x₂, x₃, ..., xₙ, ...</code> is fed to <code>Scan(f)</code>.</p><pre><code class="language-none">y₁ = f(init, x₁)
y₂ = f(y₁, x₂)
y₃ = f(y₂, x₃)
...
yₙ = f(yₙ₋₁, xₙ)</code></pre><p>This is a generalized version of the <a href="https://en.wikipedia.org/wiki/Prefix_sum"><em>prefix sum</em></a> also known as <em>cumulative sum</em>, <em>inclusive scan</em>, or <em>scan</em>.</p><p>Note that the associativity of <code>f</code> is not required when the transducer is used in a process that gurantee an order, such as <a href="#Base.foldl"><code>foldl</code></a>.</p><p>Unless <code>f</code> is a function with known identity element such as <code>+</code>, <code>*</code>, <code>min</code>, <code>max</code>, and <code>append!</code>, the initial state <code>init</code> must be provided.</p><p>Pass <a href="#Transducers.OnInit"><code>OnInit</code></a> or <a href="#Transducers.CopyInit"><code>CopyInit</code></a> object to <code>init</code> for creating a dedicated (possibly mutable) state for each fold.</p><p>See also: <a href="#Transducers.ScanEmit"><code>ScanEmit</code></a>, <a href="#Transducers.Iterated"><code>Iterated</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(Scan(*), 1:3)
3-element Array{Int64,1}:
 1
 2
 6

julia&gt; 1:3 |&gt; Map(x -&gt; x + im) |&gt; Scan(*) |&gt; collect
3-element Array{Complex{Int64},1}:
 1 + 1im
 1 + 3im
 0 + 10im

julia&gt; collect(Scan(*, 10), 1:3)
3-element Array{Int64,1}:
 10
 20
 60</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/library.jl#LL1107-L1159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.ScanEmit" href="#Transducers.ScanEmit"><code>Transducers.ScanEmit</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ScanEmit(f, init[, onlast])</code></pre><p>Accumulate input <code>x</code> with a function <code>f</code> with the call signature <code>(u, x) -&gt; (y, u)</code> and pass the result <code>y</code> to the inner reduction step.</p><p>The inner reducing step receives the sequence <code>y₁, y₂, y₃, ..., yₙ, ...</code> computed as follows</p><pre><code class="language-none">u₀ = init
y₁, u₁ = f(u₀, x₁)
y₂, u₂ = f(u₁, x₂)
y₃, u₃ = f(u₂, x₃)
...
yₙ, uₙ = f(uₙ₋₁, xₙ)
...
yₒₒ = onlast(uₒₒ)</code></pre><p>when the sequence <code>x₁, x₂, x₃, ..., xₙ, ...</code> is fed to <code>ScanEmit(f)</code>.</p><p>Pass <a href="#Transducers.OnInit"><code>OnInit</code></a> or <a href="#Transducers.CopyInit"><code>CopyInit</code></a> object to <code>init</code> for creating a dedicated (possibly mutable) state for each fold.</p><p>See also: <a href="#Transducers.Scan"><code>Scan</code></a>, <a href="#Transducers.Iterated"><code>Iterated</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(ScanEmit(tuple, 0), 1:3)
3-element Array{Int64,1}:
 0
 1
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/library.jl#LL1187-L1221">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.TCat" href="#Transducers.TCat"><code>Transducers.TCat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TCat(basesize::Integer)</code></pre><p>Threaded version of <a href="#Transducers.Cat"><code>Cat</code></a> (concatenate/flatten).</p><p>To use this transducer, all the downstream (inner) transducers must be stateless (or of type <a href="#Transducers.ScanEmit"><code>ScanEmit</code></a>) and the reducing function must be associative.  See also: <a href="../../tutorials/tutorial_parallel/#tutorial-parallel">Parallel processing tutorial</a>.</p><p>Note that the upstream (outer) transducers need not to be stateless as long as it is called with non-parallel reduction such as <a href="#Base.foldl"><code>foldl</code></a> and <a href="#Base.collect"><code>collect</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; 1:3 |&gt; Map(x -&gt; 1:x) |&gt; TCat(1) |&gt; tcollect
6-element Array{Int64,1}:
 1
 1
 2
 1
 2
 3

julia&gt; 1:3 |&gt; Scan(+) |&gt; Map(x -&gt; 1:x) |&gt; TCat(1) |&gt; collect
10-element Array{Int64,1}:
 1
 1
 2
 3
 1
 2
 3
 4
 5
 6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/library.jl#LL177-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.Take" href="#Transducers.Take"><code>Transducers.Take</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Take(n)</code></pre><p>Take <code>n</code> items from the input sequence.</p><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/take"><code>take</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; 1:10 |&gt; Take(2) |&gt; collect
2-element Array{Int64,1}:
 1
 2

julia&gt; 1:2 |&gt; Take(5) |&gt; collect
2-element Array{Int64,1}:
 1
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/library.jl#LL389-L410">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.TakeLast" href="#Transducers.TakeLast"><code>Transducers.TakeLast</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TakeLast(n)</code></pre><p>Take last <code>n</code> items from the input sequence.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; 1:10 |&gt; TakeLast(2) |&gt; collect
2-element Array{Int64,1}:
  9
 10

julia&gt; 1:2 |&gt; TakeLast(5) |&gt; collect
2-element Array{Int64,1}:
 1
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/library.jl#LL435-L454">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.TakeNth" href="#Transducers.TakeNth"><code>Transducers.TakeNth</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TakeNth(n)</code></pre><p>Output every <code>n</code> item to the inner reducing step.</p><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/take-nth"><code>take-nth</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; 1:9 |&gt; TakeNth(3) |&gt; collect
3-element Array{Int64,1}:
 1
 4
 7</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/library.jl#LL533-L550">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.TakeWhile" href="#Transducers.TakeWhile"><code>Transducers.TakeWhile</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TakeWhile(pred)</code></pre><p>Take items while <code>pred</code> returns <code>true</code>.  Abort the reduction when <code>pred</code> returns <code>false</code> for the first time.</p><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/take-while"><code>take-while</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; [1, 2, 3, 1, 2] |&gt; TakeWhile(x -&gt; x &lt; 3) |&gt; collect
2-element Array{Int64,1}:
 1
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/library.jl#LL502-L519">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.Unique" href="#Transducers.Unique"><code>Transducers.Unique</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Unique(by = identity)</code></pre><p>Pass only unseen item to the inner reducing step.</p><p>The item is distinguished by the output of function <code>by</code> when given.</p><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/distinct"><code>distinct</code> in Clojure</a>.</p><div class="admonition is-compat"><header class="admonition-header">Transducers.jl 0.4.2</header><div class="admonition-body"><p>New in version 0.4.2.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; [1, 1, 2, -1, 3, 3, 2] |&gt; Unique() |&gt; collect
4-element Array{Int64,1}:
  1
  2
 -1
  3

julia&gt; [1, 1, 2, -1, 3, 3, 2] |&gt; Unique(x -&gt; x^2) |&gt; collect
3-element Array{Int64,1}:
 1
 2
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/library.jl#LL977-L1007">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.Zip-Tuple" href="#Transducers.Zip-Tuple"><code>Transducers.Zip</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Zip(xforms...)</code></pre><p>Zip outputs of transducers <code>xforms</code> in a tuple and pass it to the inner reduction step.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Head transducers drive tail transducers.  Be careful when using it with transducers other than <a href="#Transducers.Map"><code>Map</code></a>, especially the contractive ones like <a href="#Transducers.PartitionBy"><code>PartitionBy</code></a> and the expansive ones like <a href="#Transducers.MapCat"><code>MapCat</code></a>.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(Zip(Map(identity), Map(x -&gt; 10x), Map(x -&gt; 100x)), 1:3)
3-element Array{Tuple{Int64,Int64,Int64},1}:
 (1, 10, 100)
 (2, 20, 200)
 (3, 30, 300)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/teezip.jl#LL175-L197">source</a></section></article><h3 id="Experimental-transducers"><a class="docs-heading-anchor" href="#Experimental-transducers">Experimental transducers</a><a id="Experimental-transducers-1"></a><a class="docs-heading-anchor-permalink" href="#Experimental-transducers" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Transducers.ZipSource" href="#Transducers.ZipSource"><code>Transducers.ZipSource</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ZipSource(xform::Transducer)</code></pre><p>Branch input into two &quot;flows&quot;, inject one into <code>xform</code> and then merge (zip) the output of <code>xform</code> with the original (source) input.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This API is experimental.  Backward incompatible change, including the removal of this API, is more likely to occur than other parts of this package.</p></div></div><p>To illustrate how it works, consider the following usage</p><pre><code class="language-none">collection |&gt; xf0 |&gt; ZipSource(xf1) |&gt; xf2</code></pre><p>where <code>xf0</code>, <code>xf1</code>, and <code>xf2</code> are some transducers.  Schematically, the output <code>yn</code> from <code>xfn</code> flows as follows:</p><pre><code class="language-text">xf0      xf1                       xf2
---- y0 ------ y1 ---.-- (y0, y1) -----&gt;
      |              |
       `-------------&#39;</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers
       using Transducers: ZipSource

julia&gt; collect(ZipSource(opcompose(Filter(isodd), Map(x -&gt; x + 1))), 1:5)
3-element Array{Tuple{Int64,Int64},1}:
 (1, 2)
 (3, 4)
 (5, 6)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/teezip.jl#LL1-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.GetIndex" href="#Transducers.GetIndex"><code>Transducers.GetIndex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GetIndex(array)
GetIndex{inbounds}(array)</code></pre><p>Transform an integer input <code>i</code> to <code>array[i]</code>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This API is experimental.  Backward incompatible change, including the removal of this API, is more likely to occur than other parts of this package.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers
       using Transducers: GetIndex

julia&gt; collect(GetIndex(1:10), [2, 3, 4])
3-element Array{Int64,1}:
 2
 3
 4

julia&gt; collect(GetIndex{true}(1:10), [2, 3, 4])
3-element Array{Int64,1}:
 2
 3
 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/library.jl#LL1452-L1477">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.SetIndex" href="#Transducers.SetIndex"><code>Transducers.SetIndex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SetIndex(array)
SetIndex{inbounds}(array)</code></pre><p>Perform <code>array[i] = v</code> for each input pair <code>(i, v)</code>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This API is experimental.  Backward incompatible change, including the removal of this API, is more likely to occur than other parts of this package.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers
       using Transducers: SetIndex

julia&gt; ys = zeros(3);

julia&gt; foldl(first ∘ tuple, SetIndex(ys), [(1, 11.1), (3, 33.3)], init=nothing)

julia&gt; ys
3-element Array{Float64,1}:
 11.1
  0.0
 33.3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/library.jl#LL1496-L1519">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.Inject" href="#Transducers.Inject"><code>Transducers.Inject</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Inject(iterator)</code></pre><p>Inject the output from <code>iterator</code> to the stream processed by the inner reduction step.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This API is experimental.  Backward incompatible change, including the removal of this API, is more likely to occur than other parts of this package.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers
       using Transducers: Inject

julia&gt; collect(Inject(Iterators.cycle(&quot;hello&quot;)), 1:8)
8-element Array{Tuple{Int64,Char},1}:
 (1, &#39;h&#39;)
 (2, &#39;e&#39;)
 (3, &#39;l&#39;)
 (4, &#39;l&#39;)
 (5, &#39;o&#39;)
 (6, &#39;h&#39;)
 (7, &#39;e&#39;)
 (8, &#39;l&#39;)

julia&gt; collect(Inject(Iterators.repeated([1 2])), 1:4)
4-element Array{Tuple{Int64,Array{Int64,2}},1}:
 (1, [1 2])
 (2, [1 2])
 (3, [1 2])
 (4, [1 2])

julia&gt; collect(Inject(Iterators.product(1:2, 3:5)), 1:100)
6-element Array{Tuple{Int64,Tuple{Int64,Int64}},1}:
 (1, (1, 3))
 (2, (2, 3))
 (3, (1, 4))
 (4, (2, 4))
 (5, (1, 5))
 (6, (2, 5))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/library.jl#LL1541-L1581">source</a></section></article><h2 id="combinators"><a class="docs-heading-anchor" href="#combinators">Other reducing function combinators</a><a id="combinators-1"></a><a class="docs-heading-anchor-permalink" href="#combinators" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Transducers.TeeRF" href="#Transducers.TeeRF"><code>Transducers.TeeRF</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TeeRF(reducing_functions::Tuple)
TeeRF(reducing_functions...)</code></pre><p>Combine multiple reducing functions into a new reducing function that &quot;multicast&quot; the input to multiple reducing functions.</p><p>Roughly speaking, <code>TeeRF(op₁, op₂, ..., opₙ)</code> is equivalent to</p><pre><code class="language-julia">((a₁, a₂, ..., aₙ), x) -&gt; (op₁(a₁, x), op₂(a₂, x), ..., opₙ(aₙ, x))</code></pre><p>For <a href="../interface/#Transducers.combine"><code>combine</code></a>, it behaves like <a href="#Transducers.ProductRF"><code>ProductRF</code></a>.</p><div class="admonition is-compat"><header class="admonition-header">Transducers.jl 0.4.32</header><div class="admonition-body"><p>New in version 0.4.32.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; extrema′(xs, xf = Map(identity)) = foldl(TeeRF(min, max), xf, xs);

julia&gt; extrema′([5, 2, 6, 8, 3])
(2, 8)</code></pre><p>Note that the input is considered empty unless <em>all</em> reducing functions call their bottom reducing functions.  Specify <code>init</code> to obain results even when the input collection is empty or all filtered out.</p><pre><code class="language-julia-repl">julia&gt; filtering_max = Filter(isodd)&#39;(max);

julia&gt; foldl(TeeRF(min, filtering_max), Map(identity), [5, 2, 6, 8, 3])
(2, 5)

julia&gt; foldl(TeeRF(min, filtering_max), Map(identity), 2:2:8)
ERROR: EmptyResultError: ...

julia&gt; foldl(TeeRF(min, filtering_max), Map(identity), 2:2:8; init = Init)
(2, InitialValue(max))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/combinators.jl#LL65-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.ProductRF" href="#Transducers.ProductRF"><code>Transducers.ProductRF</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ProductRF(reducing_functions::Tuple)
ProductRF(reducing_functions...)</code></pre><p>Combine <code>N</code> reducing functions into a new reducing function that work on <code>N</code>-tuple.  The <code>i</code>-th reducing function recieves the <code>i</code>-th element of the input tuple.</p><p>Roughly speaking, <code>ProductRF(op₁, op₂, ..., opₙ)</code> is equivalent to</p><pre><code class="language-julia">((a₁, a₂, ..., aₙ), (b₁, b₂, ..., bₙ)) -&gt; (op₁(a₁, b₁), op₂(a₂, b₂), ..., opₙ(aₙ, bₙ))</code></pre><div class="admonition is-compat"><header class="admonition-header">Transducers.jl 0.4.32</header><div class="admonition-body"><p>New in version 0.4.32.</p></div></div><p><strong>Examples</strong></p><p>Like <a href="#Transducers.TeeRF"><code>TeeRF</code></a>, <code>ProductRF</code> can be used to drive multiple reducing functions.  <code>ProductRF</code> is more &quot;low-level&quot; in the sense that <code>TeeRF</code> can be defined in terms of <code>ProductRF</code> (other direction is much harder):</p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; TeeRF′(fs...) = reducingfunction(
           Map(x -&gt; ntuple(_ -&gt; x, length(fs))),
           ProductRF(fs...),
       );

julia&gt; foldl(TeeRF′(min, max), Map(identity), [5, 2, 6, 8, 3])
(2, 8)</code></pre><p><code>ProductRF</code> may be useful for handling pre-existing stream whose item type is already a tuple:</p><pre><code class="language-julia">julia&gt; foldl(ProductRF(&amp;, +), Map(x -&gt; (isodd(x), x)), [5, 2, 6, 8, 3])
(false, 24)

julia&gt; foldl(TeeRF(reducingfunction(Map(isodd), &amp;), +), Map(identity), [5, 2, 6, 8, 3])
(false, 24)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/combinators.jl#LL125-L171">source</a></section></article><h2 id="Early-termination"><a class="docs-heading-anchor" href="#Early-termination">Early termination</a><a id="Early-termination-1"></a><a class="docs-heading-anchor-permalink" href="#Early-termination" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Transducers.Reduced" href="#Transducers.Reduced"><code>Transducers.Reduced</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Reduced</code></pre><p>The type signaling transducible processes to abort.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Call <a href="#Transducers.reduced"><code>reduced</code></a> function for aborting the transducible process since <a href="#Transducers.reduced"><code>reduced</code></a> makes sure <code>x</code> is not doubly wrapped.  <code>Reduced</code> is meant to be used as <code>x isa Reduced</code> for checking if the result from <a href="#Transducers.transduce"><code>transduce</code></a> is due to early termination.</p></div></div><p>See <a href="#Transducers.reduced"><code>reduced</code></a>, <a href="#Transducers.unreduced"><code>unreduced</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; function step_demo(y, x)
           if x &gt; 5
               return reduced(y)
           else
               return y + x
           end
       end;

julia&gt; result = transduce(Map(identity), Completing(step_demo), 0, 1:10)
Reduced(15)

julia&gt; result isa Reduced
true

julia&gt; unreduced(result)
15

julia&gt; result = transduce(Map(identity), Completing(step_demo), 0, 1:4)
10

julia&gt; result isa Reduced
false

julia&gt; unreduced(result)
10</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/core.jl#LL3-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.reduced" href="#Transducers.reduced"><code>Transducers.reduced</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">reduced([x = nothing])</code></pre><p>Stop transducible process with the final value <code>x</code> (default: <code>nothing</code>).  Return <code>x</code> as-is if it already is a <code>reduced</code> value.</p><p>See <a href="#Transducers.Reduced"><code>Reduced</code></a>, <a href="#Transducers.unreduced"><code>unreduced</code></a>.</p><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/ensure-reduced"><code>ensure-reduced</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; foldl(Enumerate(), &quot;abcdef&quot;; init=0) do y, (i, x)
           if x == &#39;d&#39;
               return reduced(y)
           end
           return y + i
       end
6

julia&gt; foreach(Enumerate(), &quot;abc&quot;) do (i, x)
           println(i, &#39; &#39;, x)
           if x == &#39;b&#39;
               return reduced()
           end
       end;
1 a
2 b</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/core.jl#LL59-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.unreduced" href="#Transducers.unreduced"><code>Transducers.unreduced</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">unreduced(x)</code></pre><p>Unwrap <code>x</code> if it is a <code>Reduced</code>; do nothing otherwise.</p><p>See <a href="#Transducers.Reduced"><code>Reduced</code></a>, <a href="#Transducers.reduced"><code>reduced</code></a>.</p><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/unreduced"><code>unreduced</code> in Clojure</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/core.jl#LL95-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.ifunreduced" href="#Transducers.ifunreduced"><code>Transducers.ifunreduced</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ifunreduced(f, [x])</code></pre><p>Equivalent to <a href="#Transducers.unreduced"><code>unreduced(x)</code></a> if <code>x</code> is a <a href="#Transducers.Reduced"><code>Reduced</code></a>; otherwise run <code>f(x)</code>.  Return a curried version if <code>x</code> is not provided.</p><p>See: <a href="#Base.foreach"><code>foreach</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; 1 |&gt; ifunreduced() do x
           println(&quot;called with x = &quot;, x)
       end
called with x = 1

julia&gt; reduced(1) |&gt; ifunreduced() do x
           println(&quot;called with x = &quot;, x)
       end
1</code></pre><p>Notice that nothing is printed in the last example.</p><p><strong>Implementation</strong></p><pre><code class="language-julia">ifunreduced(f) = x -&gt; ifunreduced(f, x)
ifunreduced(f, x::Reduced) = unreduced(x)
ifunreduced(f, x) = f(x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/processes.jl#LL1013-L1046">source</a></section></article><h2 id="Miscellaneous"><a class="docs-heading-anchor" href="#Miscellaneous">Miscellaneous</a><a id="Miscellaneous-1"></a><a class="docs-heading-anchor-permalink" href="#Miscellaneous" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Transducers.Transducer-Tuple{Union{Base.Generator, Base.Iterators.Filter, Base.Iterators.Flatten}}" href="#Transducers.Transducer-Tuple{Union{Base.Generator, Base.Iterators.Filter, Base.Iterators.Flatten}}"><code>Transducers.Transducer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Transducer(iterator::Iterators.Generator)
Transducer(iterator::Iterators.Filter)
Transducer(iterator::Iterators.Flatten)</code></pre><p>Extract &quot;processing&quot; part of an <code>iterator</code> as a <code>Transducer</code>.  The &quot;data source&quot; iterator (i.e., <code>xs</code> in <code>(f(x) for x in xs)</code>) is ignored and <code>nothing</code> must be used as a place holder (i.e., <code>(f(x) for x in nothing)</code>).</p><p>See also <a href="#Transducers.eduction"><code>eduction</code></a>.</p><div class="admonition is-compat"><header class="admonition-header">Transducers.jl 0.3</header><div class="admonition-body"><p>New in version 0.3.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; xf1 = Transducer(2x for x in nothing if x % 2 == 0);

julia&gt; xf2 = opcompose(Filter(x -&gt; x % 2 == 0), Map(x -&gt; 2x));  # equivalent

julia&gt; xs = 1:10
       collect(xf1, xs) == collect(xf2, xs)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/comprehensions.jl#LL34-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.Transducer-Tuple{OnlineStatsBase.OnlineStat}" href="#Transducers.Transducer-Tuple{OnlineStatsBase.OnlineStat}"><code>Transducers.Transducer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Transducer(o::OnlineStat)</code></pre><p>Use an <code>OnlineStat</code> as a stateful transducer.</p><p>It is implemented as:</p><pre><code class="language-julia">opcompose(Scan(fit!, CopyInit(o)), Map(value))</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers
       using OnlineStats: Mean

julia&gt; collect(Transducer(Mean()), 1:4)
4-element Array{Float64,1}:
 1.0
 1.5
 2.0
 2.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/interop/onlinestats.jl#LL1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.reducingfunction" href="#Transducers.reducingfunction"><code>Transducers.reducingfunction</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">reducingfunction(xf, step; simd)
xf&#39;(step; simd)</code></pre><p>Apply transducer <code>xf</code> to the reducing function <code>step</code> to create a new reducing function.</p><div class="admonition is-compat"><header class="admonition-header">Transducers.jl 0.3</header><div class="admonition-body"><p>New in version 0.3.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Be careful using <code>reducingfunction</code> with stateful transducers like <a href="#Transducers.Scan"><code>Scan</code></a> with mutable <code>init</code> (e.g., <code>Scan(push!, [])</code>).  See more in Examples below.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>xf::Transducer</code>: A transducer.</li><li><code>step</code>: A callable which accepts 1 and 2 arguments.  If it only accepts 2 arguments, wrap it with <a href="#Transducers.Completing"><code>Completing</code></a> to &quot;add&quot; 1-argument form (i.e., <a href="../interface/#Transducers.complete"><code>complete</code></a> protocol).</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>simd</code>: <code>false</code>, <code>true</code>, or <code>:ivdep</code>. See <a href="../../explanation/internals/#Transducers.maybe_usesimd-Tuple{Transducers.AbstractReduction,Union{Val{true}, Val{false}, Val{:ivdep}, Bool, Symbol}}"><code>maybe_usesimd</code></a>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; rf = reducingfunction(Map(x -&gt; x + 1), *);

julia&gt; rf(10, 2) === 10 * (2 + 1)
true</code></pre><p><strong>Warning: Be careful when using <code>reducingfunction</code> with stateful transducers</strong></p><p>Stateful <code>Transducer</code>s themselves in Transducers.jl are not inherently broken with <code>reducingfunction</code>.  However, it can produce incorrect results when combined with mutable states:</p><pre><code class="language-julia-repl">julia&gt; scan_state = [];

julia&gt; rf_bad = opcompose(Scan(push!, scan_state), Cat())&#39;(string);

julia&gt; transduce(rf_bad, &quot;&quot;, 1:3)
&quot;112123&quot;</code></pre><p>The first run works.  However, observe that the vector <code>scan_state</code> is not empty anymore:</p><pre><code class="language-julia-repl">julia&gt; scan_state
3-element Array{Any,1}:
 1
 2
 3</code></pre><p>Thus, the second run produces an incorrect result:</p><pre><code class="language-julia-repl">julia&gt; transduce(rf_bad, &quot;&quot;, 1:3)
&quot;123112312123123&quot;</code></pre><p>One way to solve this issue is to use <a href="#Transducers.CopyInit"><code>CopyInit</code></a> or <a href="#Transducers.OnInit"><code>OnInit</code></a>.</p><pre><code class="language-julia-repl">julia&gt; scan_state = CopyInit([])
CopyInit(Any[])

julia&gt; rf_good = opcompose(Scan(push!, scan_state), Cat())&#39;(string);

julia&gt; transduce(rf_good, &quot;&quot;, 1:3)
&quot;112123&quot;

julia&gt; scan_state
CopyInit(Any[])

julia&gt; transduce(rf_good, &quot;&quot;, 1:3)
&quot;112123&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/processes.jl#LL3-L89">source</a></section><section><div><pre><code class="language-none">reducingfunction([xf::Transducer,] o::OnlineStat; simd)</code></pre><p>Convert an <code>OnlineStat</code> to a reducing function.  Returned function can be used with <a href="#Base.foldl"><code>foldl</code></a>, <a href="#Base.reduce"><code>reduce</code></a>, and <a href="#Transducers.dreduce"><code>dreduce</code></a>. Note that input <code>o</code> is only used as a &quot;prototype&quot;; i.e., it&#39;s not going to be mutated.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers
       using OnlineStats: Mean

julia&gt; foldl(reducingfunction(Mean()), Map(x -&gt; x^2), 1:4)
Mean: n=4 | value=7.5

julia&gt; foldl(Mean(), Map(x -&gt; x^2), 1:4)  # equivalent to above
Mean: n=4 | value=7.5

julia&gt; reduce(Mean(), Map(x -&gt; x^2), 1:4)  # threaded
Mean: n=4 | value=7.5

julia&gt; foldl(Mean(), eduction(x^2 for x in 1:4))  # ditto
Mean: n=4 | value=7.5

julia&gt; reduce(Mean(), eduction(x^2 for x in 1:4))  # ditto
Mean: n=4 | value=7.5</code></pre><p><a href="#Transducers.dreduce"><code>dreduce</code></a> can be used instead of <code>reduce</code>.  However the usual caveats of code availability for Distributed.jl apply.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/interop/onlinestats.jl#LL29-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.Completing" href="#Transducers.Completing"><code>Transducers.Completing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Completing(function)</code></pre><p>Wrap a <code>function</code> to add a no-op <a href="../interface/#Transducers.complete"><code>complete</code></a> protocol.  Use it when passing a <code>function</code> without unary method to <a href="#Transducers.transduce"><code>transduce</code></a> etc.</p><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/completing"><code>completing</code> in Clojure</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/core.jl#LL724-L732">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.Init" href="#Transducers.Init"><code>Transducers.Init</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">Init
Init(op) :: InitialValues.InitialValue</code></pre><p>The canonical initializer; i.e., a singleton placeholder usable for <code>init</code> argument of <code>foldl</code> for binary functions with known initial values.</p><p>When <code>init = Init</code> is passed to <code>foldl</code> etc., <code>Init(op)</code> is called for the bottom reducing function <code>op</code> during the <a href="../interface/#Transducers.start"><code>start</code></a> phase. <code>Init(op)</code> returns <a href="https://juliafolds.github.io/InitialValues.jl/dev/#InitialValues.InitialValue"><code>InitialValue(op)</code></a> which acts as the canonical initial value of <code>op</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; foldl(+, 1:3 |&gt; Filter(isodd); init = Init)
4

julia&gt; foldl(+, 2:2:4 |&gt; Filter(isodd); init = Init)
InitialValue(+)</code></pre><p><strong>Extended help</strong></p><p>Note that <code>op</code> passed to <code>foldl</code> etc. must be known to InitialValues.jl:</p><pre><code class="language-julia-repl">julia&gt; unknown_op(a, b) = a + b;

julia&gt; foldl(unknown_op, 2:2:4 |&gt; Filter(isodd); init = Init)
ERROR: IdentityNotDefinedError: `init = Transducers.Init` is specified but the identity element `InitialValue(op)` is not defined for
    op = unknown_op
[...]</code></pre><p><code>InitialValues.asmonoid</code> can be used to wrap a binary function to add (&quot;adjoin&quot;) the identity value to its domain:</p><pre><code class="language-julia-repl">julia&gt; using InitialValues: asmonoid

julia&gt; foldl(asmonoid(unknown_op), 2:2:4 |&gt; Filter(isodd); init = Init)
InitialValue(::InitialValues.AdjoinIdentity{typeof(unknown_op)})</code></pre><p>When <a href="../interface/#Transducers.start"><code>start(rf, Init)</code></a> is called with a composite reducing function <code>rf</code>, <code>Init(rf₀)</code> is called for the bottom reducing function <code>rf₀</code> of <code>rf</code>:</p><pre><code class="language-julia-repl">julia&gt; rf = Take(3)&#39;(+);  # `+` is the bottom reducing function

julia&gt; acc = Transducers.start(rf, Init);

julia&gt; Transducers.unwrap(rf, acc)
(3, InitialValue(+))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/core.jl#LL1063-L1124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.OnInit" href="#Transducers.OnInit"><code>Transducers.OnInit</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OnInit(f)</code></pre><p>Call a callable <code>f</code> to create an initial value.</p><p>See also <a href="#Transducers.CopyInit"><code>CopyInit</code></a>.</p><p><code>OnInit</code> or <code>CopyInit</code> must be used whenever using in-place reduction with <a href="#Base.reduce"><code>reduce</code></a> etc.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; xf1 = Scan(push!, [])
Scan(push!, Any[])

julia&gt; foldl(right, xf1, 1:3)
3-element Array{Any,1}:
 1
 2
 3

julia&gt; xf1
Scan(push!, Any[1, 2, 3])</code></pre><p>Notice that the array is stored in <code>xf1</code> and mutated in-place.  As a result, second run of <code>foldl</code> contains the results from the first run:</p><pre><code class="language-julia-repl">julia&gt; foldl(right, xf1, 10:11)
5-element Array{Any,1}:
  1
  2
  3
 10
 11</code></pre><p>This may not be desired.  To avoid this behavior, create an <code>OnInit</code> object which takes a factory function to create a new initial value.</p><pre><code class="language-julia-repl">julia&gt; xf2 = Scan(push!, OnInit(() -&gt; []))
Scan(push!, OnInit(##9#10()))

julia&gt; foldl(right, xf2, 1:3)
3-element Array{Any,1}:
 1
 2
 3

julia&gt; foldl(right, xf2, [10.0, 11.0])
2-element Array{Any,1}:
 10.0
 11.0</code></pre><p>Keyword argument <code>init</code> for transducible processes also accept an <code>OnInit</code>:</p><pre><code class="language-julia-repl">julia&gt; foldl(push!, Map(identity), &quot;abc&quot;; init=OnInit(() -&gt; []))
3-element Array{Any,1}:
 &#39;a&#39;
 &#39;b&#39;
 &#39;c&#39;</code></pre><p>To create a copy of a mutable object, <a href="#Transducers.CopyInit"><code>CopyInit</code></a> is easier to use.</p><p>However, more powerful and generic pattern is to use <code>push!!</code> from BangBang.jl and initialize <code>init</code> with <code>Union{}[]</code> so that it automatically finds the minimal element type.</p><pre><code class="language-julia-repl">julia&gt; using BangBang

julia&gt; foldl(push!!, Map(identity), &quot;abc&quot;; init=Union{}[])
3-element Array{Char,1}:
 &#39;a&#39;
 &#39;b&#39;
 &#39;c&#39;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/core.jl#LL883-L970">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.CopyInit" href="#Transducers.CopyInit"><code>Transducers.CopyInit</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CopyInit(value)</code></pre><p>This is equivalent to <code>OnInit(() -&gt; deepcopy(value))</code>.</p><div class="admonition is-compat"><header class="admonition-header">Transducers.jl 0.3</header><div class="admonition-body"><p>New in version 0.3.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; init = CopyInit([]);

julia&gt; foldl(push!, Map(identity), 1:3; init=init)
3-element Array{Any,1}:
 1
 2
 3

julia&gt; foldl(push!, Map(identity), 1:3; init=init)  # `init` can be reused
3-element Array{Any,1}:
 1
 2
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/core.jl#LL979-L1006">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.right" href="#Transducers.right"><code>Transducers.right</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">right([l, ]r) -&gt; r</code></pre><p>It is simply defined as</p><pre><code class="language-julia">right(l, r) = r
right(r) = r</code></pre><p>This function is meant to be used as <code>step</code> argument for <a href="#Base.foldl"><code>foldl</code></a> etc. for extracting the last output of the transducers.</p><div class="admonition is-compat"><header class="admonition-header">Transducers.jl 0.3</header><div class="admonition-body"><p>Initial value must be manually specified.  In 0.2, it was automatically set to <code>nothing</code>.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; foldl(right, Take(5), 1:10)
5

julia&gt; foldl(right, Drop(5), 1:3; init=0)  # using `init` as the default value
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/core.jl#LL784-L813">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.setinput" href="#Transducers.setinput"><code>Transducers.setinput</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">setinput(ed::Eduction, coll)</code></pre><p>Set input collection of eduction <code>ed</code> to <code>coll</code>.</p><div class="admonition is-compat"><header class="admonition-header">Transducers.jl 0.3</header><div class="admonition-body"><p>Previously, <code>setinput</code> combined with <code>eduction</code> was a recommended way to use transducers in a type stable manner.  As of v0.3, all the <code>foldl</code>-like functions and <code>eduction</code> are type stable for many cases.  This workaround is no more necessary.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; ed = eduction(Map(x -&gt; 2x), Float64[]);

julia&gt; xs = ones(2, 3);

julia&gt; foldl(+, setinput(ed, xs))
12.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/processes.jl#LL573-L596">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.AdHocFoldable" href="#Transducers.AdHocFoldable"><code>Transducers.AdHocFoldable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AdHocFoldable(foldl, [collection = nothing])</code></pre><p>Provide a different way to fold <code>collection</code> without creating a wrapper type.</p><p><strong>Arguments</strong></p><ul><li><code>foldl::Function</code>: a function that implements <a href="../interface/#Transducers.__foldl__"><code>__foldl__</code></a>.</li><li><code>collection</code>: a collection passed to the last argument of <code>foldl</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers
       using Transducers: @next, complete
       using ArgCheck

julia&gt; function uppertriangle(A::AbstractMatrix)
           @argcheck !Base.has_offset_axes(A)
           return AdHocFoldable(A) do rf, acc, A
               for j in 1:size(A, 2), i in 1:min(j, size(A, 1))
                   acc = @next(rf, acc, @inbounds A[i, j])
               end
               return complete(rf, acc)
           end
       end;

julia&gt; A = reshape(1:6, (3, 2))
3×2 reshape(::UnitRange{Int64}, 3, 2) with eltype Int64:
 1  4
 2  5
 3  6

julia&gt; collect(Map(identity), uppertriangle(A))
3-element Array{Int64,1}:
 1
 4
 5

julia&gt; function circularwindows(xs::AbstractVector, h::Integer)
           @argcheck !Base.has_offset_axes(xs)
           @argcheck h &gt;= 0
           @argcheck 2 * h + 1 &lt;= length(xs)
           return AdHocFoldable(xs) do rf, acc, xs
               buffer = similar(xs, 2 * h + 1)
               @inbounds for i in 1:h
                   buffer[1:h - i + 1] .= @view xs[end - h + i:end]
                   buffer[h - i + 2:end] .= @view xs[1:h + i]
                   acc = @next(rf, acc, buffer)
               end
               for i in h + 1:length(xs) - h
                   acc = @next(rf, acc, @inbounds @view xs[i - h:i + h])
               end
               @inbounds for i in 1:h
                   buffer[1:end - i] .= @view xs[end - 2 * h + i:end]
                   buffer[end - i + 1:end] .= @view xs[1:i]
                   acc = @next(rf, acc, buffer)
               end
               return complete(rf, acc)
           end
       end;

julia&gt; collect(Map(collect), circularwindows(1:9, 2))
9-element Array{Array{Int64,1},1}:
 [8, 9, 1, 2, 3]
 [9, 1, 2, 3, 4]
 [1, 2, 3, 4, 5]
 [2, 3, 4, 5, 6]
 [3, 4, 5, 6, 7]
 [4, 5, 6, 7, 8]
 [5, 6, 7, 8, 9]
 [6, 7, 8, 9, 1]
 [7, 8, 9, 1, 2]

julia&gt; expressions(str::AbstractString; kwargs...) =
           AdHocFoldable(str) do rf, val, str
               pos = 1
               while true
                   expr, pos = Meta.parse(str, pos;
                                          raise = false,
                                          depwarn = false,
                                          kwargs...)
                   expr === nothing &amp;&amp; break
                   val = @next(rf, val, expr)
               end
               return complete(rf, val)
           end;

julia&gt; collect(Map(identity), expressions(&quot;&quot;&quot;
       x = 1
       y = 2
       &quot;&quot;&quot;))
2-element Array{Expr,1}:
 :(x = 1)
 :(y = 2)

julia&gt; counting = AdHocFoldable() do rf, acc, _
           i = 0
           while true
               i += 1
               acc = @next(rf, acc, i)
           end
       end;

julia&gt; foreach(counting) do i
           @show i;
           i == 3 &amp;&amp; return reduced()
       end;
i = 1
i = 2
i = 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/processes.jl#LL1101-L1213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Transducers.withprogress" href="#Transducers.withprogress"><code>Transducers.withprogress</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">withprogress(foldable) -&gt; foldable′</code></pre><p>Wrap a foldable so that progress is shown in logging-based progress meter (e.g., Juno) during <a href="#Base.foldl"><code>foldl</code></a>, <a href="#Base.reduce"><code>reduce</code></a>, <a href="#Transducers.dreduce"><code>dreduce</code></a>, etc.</p><p>For parallel reduction such as <code>reduce</code> and <code>dreduce</code>, reasonably small <code>basesize</code> and <code>threads_basesize</code> (for <code>dreduce</code>) must be used to ensure that progress information is updated frequently.  However, it may slow down the computation if <code>basesize</code> is too small.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>interval::Real</code>: Minimum interval (in seconds) for how often progress is logged.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; xf = Map() do x
           sleep(0.01)
           x
       end;

julia&gt; foldl(+, xf, withprogress(1:100; interval=1e-3))  # see progress meter
5050</code></pre><p>In <code>foldl</code> and <code>reduce</code>, <code>withprogress</code> can be nested.  This is not supported in <code>dreduce</code>.</p><pre><code class="language-julia-repl">julia&gt; xf = opcompose(
           MapCat() do x
               withprogress(1:x; interval=1e-3)  # nested progress
           end,
           Map() do x
               sleep(0.5)
               x
           end,
       );

julia&gt; if VERSION &gt;= v&quot;1.3-alpha&quot;
           # Calling `sleep` in thread is safe in Julia 1.3:
           reduce(+, xf, withprogress(1:10; interval=1e-3); basesize=1)
       else
           foldl(+, xf, withprogress(1:10; interval=1e-3))
       end
220</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/progress.jl#LL1-L51">source</a></section></article><h2 id="Deprecated"><a class="docs-heading-anchor" href="#Deprecated">Deprecated</a><a id="Deprecated-1"></a><a class="docs-heading-anchor-permalink" href="#Deprecated" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.mapfoldl" href="#Base.mapfoldl"><code>Base.mapfoldl</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mapfoldl(xf::Transducer, step, reducible; init, simd)</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p><code>mapfoldl</code> exists primary for backward compatibility.  It is recommended to use <code>foldl</code>.</p></div></div><p>Like <a href="#Base.foldl"><code>foldl</code></a> but <code>step</code> is <em>not</em> automatically wrapped by <a href="#Transducers.Completing"><code>Completing</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; function step_demo(state, input)
           @show state, input
           state + input
       end;

julia&gt; function step_demo(state)
           println(&quot;Finishing with state = &quot;, state)
           state
       end;

julia&gt; mapfoldl(Filter(isodd), step_demo, 1:4, init=0.0)
(state, input) = (0.0, 1)
(state, input) = (1.0, 3)
Finishing with state = 4.0
4.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/processes.jl#LL361-L392">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.mapreduce" href="#Base.mapreduce"><code>Base.mapreduce</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mapreduce(xf, step, reducible; init, simd)</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p><code>mapreduce</code> exists primary for backward compatibility.  It is recommended to use <code>reduce</code>.</p></div></div><p>Like <a href="#Base.reduce"><code>reduce</code></a> but <code>step</code> is <em>not</em> automatically wrapped by <a href="#Transducers.Completing"><code>Completing</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds/Transducers.jl/blob/31b2338d3267af3936a2f68363c1f4ec77538b38/src/reduce.jl#LL57-L67">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-julia_issue_22891"><a class="tag is-link" href="#citeref-julia_issue_22891">julia_issue_22891</a>See also: <a href="https://github.com/JuliaLang/julia/issues/22891">break with value + loop else clauses (JuliaLang/julia#22891)</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Home</a><a class="docs-footer-nextpage" href="../interface/">Interface »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 7 July 2020 23:50">Tuesday 7 July 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
