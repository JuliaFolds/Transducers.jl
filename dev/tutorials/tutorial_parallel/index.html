<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial: Parallelism · Transducers.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Transducers.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../../reference/manual/">Manual</a></li><li><a class="tocitem" href="../../reference/interface/">Interface</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorial_missings/">Tutorial: Missing values</a></li><li class="is-active"><a class="tocitem" href>Tutorial: Parallelism</a><ul class="internal"><li><a class="tocitem" href="#Quick-examples"><span>Quick examples</span></a></li><li><a class="tocitem" href="#When-can-I-use-foldxt-and-foldxd?"><span>When can I use <code>foldxt</code> and <code>foldxd</code>?</span></a></li><li><a class="tocitem" href="#tutorial-parallel-collect"><span>Example: parallel <code>collect</code></span></a></li><li><a class="tocitem" href="#Example:-ad-hoc-histogram"><span>Example: ad-hoc histogram</span></a></li><li><a class="tocitem" href="#Example:-early-termination"><span>Example: early termination</span></a></li></ul></li><li><a class="tocitem" href="../words/">Parallel word count</a></li></ul></li><li><span class="tocitem">How-to guides</span><ul><li><a class="tocitem" href="../../howto/upgrade-to-ixf/">Upgrade to new <code>|&gt;</code> of Transducers.jl 0.4.39</a></li><li><a class="tocitem" href="../../howto/empty_result_handling/">Empty result handling</a></li><li><a class="tocitem" href="../../howto/transducers/">Writing transducers</a></li><li><a class="tocitem" href="../../howto/reducibles/">Writing reducibles</a></li><li><a class="tocitem" href="../../howto/useful_patterns/">Useful patterns</a></li></ul></li><li><span class="tocitem">Explanation</span><ul><li><a class="tocitem" href="../../parallelism/">Parallelism</a></li><li><a class="tocitem" href="../../explanation/comparison_to_iterators/">Comparison to iterators</a></li><li><a class="tocitem" href="../../explanation/glossary/">Glossary</a></li><li><a class="tocitem" href="../../explanation/state_machines/">State machines</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Tutorial: Parallelism</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial: Parallelism</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaFolds/Transducers.jl/blob/master/examples/tutorial_parallel.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="tutorial-parallel"><a class="docs-heading-anchor" href="#tutorial-parallel">Parallel processing tutorial</a><a id="tutorial-parallel-1"></a><a class="docs-heading-anchor-permalink" href="#tutorial-parallel" title="Permalink"></a></h1><p>See also: <a href="../../parallelism/#overview-parallel">Overview of parallel processing in Transducers.jl</a></p><h2 id="Quick-examples"><a class="docs-heading-anchor" href="#Quick-examples">Quick examples</a><a id="Quick-examples-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-examples" title="Permalink"></a></h2><h3 id="Sequential-processing"><a class="docs-heading-anchor" href="#Sequential-processing">Sequential processing</a><a id="Sequential-processing-1"></a><a class="docs-heading-anchor-permalink" href="#Sequential-processing" title="Permalink"></a></h3><pre><code class="language-julia">using Transducers

xs = randn(10_000_000)
foldl(+, Map(sin), xs)</code></pre><pre class="documenter-example-output">-2122.9415394848356</pre><h3 id="Thread-based-parallelism"><a class="docs-heading-anchor" href="#Thread-based-parallelism">Thread-based parallelism</a><a id="Thread-based-parallelism-1"></a><a class="docs-heading-anchor-permalink" href="#Thread-based-parallelism" title="Permalink"></a></h3><p>Just replace <code>foldl</code> with <code>foldxt</code>, to make use of multiple cores:</p><pre><code class="language-julia">foldxt(+, Map(sin), xs)</code></pre><pre class="documenter-example-output">-2122.9415394848356</pre><p>(In my laptop (4 core machine) I start seeing some speedup around <code>length(xs) ≥ 100_000</code> for this transducer and reducing function.)</p><h3 id="Process-based-parallelism"><a class="docs-heading-anchor" href="#Process-based-parallelism">Process-based parallelism</a><a id="Process-based-parallelism-1"></a><a class="docs-heading-anchor-permalink" href="#Process-based-parallelism" title="Permalink"></a></h3><pre><code class="language-julia">using Distributed
addprocs(4)

foldxd(+, Map(sin), xs)</code></pre><pre class="documenter-example-output">-2122.941539484855</pre><p>(Note: there is likely no speedup for light-weight computation and large input data like this, when using <code>foldxd</code>.)</p><h3 id="Parallel-processing-with-iterator-comprehensions"><a class="docs-heading-anchor" href="#Parallel-processing-with-iterator-comprehensions">Parallel processing with iterator comprehensions</a><a id="Parallel-processing-with-iterator-comprehensions-1"></a><a class="docs-heading-anchor-permalink" href="#Parallel-processing-with-iterator-comprehensions" title="Permalink"></a></h3><p>You can also use parallel processing functions in Transducers.jl such as <a href="../../reference/manual/#Transducers.foldxt"><code>foldxt</code></a>, <a href="../../reference/manual/#Transducers.foldxd"><code>foldxd</code></a>, <a href="../../reference/manual/#Transducers.tcollect"><code>tcollect</code></a>, <a href="../../reference/manual/#Transducers.dcollect"><code>dcollect</code></a>, <a href="../../reference/manual/#Transducers.tcopy"><code>tcopy</code></a> and <a href="../../reference/manual/#Transducers.dcopy"><code>dcopy</code></a> with iterator comprehensions:</p><pre><code class="language-julia">foldxt(+, (sin(x) for x in xs if abs(x) &lt; 1); basesize = 500_000)</code></pre><pre class="documenter-example-output">-2709.9215854671284</pre><pre><code class="language-julia">foldxt(+, (x * y for x in 1:3, y in 1:3))</code></pre><pre class="documenter-example-output">36</pre><pre><code class="language-julia">tcollect(sin(x) for x in xs if abs(x) &lt; 1)</code></pre><pre class="documenter-example-output">6826957-element Vector{Float64}:
  0.8083648068107231
  0.8148131866918079
 -0.06530310134381154
 -0.4532030074249769
  0.6593385615314898
 -0.2423080638801703
 -0.6906331868077892
  0.5256500911943072
 -0.10440552230971814
  0.6863217796085403
  ⋮
 -0.4784403274943886
 -0.46761144097083196
  0.566325738864871
 -0.5925200365275034
  0.5708141670411829
  0.3413017229426536
  0.39979088181796324
  0.7737403935869056
  0.7607067950159715</pre><pre><code class="language-julia">using StructArrays: StructVector
table = StructVector(a = [1, 2, 3], b = [5, 6, 7])

tcopy((A = row.a + 1, B = row.b - 1) for row in table if isodd(row.a))</code></pre><pre class="documenter-example-output">2-element StructArray(::Vector{Int64}, ::Vector{Int64}) with eltype NamedTuple{(:A, :B), Tuple{Int64, Int64}}:
 (A = 2, B = 4)
 (A = 4, B = 6)</pre><h2 id="When-can-I-use-foldxt-and-foldxd?"><a class="docs-heading-anchor" href="#When-can-I-use-foldxt-and-foldxd?">When can I use <code>foldxt</code> and <code>foldxd</code>?</a><a id="When-can-I-use-foldxt-and-foldxd?-1"></a><a class="docs-heading-anchor-permalink" href="#When-can-I-use-foldxt-and-foldxd?" title="Permalink"></a></h2><h3 id="Requirement-1:-Associative-reducing-step-function"><a class="docs-heading-anchor" href="#Requirement-1:-Associative-reducing-step-function">Requirement 1: Associative reducing step function</a><a id="Requirement-1:-Associative-reducing-step-function-1"></a><a class="docs-heading-anchor-permalink" href="#Requirement-1:-Associative-reducing-step-function" title="Permalink"></a></h3><p>Parallel reductions such as <a href="../../reference/manual/#Transducers.foldxt"><code>foldxt</code></a> and <a href="../../reference/manual/#Transducers.foldxd"><code>foldxd</code></a> requires <em>associative</em> <a href="../../explanation/glossary/#Glossary">reducing step function</a>. Recall that <a href="https://en.wikipedia.org/wiki/Associative_property">associativity</a> means that the <em>grouping</em> of evaluations of binary operator does not matter:</p><pre><code class="language-julia">op = +  # for example
a, b, c = 1, 2, 3  # for example

@assert op(op(a, b), c) == op(a, op(b, c))</code></pre><p>Given this property, computations like <code>a + b + c + d</code> can be done with different &quot;groupings&quot;:</p><pre><code class="language-none">  a + b + c + d

= ((a + b) + c) + d                +
                                  / \
                                 +   d
                                / \
                               +   c           foldl-like grouping
                              / \
                             a   b

= (a + b) + (c + d)                +
                                  / \
                                 /   \
                                /     \        reduce-like grouping
                               +       +
                              / \     / \
                             a   b   c   d</code></pre><p>Notice that, in the last grouping, computation of <code>c + d</code> does not have to wait for the result of <code>a + b</code>.  This is why we need associativity for parallel execution.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Do not confuse associativity with <em>commutativity</em> <code>op(a, b) = op(b, a)</code>.  For example, matrix multiplication <code>*(::Matrix, ::Matrix)</code> is associative but <em>not</em> commutative in general. However, since <code>foldxt</code> only requires associativity, it is valid to use <code>foldxt(*, xf, matrices)</code>.</p></div></div><p>As reducing function <code>+</code> is associative, it can be used with <code>foldxt</code> (and <code>foldxd</code>):</p><pre><code class="language-julia">foldxt(+, Map(identity), 1:10; init = 0, basesize = 1)</code></pre><pre class="documenter-example-output">55</pre><p>and the result is the same as the sequential version:</p><pre><code class="language-julia">foldl(+, Map(identity), 1:10; init = 0)</code></pre><pre class="documenter-example-output">55</pre><p>Note: <code>basesize</code> is for forcing <code>foldxt</code> to avoid falling back to <code>foldl</code> for small length container such as <code>1:10</code>.</p><p>On the other hand, binary function <code>-</code> is not associative.  Thus, <code>foldxt</code> cannot be used instead of <code>foldl</code> (they produce different result):</p><pre><code class="language-julia">foldxt(-, Map(identity), 1:10; init = 0, basesize = 1)</code></pre><pre class="documenter-example-output">-5</pre><pre><code class="language-julia">foldl(+, Map(identity), 1:10; init = 0)</code></pre><pre class="documenter-example-output">55</pre><h3 id="Requirement-2:-stateless-transducers"><a class="docs-heading-anchor" href="#Requirement-2:-stateless-transducers">Requirement 2: stateless transducers</a><a id="Requirement-2:-stateless-transducers-1"></a><a class="docs-heading-anchor-permalink" href="#Requirement-2:-stateless-transducers" title="Permalink"></a></h3><p>Parallel reduction only work with stateless transducers <a href="../../reference/manual/#Transducers.Map"><code>Map</code></a>, <a href="../../reference/manual/#Transducers.Filter"><code>Filter</code></a>, <a href="../../reference/manual/#Transducers.Cat"><code>Cat</code></a>, etc. and you will get an error when using stateful transducers such as <code>Scan</code> with <code>foldxt</code> or <code>foldxd</code>:</p><pre><code class="language-julia">foldxt(+, Scan(+), 1:10; basesize = 1)</code></pre><pre class="documenter-example-output">ERROR: Stateful transducer Scan(+) does not support `combine`</pre><p>Stateful transducers cannot be used with <code>foldxt</code> because it is impossible to start processing input collection from the middle when the transducers need to know all previous elements (= stateful).</p><p><a href="../../reference/manual/#Transducers.ScanEmit"><code>ScanEmit</code></a> is a stateful transducer but it is assumed that it is used in a context that outputs can be treated as stateless (see: <a href="../words/#parallel-word-count">Splitting a string into words and counting them in parallel</a>).</p><h2 id="tutorial-parallel-collect"><a class="docs-heading-anchor" href="#tutorial-parallel-collect">Example: parallel <code>collect</code></a><a id="tutorial-parallel-collect-1"></a><a class="docs-heading-anchor-permalink" href="#tutorial-parallel-collect" title="Permalink"></a></h2><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This section explains the <em>implementation ideas</em> of parallel <code>collect</code>.  Pre-defined functions such as <a href="../../reference/manual/#Transducers.tcopy"><code>tcopy</code></a> and <a href="../../reference/manual/#Transducers.dcopy"><code>dcopy</code></a> should cover many use-cases.</p></div></div><p>Suppose (pretend) there is a compute-heavy transducer:</p><pre><code class="language-julia">xf_compute = opcompose(Filter(!ismissing), Map(x -&gt; x^2))</code></pre><p>Transducers.jl supports applying this to an input container and then collecting the results into another container.  It can be done sequentially (<a href="../../reference/manual/#Base.collect"><code>collect</code></a>, <a href="../../reference/manual/#Base.copy"><code>copy</code></a>, etc.) and in parallel using threads (<a href="../../reference/manual/#Transducers.tcollect"><code>tcollect</code></a>, <a href="../../reference/manual/#Transducers.tcopy"><code>tcopy</code></a>) or using multiple processes (<a href="../../reference/manual/#Transducers.dcollect"><code>dcollect</code></a>, <a href="../../reference/manual/#Transducers.dcopy"><code>dcopy</code></a>).  For example:</p><pre><code class="language-julia">xs = [abs(x) &gt; 1 ? missing : x for x in randn(10_000)]
y1 = collect(xf_compute, xs)</code></pre><p>Doing this in parallel is as easy as using <code>tcollect</code> or <code>dcollect</code>. However, it is easy to do this manually, too:</p><pre><code class="language-julia">using BangBang: append!!

singleton_vector(x) = [x]
y2 = foldxt(append!!, xs |&gt; xf_compute |&gt; Map(singleton_vector))
@assert y1 == y2</code></pre><p>This code illustrates the common pattern in parallel processing:</p><ol><li><p>Put a result from the transducer in a &quot;singleton solution&quot;. Here, it is <code>[x]</code>.</p></li><li><p>Then &quot;merge&quot; the (singleton) solution into the exsiting one. This is done by <code>append!!</code> in the above example.</p></li></ol><p>To illustrate how <code>foldxt(append!!, xs |&gt; ... |&gt; Map(singleton_vector))</code> works, let&#39;s create a reducing function that records the arguments and returned values of <code>append!!</code>:</p><pre><code class="language-julia">chan = Channel(Inf)

function append_and_log!!(a, b)</code></pre><p>As arguments and output may be mutated later, we use <code>copy</code> to record the snapshots of their values at this moment:</p><pre><code class="language-julia">    a0 = copy(a)
    b0 = copy(b)
    c = append!!(a, b)
    put!(chan, (a0, b0) =&gt; copy(c))
    return c
end</code></pre><p>This function can be used instead of <code>append!!</code>.  Let&#39;s try simpler and shorter example.  This is equivalent to <code>collect(1:4)</code>:</p><pre><code class="language-julia">foldxt(append_and_log!!, Map(singleton_vector), 1:4; basesize = 1, init = Union{}[])</code></pre><pre class="documenter-example-output">4-element Vector{Int64}:
 1
 2
 3
 4</pre><p>(See below for why we are using <code>init = Union{}[]</code> here.)</p><p>Here is the list of arguments and returned value of <code>append!!</code> in this reduction:</p><pre><code class="language-julia">records = Pair[]
while isready(chan)
    push!(records, take!(chan))
end
records</code></pre><pre class="documenter-example-output">7-element Vector{Pair}:
 (Union{}[], [1]) =&gt; [1]
 (Union{}[], [3]) =&gt; [3]
 (Union{}[], [2]) =&gt; [2]
 (Union{}[], [4]) =&gt; [4]
       ([1], [2]) =&gt; [1, 2]
       ([3], [4]) =&gt; [3, 4]
 ([1, 2], [3, 4]) =&gt; [1, 2, 3, 4]</pre><p>This recorded inputs and outputs of <code>append!!</code> show that its &quot;call tree&quot; is:</p><pre><code class="language-none">          [1,2,3,4] &lt;------------- append!!([1,2], [3,4]) == [1,2,3,4]
         /         \
    [1,2]           [3,4] &lt;------- append!!([3], [4]) == [3, 4]
   /     \         /     \
 [1]     [2]     [3]     [4] &lt;---- append!!([], [4]) == [4]
 / \     / \     / \     / \
[] [1]  [] [2]  [] [3]  [] [4]</code></pre><p>Compare this to the example <code>a + b + c + d</code> above.</p><h3 id="Optimization-and-generic-container-handling"><a class="docs-heading-anchor" href="#Optimization-and-generic-container-handling">Optimization and generic container handling</a><a id="Optimization-and-generic-container-handling-1"></a><a class="docs-heading-anchor-permalink" href="#Optimization-and-generic-container-handling" title="Permalink"></a></h3><p>Above usage of <code>foldxt</code> is not quite efficient as <code>singleton_vector</code> allocates small objects in the heap.  Thus, it makes sense to use immutable objects for the singleton solutions so that Julia compiler can eliminate allocation of the intermediate singleton solutions. Here, this can be done by simply using <code>SVector</code>instead of <code>singleton_vector</code>:</p><pre><code class="language-julia">using StaticArrays: SVector

foldxt(append!!, Map(SVector), 1:4)</code></pre><pre class="documenter-example-output">4-element StaticArrays.SVector{4, Int64} with indices SOneTo(4):
 1
 2
 3
 4</pre><p>However, notice that the return value is a static vector.  This is not ideal when the input collection is large.  The output collection type can be specified by <code>init</code>.  We can simply use <code>init = Union{}[]</code> in this case:</p><pre><code class="language-julia">foldxt(append!!, Map(SVector), 1:4; init = Union{}[])</code></pre><pre class="documenter-example-output">4-element Vector{Int64}:
 1
 2
 3
 4</pre><p>Note that passing <code>Vector</code> to <code>init</code> of <code>foldxt</code> is usually a wrong choice as it would mean that the same object is simultaneously mutated by different threads.  However, since <code>Vector{Union{}}</code> cannot have any element (as there is no object of type <code>Union{}</code>), using <code>Union{}[]</code> for <code>init</code> is an exception and it is a good way to indicate that output vector should use the &quot;smallest&quot; <code>eltype</code> required.  That is to say, <code>append!!</code> widens the vector &quot;just enough&quot; to fit the resulting elements.</p><p>For generic containers (e.g., various table types), use <a href="https://juliafolds.github.io/BangBang.jl/dev/#BangBang.NoBang.singletonof-Union{Tuple{T},%20Tuple{Type{T},Any}}%20where%20T"><code>BangBang.Empty</code></a> as the empty initial value.  This is useful for creating a table object such as <a href="https://github.com/JuliaData/DataFrames.jl"><code>DataFrame</code></a> as the result of parallel processing:</p><pre><code class="language-julia">using BangBang: Empty
using DataFrames: DataFrame

foldxt(append!!, Map(x -&gt; SVector((a = x,))), 1:4; init = Empty(DataFrame))</code></pre><pre class="documenter-example-output">4×1 DataFrame
 Row │ a
     │ Int64
─────┼───────
   1 │     1
   2 │     2
   3 │     3
   4 │     4</pre><p>It is slightly more tricky to make this approach work with other table types such as <a href="https://github.com/JuliaArrays/StructArrays.jl"><code>StructArrays</code></a> and <a href="https://github.com/JuliaData/TypedTables.jl"><code>TypedTables</code></a>.  Use <a href="../../reference/manual/#Transducers.tcopy"><code>tcopy</code></a> or <a href="../../reference/manual/#Transducers.dcopy"><code>dcopy</code></a> to work with generic containers.</p><h2 id="Example:-ad-hoc-histogram"><a class="docs-heading-anchor" href="#Example:-ad-hoc-histogram">Example: ad-hoc histogram</a><a id="Example:-ad-hoc-histogram-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-ad-hoc-histogram" title="Permalink"></a></h2><p>Following example counts number of occurrence of each leading digit in a distribution of random numbers.  First, let&#39;s create &quot;singleton solutions&quot; using transducers:</p><pre><code class="language-julia">xs = 1_000_000 * randn(10_000_000)
dicts1 = xs |&gt; Map(abs) |&gt; Filter(x -&gt; x &gt; 1) |&gt; Map() do x
    y = digits(floor(Int, x))[end]
    Dict(y =&gt; 1)
end</code></pre><p>The singleton solutions can be merged using <code>mergewith!(+, a, b)</code>. Conveniently, <code>mergewith!(+)</code> is the curried form <code>(args...) -&gt; mergewith!(+, args...)</code>:</p><pre><code class="language-julia">using Compat: mergewith!  # not required in Julia &gt;= 1.5
rf! = mergewith!(+)
rf!(Dict(:a =&gt; 1, :b =&gt; 2), Dict(:b =&gt; 3, :c =&gt; 4))</code></pre><pre class="documenter-example-output">Dict{Symbol, Int64} with 3 entries:
  :a =&gt; 1
  :b =&gt; 5
  :c =&gt; 4</pre><p>This is the form of binary function appropriate for <code>foldl</code> and <code>foldxt</code>.</p><p>Note that it is OK to use in-place function <code>mergewith!</code> here because the dictionary passed as <code>a</code> is created by <code>Dict(y =&gt; 1)</code> and not shared by anyone.  When there is no such guarantee, passing <a href="../../reference/manual/#Transducers.OnInit"><code>init = OnInit(Dict{Int,Int})</code></a> is a good option.  Note that passing <code>init = Dict{Int,Int}()</code> to <code>foldxt</code> is not correct as multiple tasks would share and try to mutate the same dictionary this way.</p><p>Let&#39;s try this with parallel <code>foldxt</code>:</p><pre><code class="language-julia">counts1 = foldxt(mergewith!(+), dicts1)</code></pre><p>Compare the result with <code>foldl</code>:</p><pre><code class="language-julia">counts2 = foldl(mergewith!(+), dicts1)
@assert counts1 == counts2</code></pre><p>Hopefully the result is close to the <a href="https://en.wikipedia.org/wiki/Benford%27s_law">Benford&#39;s law - Wikipedia</a>:</p><pre><code class="language-julia">let n = sum(values(counts1))
    sort!(keys(counts1) .=&gt; values(counts1) ./ n)
end</code></pre><pre class="documenter-example-output">9-element Vector{Pair{Int64, Float64}}:
 1 =&gt; 0.3594709594709595
 2 =&gt; 0.12891542891542893
 3 =&gt; 0.0865062865062865
 4 =&gt; 0.08103318103318104
 5 =&gt; 0.07736777736777736
 6 =&gt; 0.07341727341727342
 7 =&gt; 0.06906966906966908
 8 =&gt; 0.06452776452776453
 9 =&gt; 0.05969165969165969</pre><p>Since we are counting only nine elements, it is actually better to use fixed-size container such as a tuple in this case:</p><pre><code class="language-julia">dicts2 = xs |&gt; Map(abs) |&gt; Filter(x -&gt; x &gt; 1) |&gt; Map() do x
    y = digits(floor(Int, x))[end]
    ntuple(i -&gt; i == y, 9)
end

counts3 = foldxt(dicts2; init=ntuple(_ -&gt; 0, 9)) do a, b
    map(+, a, b)
end
@assert Dict(zip(1:9, counts3)) == counts1</code></pre><p>Note that, as tuples are immutable, it is valid to pass it as <code>init</code> of <code>foldxt</code>.</p><h3 id="MicroCollections.jl-for-efficient-singleton-solution"><a class="docs-heading-anchor" href="#MicroCollections.jl-for-efficient-singleton-solution">MicroCollections.jl for efficient singleton solution</a><a id="MicroCollections.jl-for-efficient-singleton-solution-1"></a><a class="docs-heading-anchor-permalink" href="#MicroCollections.jl-for-efficient-singleton-solution" title="Permalink"></a></h3><p>When the appropriate &quot;bins&quot; are not known, <code>mergewith!(+)</code>-based strategy is more appropriate.  However, it is not ideal to allocate a small container like <code>Dict(y =&gt; 1)</code> in the heap for each iteration. <a href="https://github.com/JuliaFolds/MicroCollections.jl">MicroCollections.jl</a> provides singleton (and empty) containers that are designed for this usecase.  The <code>SingletonDict</code> is &quot;upcast&quot; to the mutable <code>Dict</code> in the first invocation when merged with BangBang.jl functions:</p><pre><code class="language-julia">using BangBang: mergewith!!
using MicroCollections: SingletonDict

acc1 = mergewith!!(+, SingletonDict(:a =&gt; 1), SingletonDict(:b =&gt; 1))</code></pre><pre class="documenter-example-output">Dict(:a =&gt; 1, :b =&gt; 1)</pre><p>This dictionary is reused in the subsequent iterations:</p><pre><code class="language-julia">acc2 = mergewith!!(+, acc1, SingletonDict(:b =&gt; 1))</code></pre><pre class="documenter-example-output">Dict(:a =&gt; 1, :b =&gt; 2)</pre><pre><code class="language-julia">acc3 = mergewith!!(+, acc2, SingletonDict(:c =&gt; 1))</code></pre><pre class="documenter-example-output">Dict(:a =&gt; 1, :b =&gt; 2, :c =&gt; 1)</pre><p>The first result is reused across these iterations (within a single thread).</p><pre><code class="language-julia">@assert acc1 === acc2 === acc3</code></pre><p>Finally, <code>Dict</code>s from different threads are merged using the same function <code>mergewith!!(+)</code>:</p><pre><code class="language-julia">acc4 = Dict(:a =&gt; 5, :c =&gt; 3)  # from different thread
acc5 = mergewith!!(+, acc3, acc4)</code></pre><pre class="documenter-example-output">Dict(:a =&gt; 6, :b =&gt; 2, :c =&gt; 4)</pre><p>Thus, <code>dicts1</code> can be optimized simply by replacing <code>Dict(y =&gt; 1)</code> with <code>SingletonDict(y =&gt; 1)</code>:</p><pre><code class="language-julia">dicts3 = xs |&gt; Map(abs) |&gt; Filter(x -&gt; x &gt; 1) |&gt; Map() do x
    y = digits(floor(Int, x))[end]
    SingletonDict(y =&gt; 1)
end

counts4 = foldxt(mergewith!!(+), dicts3)
@assert counts1 == counts4</code></pre><h2 id="Example:-early-termination"><a class="docs-heading-anchor" href="#Example:-early-termination">Example: early termination</a><a id="Example:-early-termination-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-early-termination" title="Permalink"></a></h2><p>Find the <em>first</em> element that is multiple of three:</p><pre><code class="language-julia">foldxt(ReduceIf(x -&gt; x % 3 == 0), 1:10; init = nothing, basesize = 1) do _, x
    # # Uncomment for demo:
    # x == 3 ? sleep(0.1) : @show x  # give other tasks a chance to finish first
    return x
end</code></pre><pre class="documenter-example-output">3</pre><p>This snippet always returns <code>3</code>, even though the reductions for <code>c = 6</code> and <code>c = 9</code> may finish first.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial_missings/">« Tutorial: Missing values</a><a class="docs-footer-nextpage" href="../words/">Parallel word count »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 21 April 2021 23:48">Wednesday 21 April 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
