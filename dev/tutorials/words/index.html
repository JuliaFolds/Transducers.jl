<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Parallel word count · Transducers.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Transducers.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../../reference/manual/">Manual</a></li><li><a class="tocitem" href="../../reference/interface/">Interface</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorial_missings/">Tutorial: Missing values</a></li><li><a class="tocitem" href="../tutorial_parallel/">Tutorial: Parallelism</a></li><li class="is-active"><a class="tocitem" href>Parallel word count</a><ul class="internal"><li><a class="tocitem" href="#String-splitting-transducer"><span>String-splitting transducer</span></a></li><li><a class="tocitem" href="#Word-counting-transducer"><span>Word-counting transducer</span></a></li></ul></li></ul></li><li><span class="tocitem">How-to guides</span><ul><li><a class="tocitem" href="../../howto/upgrade-to-ixf/">Upgrade to new <code>|&gt;</code> of Transducers.jl 0.4.39</a></li><li><a class="tocitem" href="../../howto/empty_result_handling/">Empty result handling</a></li><li><a class="tocitem" href="../../howto/transducers/">Writing transducers</a></li><li><a class="tocitem" href="../../howto/reducibles/">Writing reducibles</a></li><li><a class="tocitem" href="../../howto/useful_patterns/">Useful patterns</a></li></ul></li><li><span class="tocitem">Explanation</span><ul><li><a class="tocitem" href="../../parallelism/">Parallelism</a></li><li><a class="tocitem" href="../../explanation/comparison_to_iterators/">Comparison to iterators</a></li><li><a class="tocitem" href="../../explanation/glossary/">Glossary</a></li><li><a class="tocitem" href="../../explanation/state_machines/">State machines</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Parallel word count</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Parallel word count</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaFolds/Transducers.jl/blob/master/examples/words.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="parallel-word-count"><a class="docs-heading-anchor" href="#parallel-word-count">Splitting a string into words and counting them in parallel</a><a id="parallel-word-count-1"></a><a class="docs-heading-anchor-permalink" href="#parallel-word-count" title="Permalink"></a></h1><p>We start from the parallel algorithm presented in Guy Steele&#39;s 2009 ICFP talk <a href="https://vimeo.com/6624203">(video)</a>.  It splits a space-separated string into list of strings (words).  The repeating theme in the talk was to build &quot;singleton solutions&quot; and then merge them together using an associative function.  We will follow this guideline and slightly extend the algorithm.</p><p>It is highly recommended to just watch the talk for understanding the algorithm.  However, we briefly describe how it works.</p><p>When a certain contiguous region of a string is processed, we either already have seen at least one space or not.  These two states are tracked using following two types.  If there is no space so far, we only have a chunk of a possibly larger word (see example below):</p><pre><code class="language-julia">struct Chunk
    s::String
end</code></pre><p>If there are one or more spaces, (possibly zero) words that are already determined and left/right &quot;chunks&quot; have to be tracked separately:</p><pre><code class="language-julia">struct Segment
    l::String
    A::Vector{String}
    r::String
end</code></pre><p>Here is an example taken from the talk:</p><pre><code class="language-none">Segment(&quot;Here&quot;, [&quot;is&quot;, &quot;a&quot;], &quot;&quot;)
   |
   |       Segment(&quot;lian&quot;, [], &quot;string&quot;)
 __|_____            _|______
|        |          |        |
Here is a sesquipedalian string of words
          |________|          |________|
   Chunk(&quot;sesquipeda&quot;)        Segment(&quot;g&quot;, [&quot;of&quot;], &quot;words&quot;)</code></pre><p>We then need a way to merge two results which can independently in one of the above two states.</p><pre><code class="language-julia">⊕(x::Chunk, y::Chunk) = Chunk(x.s * y.s)
⊕(x::Chunk, y::Segment) = Segment(x.s * y.l, y.A, y.r)
⊕(x::Segment, y::Chunk) = Segment(x.l, x.A, x.r * y.s)
⊕(x::Segment, y::Segment) =
    Segment(x.l,
            append!(append!(x.A, maybewordv(x.r * y.l)), y.A),
            y.r)

maybewordv(s::String) = isempty(s) ? String[] : [s]</code></pre><p>Input is a sequence of <code>Char</code>s.  Each of them has to be converted into a &quot;singleton solution&quot; which can be merged with already aggregated (or another singleton) solution with <code>⊕</code>:</p><pre><code class="language-julia">segment_or_chunk(c::Char) = c == &#39; &#39; ? Segment(&quot;&quot;, [], &quot;&quot;) : Chunk(string(c))</code></pre><p>Putting them together, we get:</p><pre><code class="language-julia">function collectwords(s::String)
    g = mapfoldl(segment_or_chunk, ⊕, s; init=Segment(&quot;&quot;, [], &quot;&quot;))
    if g isa Char
        return maybewordv(g.s)
    else
        return append!(append!(maybewordv(g.l), g.A), maybewordv(g.r))
    end
end</code></pre><p>Let&#39;s run a few tests covering some edge cases:</p><pre><code class="language-julia">using Test
@testset begin
    @test collectwords(&quot;This is a sample&quot;) == [&quot;This&quot;, &quot;is&quot;, &quot;a&quot;, &quot;sample&quot;]
    @test collectwords(&quot; Here is another sample &quot;) == [&quot;Here&quot;, &quot;is&quot;, &quot;another&quot;, &quot;sample&quot;]
    @test collectwords(&quot;JustOneWord&quot;) == [&quot;JustOneWord&quot;]
    @test collectwords(&quot; &quot;) == []
    @test collectwords(&quot;&quot;) == []
end</code></pre><pre class="documenter-example-output">Test Summary: | Pass  Total
test set      |    5      5</pre><h2 id="String-splitting-transducer"><a class="docs-heading-anchor" href="#String-splitting-transducer">String-splitting transducer</a><a id="String-splitting-transducer-1"></a><a class="docs-heading-anchor-permalink" href="#String-splitting-transducer" title="Permalink"></a></h2><p>Let&#39;s make it re-usable by packaging it into a transducer.</p><p>Rather than accumulating words into a vector, we are going to write a transducer that &quot;emits&quot; a word as soon as it is ready.  The downstream transducer may choose to record everything or only aggregate, e.g., reduced statistics.  To this end, we replace <code>Segment</code> in the original algorithm with</p><pre><code class="language-julia">struct Vacant
    l::String
    r::String
end</code></pre><p>and output the words in the &quot;middle&quot; without accumulating it.  So, instead of <code>segment_or_chunk</code>, we now have:</p><pre><code class="language-julia">vacant_or_chunk(c::Char) = c == &#39; &#39; ? Vacant(&quot;&quot;, &quot;&quot;) : Chunk(string(c))</code></pre><p>The idea is to create a custom transducer <code>WordsXF</code> that is used as in</p><pre><code class="language-julia">... |&gt; Map(vacant_or_chunk) |&gt; WordsXF() |&gt; Filter(!isnothing) |&gt; ...</code></pre><p>so that the whole transducer streams non-empty words to the downstream.  That is to say, the input stream is first processed by <code>vacant_or_chunk</code> which returns either a <code>Vacant</code> or a <code>Chunk</code>. This is processed by <code>WordsXF()</code> which outputs either a word (a <code>String</code>) or <code>nothing</code>.  We are using <code>Filter(!isnothing)</code> in the downstream to simplify the definition of <code>WordsXF</code>.</p><p>We define a function <code>extract(x::Union{Chunk,Vacant}, y::Union{Chunk,Vacant}) -&gt; (output, state)</code>.  It is something like <code>⊕</code> but works with <code>Chunk</code> and <code>Vacant</code>:</p><pre><code class="language-julia">extract(x::Chunk, y::Chunk) = nothing, Chunk(x.s * y.s)
extract(x::Chunk, y::Vacant) = nothing, Vacant(x.s * y.l, y.r)
extract(x::Vacant, y::Chunk) = nothing, Vacant(x.l, x.r * y.s)
extract(x::Vacant, y::Vacant) = maybeword(x.r * y.l), Vacant(x.l, y.r)

maybeword(s) = isempty(s) ? nothing : s</code></pre><p>Let&#39;s wrap this in a <a href="../../reference/manual/#Transducers.Transducer"><code>Transducer</code></a>.</p><pre><code class="language-julia">using Transducers
using Transducers:
    @next, R_, Transducer, combine, complete, inner, next, start, unwrap, wrap, wrapping</code></pre><p>First, we declare a transducer type:</p><pre><code class="language-julia">struct WordsXF &lt;: Transducer end</code></pre><p>Since this transducer has to keep &quot;unfinished&quot; words as its own private state, we use <a href="../../reference/interface/#Transducers.wrap"><code>wrap</code></a> inside <a href="../../reference/interface/#Transducers.start"><code>start</code></a> to prepare the state for it:</p><pre><code class="language-julia">Transducers.start(rf::R_{WordsXF}, init) = wrap(rf, Chunk(&quot;&quot;), start(inner(rf), init))</code></pre><p>Inside of <a href="../../reference/interface/#Transducers.complete"><code>next</code></a> (i.e., &quot;loop body&quot;) we call <code>extract</code> defined above to combine the input <code>x::Union{Chunk,Vacant}</code> into <code>state::Union{Chunk,Vacant}</code>.  If <code>extract</code> returns a word, it is passed to the inner reducing function:</p><pre><code class="language-julia">function Transducers.next(rf::R_{WordsXF}, acc, x)
    wrapping(rf, acc) do state, iacc
        word, state = extract(state, x)
        iacc = next(inner(rf), iacc, word)
        return state, iacc
    end
end</code></pre><p>At the end of a fold, <a href="../../reference/interface/#Transducers.complete"><code>complete</code></a> is called.  We can process unfinished words at this stage.  Note that we need to use <a href="../../reference/interface/#Transducers.combine"><code>combine</code></a> of the inner reducing function (assuming it is associative) to &quot;prepend&quot; a word to the accumulated state of the inner reducing function.</p><pre><code class="language-julia">function Transducers.complete(rf::R_{WordsXF}, acc)
    state, iacc = unwrap(rf, acc)
    if state isa Vacant
        pre = @next(inner(rf), start(inner(rf), Init), maybeword(state.l))
        iacc = combine(inner(rf), pre, iacc)  # prepending `state.l`
        iacc = @next(inner(rf), iacc, maybeword(state.r))  # appending `state.r`
    else
        @assert state isa Chunk
        iacc = @next(inner(rf), iacc, maybeword(state.s))
    end
    return complete(inner(rf), iacc)
end</code></pre><p>That&#39;s all we need for using this transducer with sequential folds. For parallel reduce we need <a href="../../reference/interface/#Transducers.combine"><code>combine</code></a>. It is more or less identical to <code>next</code>:</p><pre><code class="language-julia">function Transducers.combine(rf::R_{WordsXF}, a, b)
    ua, ira = unwrap(rf, a)
    ub, irb = unwrap(rf, b)
    word, uc = extract(ua, ub)
    ira = @next(inner(rf), ira, word)
    irc = combine(inner(rf), ira, irb)
    return wrap(rf, uc, irc)
end

wordsxf = opcompose(Map(vacant_or_chunk), WordsXF(), Filter(!isnothing))</code></pre><p>Test:</p><pre><code class="language-julia">@testset begin
    @test collect(wordsxf, &quot;This is a sample&quot;) == [&quot;This&quot;, &quot;is&quot;, &quot;a&quot;, &quot;sample&quot;]
    @test collect(wordsxf, &quot; Here is another sample &quot;) == [&quot;Here&quot;, &quot;is&quot;, &quot;another&quot;, &quot;sample&quot;]
    @test collect(wordsxf, &quot;JustOneWord&quot;) == [&quot;JustOneWord&quot;]
    @test collect(wordsxf, &quot; &quot;) == []
    @test collect(wordsxf, &quot;&quot;) == []
end</code></pre><pre class="documenter-example-output">Test Summary: | Pass  Total
test set      |    5      5</pre><h2 id="Word-counting-transducer"><a class="docs-heading-anchor" href="#Word-counting-transducer">Word-counting transducer</a><a id="Word-counting-transducer-1"></a><a class="docs-heading-anchor-permalink" href="#Word-counting-transducer" title="Permalink"></a></h2><p>We can pipe the resulting words into various transducers.</p><pre><code class="language-julia">using MicroCollections: SingletonDict

processcount(word) = SingletonDict(word =&gt; 1)
countxf = opcompose(wordsxf, Map(processcount))</code></pre><pre class="documenter-example-output">Map(vacant_or_chunk) ⨟
    WordsXF() ⨟
    Filter(Base.λ❓) ⨟
    Map(processcount)</pre><p>Transducer <code>countxf</code> constructs a &quot;singleton solution&quot; as a dictionary which then accumulated with the associative reducing step function <code>mergewith!!(+)</code> from BangBang.jl:</p><pre><code class="language-julia">using BangBang: mergewith!!</code></pre><p>Putting the transducer and reducing function together, we get:</p><pre><code class="language-julia">countwords(s; kwargs...) =
    foldxt(mergewith!!(+), countxf, s; init = CopyInit(Dict{String,Int}()), kwargs...)</code></pre><p>Side note: We use <a href="../../reference/manual/#Transducers.CopyInit"><code>CopyInit</code></a> to create a fresh initial state for each sub-reduce to avoid overwriting mutable data between threads.</p><p>Let&#39;s run some tests with different <code>basesize</code> (<code>length(s) / basesize</code> corresponds to number of tasks to be used):</p><pre><code class="language-julia">@testset for basesize in [1, 2, 4]
    @test countwords(&quot;This is a sample&quot;, basesize=basesize) ==
        Dict(&quot;This&quot; =&gt; 1, &quot;is&quot; =&gt; 1, &quot;a&quot; =&gt; 1, &quot;sample&quot; =&gt; 1)
    @test countwords(&quot; Here is another sample &quot;, basesize=basesize) ==
        Dict(&quot;Here&quot; =&gt; 1, &quot;is&quot; =&gt; 1, &quot;another&quot; =&gt; 1, &quot;sample&quot; =&gt; 1)
    @test countwords(&quot;JustOneWord&quot;, basesize=basesize) ==
        Dict(&quot;JustOneWord&quot; =&gt; 1)
    @test countwords(&quot; &quot;, basesize=basesize) == Dict()
    @test countwords(&quot;&quot;, basesize=basesize) == Dict()
    @test countwords(&quot;aaa bb aaa aaa bb bb aaa&quot;, basesize=basesize) ==
        Dict(&quot;aaa&quot; =&gt; 4, &quot;bb&quot; =&gt; 3)
    @test countwords(&quot;あああ いい あああ あああ いい いい あああ&quot;, basesize=basesize) ==
        Dict(&quot;あああ&quot; =&gt; 4, &quot;いい&quot; =&gt; 3)
end</code></pre><pre class="documenter-example-output">Test Summary: | Pass  Total
basesize = 1  |    7      7
Test Summary: | Pass  Total
basesize = 2  |    7      7
Test Summary: | Pass  Total
basesize = 4  |    7      7</pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial_parallel/">« Tutorial: Parallelism</a><a class="docs-footer-nextpage" href="../../howto/upgrade-to-ixf/">Upgrade to new <code>|&gt;</code> of Transducers.jl 0.4.39 »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 21 April 2021 07:02">Wednesday 21 April 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
