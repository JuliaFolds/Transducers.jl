<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Manual · Transducers.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Transducers.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li class="current"><a class="toctext" href>Manual</a><ul class="internal"><li><a class="toctext" href="#Transducer-contexts-1">Transducer contexts</a></li><li><a class="toctext" href="#Transducers-1">Transducers</a></li><li><a class="toctext" href="#Miscellaneous-1">Miscellaneous</a></li></ul></li><li><a class="toctext" href="../interface/">Interface</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Manual</a></li></ul><a class="edit-page" href="https://github.com/tkf/Transducers.jl/blob/master/docs/src/manual.md#L"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Manual</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Transducers-and-Transducer-contexts-1" href="#Transducers-and-Transducer-contexts-1">Transducers and Transducer contexts</a></h1><ul><li><a href="#Base.append!"><code>Base.append!</code></a></li><li><a href="#Base.collect"><code>Base.collect</code></a></li><li><a href="#Base.copy!"><code>Base.copy!</code></a></li><li><a href="#Base.map!"><code>Base.map!</code></a></li><li><a href="#Base.mapfoldl"><code>Base.mapfoldl</code></a></li><li><a href="#Transducers.eduction"><code>Transducers.eduction</code></a></li><li><a href="#Transducers.loop"><code>Transducers.loop</code></a></li><li><a href="#Transducers.transduce"><code>Transducers.transduce</code></a></li><li><a href="#Transducers.Cat"><code>Transducers.Cat</code></a></li><li><a href="#Transducers.Completing"><code>Transducers.Completing</code></a></li><li><a href="#Transducers.Dedupe"><code>Transducers.Dedupe</code></a></li><li><a href="#Transducers.Distinct"><code>Transducers.Distinct</code></a></li><li><a href="#Transducers.Drop"><code>Transducers.Drop</code></a></li><li><a href="#Transducers.DropLast"><code>Transducers.DropLast</code></a></li><li><a href="#Transducers.DropWhile"><code>Transducers.DropWhile</code></a></li><li><a href="#Transducers.Filter"><code>Transducers.Filter</code></a></li><li><a href="#Transducers.GetIndex"><code>Transducers.GetIndex</code></a></li><li><a href="#Transducers.Interpose"><code>Transducers.Interpose</code></a></li><li><a href="#Transducers.Keep"><code>Transducers.Keep</code></a></li><li><a href="#Transducers.Map"><code>Transducers.Map</code></a></li><li><a href="#Transducers.MapCat"><code>Transducers.MapCat</code></a></li><li><a href="#Transducers.PartitionBy"><code>Transducers.PartitionBy</code></a></li><li><a href="#Transducers.Replace"><code>Transducers.Replace</code></a></li><li><a href="#Transducers.Scan"><code>Transducers.Scan</code></a></li><li><a href="#Transducers.SetIndex"><code>Transducers.SetIndex</code></a></li><li><a href="#Transducers.Take"><code>Transducers.Take</code></a></li><li><a href="#Transducers.TakeNth"><code>Transducers.TakeNth</code></a></li><li><a href="#Transducers.TakeWhile"><code>Transducers.TakeWhile</code></a></li><li><a href="#Transducers.TeeZip"><code>Transducers.TeeZip</code></a></li><li><a href="#Transducers.Window"><code>Transducers.Window</code></a></li></ul><h2><a class="nav-anchor" id="Transducer-contexts-1" href="#Transducer-contexts-1">Transducer contexts</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.mapfoldl" href="#Base.mapfoldl"><code>Base.mapfoldl</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mapfoldl(xf, step, init, itr) :: T
transduce(xf, step, init, itr) :: Union{T, Reduced{T}}</code></pre><p>Compose transducer <code>xf</code> with reducing step function <code>step</code> and reduce <code>itr</code> using it.</p><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p><code>transduce</code> differs from <code>mapfoldl</code> as <code>Reduced{T}</code> is returned if the transducer <code>xf</code> or <code>step</code> aborts the reduction.</p></div></div><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/transduce"><code>transduce</code> in Clojure</a>.</p><p><strong>Arguments</strong></p><ul><li><code>xf::Transducer</code>: A transducer.</li><li><code>step</code>: A callable which accepts 1 and 2 arguments.  If it only accepts 2 arguments, wrap it by <a href="#Transducers.Completing"><code>Completing</code></a> to add <a href="../interface/#Transducers.complete"><code>complete</code></a> protocol.</li><li><code>init</code>: An initial value fed to the first argument to reducing step function <code>step</code>.</li><li><code>itr</code>: An iterable.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; function step_demo(state, input)
           @show state, input
           state + input
       end;

julia&gt; function step_demo(state)
           println(&quot;Finishing with state = &quot;, state)
           state
       end;

julia&gt; mapfoldl(Filter(isodd), step_demo, 0.0, 1:4)
(state, input) = (0.0, 1)
(state, input) = (1.0, 3)
Finishing with state = 4.0
4.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/cf022153885234294a31fb835ac4cb4976ed9ebc/src/contexts.jl#LL57-L99">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.transduce" href="#Transducers.transduce"><code>Transducers.transduce</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mapfoldl(xf, step, init, itr) :: T
transduce(xf, step, init, itr) :: Union{T, Reduced{T}}</code></pre><p>See <a href="#Base.mapfoldl"><code>mapfoldl</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/cf022153885234294a31fb835ac4cb4976ed9ebc/src/contexts.jl#LL102-L107">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.loop" href="#Transducers.loop"><code>Transducers.loop</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">loop(step, xf, init, coll)</code></pre><p>This is a shorthand for <code>transduce(Completing(step), xf, init, coll)</code>. It is intended to be used with <code>do</code> block.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; loop(Filter(isodd), 0.0, 1:4) do state, input
           @show state, input
           state + input
       end
(state, input) = (0.0, 1)
(state, input) = (1.0, 3)
4.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/cf022153885234294a31fb835ac4cb4976ed9ebc/src/contexts.jl#LL335-L353">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.eduction" href="#Transducers.eduction"><code>Transducers.eduction</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">eduction(xf::Transducer, coll)</code></pre><p>Create a iterable and reducible object.</p><ul><li><a href="https://docs.julialang.org/en/v1/manual/interfaces/#man-interface-iteration-1">Iterable</a>.</li><li>Reducible (TODO); i.e., it can be handled by <a href="#Transducers.transduce"><code>transduce</code></a> efficiently.</li></ul><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/eduction"><code>eduction</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; for x in eduction(Filter(isodd) |&gt; Take(3), 1:1000)
           @show x
       end
x = 1
x = 3
x = 5</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/cf022153885234294a31fb835ac4cb4976ed9ebc/src/contexts.jl#LL179-L200">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.map!" href="#Base.map!"><code>Base.map!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">map!(xf::Transducer, dest, src)</code></pre><p>Feed <code>src</code> to transducer <code>xf</code>, storing the result in <code>dest</code>. Collections <code>dest</code> and <code>src</code> must have the same shape.  Transducer <code>xf</code> may contain filtering transducers.  If some entries <code>src</code> are skipped, the corresponding entries in <code>dest</code> will be unchanged. Transducer <code>xf</code> must not contain any expansive transducers such as <a href="#Transducers.MapCat"><code>MapCat</code></a>.</p><p>See also <a href="#Base.copy!"><code>copy!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; xs = collect(1:5)
       ys = zero(xs)
       map!(Filter(isodd), ys, xs)
5-element Array{Int64,1}:
 1
 0
 3
 0
 5

julia&gt; ans === ys
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/cf022153885234294a31fb835ac4cb4976ed9ebc/src/contexts.jl#LL251-L280">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.copy!" href="#Base.copy!"><code>Base.copy!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">copy!(xf::Transducer, dest, src)</code></pre><p>Feed <code>src</code> to transducer <code>xf</code>, storing the result in <code>dest</code>. Collections <code>dest</code> and <code>src</code> may have the same shape.  Source <code>src</code> must be iterable.  Destination <code>dest</code> must implement <code>empty!</code> and <code>push!</code>.</p><p>See also <a href="#Base.map!"><code>map!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; copy!(PartitionBy(x -&gt; x ÷ 3) |&gt; Map(sum), Int[], 1:10)
4-element Array{Int64,1}:
  3
 12
 21
 19</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/cf022153885234294a31fb835ac4cb4976ed9ebc/src/contexts.jl#LL311-L332">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.append!" href="#Base.append!"><code>Base.append!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">append!(xf::Transducer, dest, src)</code></pre><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/into"><code>into</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; append!(Drop(2), [-1, -2], 1:5)
5-element Array{Int64,1}:
 -1
 -2
  3
  4
  5</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/cf022153885234294a31fb835ac4cb4976ed9ebc/src/contexts.jl#LL205-L222">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.collect" href="#Base.collect"><code>Base.collect</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">collect(xf::Transducer, itr)</code></pre><p>Process an iterable <code>itr</code> using a transducer <code>xf</code> and collect the result into a <code>Vector</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(Interpose(missing), 1:3)
5-element Array{Union{Missing, Int64},1}:
 1
  missing
 2
  missing
 3</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/cf022153885234294a31fb835ac4cb4976ed9ebc/src/contexts.jl#LL225-L243">source</a></section><h2><a class="nav-anchor" id="Transducers-1" href="#Transducers-1">Transducers</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.Cat" href="#Transducers.Cat"><code>Transducers.Cat</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Cat()</code></pre><p>Concatenate/flatten nested iterators.</p><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/cat"><code>cat</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(Cat(), [[1, 2], [3], [4, 5]]) == 1:5
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/cf022153885234294a31fb835ac4cb4976ed9ebc/src/library.jl#LL67-L81">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.Dedupe" href="#Transducers.Dedupe"><code>Transducers.Dedupe</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Dedupe()</code></pre><p>De-duplicate <em>consecutive</em> items.</p><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/dedupe"><code>dedupe</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(Dedupe(), [1, 1, 2, 1, 3, 3, 2])
5-element Array{Int64,1}:
 1
 2
 1
 3
 2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/cf022153885234294a31fb835ac4cb4976ed9ebc/src/library.jl#LL666-L685">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.Distinct" href="#Transducers.Distinct"><code>Transducers.Distinct</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Distinct()</code></pre><p>Pass only unseen item to the inner reducing step.</p><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/distinct"><code>distinct</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(Distinct(), [1, 1, 2, 1, 3, 3, 2])
3-element Array{Int64,1}:
 1
 2
 3</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/cf022153885234294a31fb835ac4cb4976ed9ebc/src/library.jl#LL589-L606">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.Drop" href="#Transducers.Drop"><code>Transducers.Drop</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Drop(n)</code></pre><p>Drop first <code>n</code> items.</p><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/drop"><code>drop</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(Drop(3), 1:5)
2-element Array{Int64,1}:
 4
 5</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/cf022153885234294a31fb835ac4cb4976ed9ebc/src/library.jl#LL243-L259">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.DropLast" href="#Transducers.DropLast"><code>Transducers.DropLast</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">DropLast(n)</code></pre><p>Drop last <code>n</code> items.</p><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/drop-last"><code>drop-last</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(DropLast(2), 1:5)
3-element Array{Int64,1}:
 1
 2
 3</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/cf022153885234294a31fb835ac4cb4976ed9ebc/src/library.jl#LL278-L295">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.DropWhile" href="#Transducers.DropWhile"><code>Transducers.DropWhile</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">DropWhile(pred)</code></pre><p>Drop items while <code>pred</code> returns <code>true</code> consecutively.  It becomes a no-op after <code>pred</code> returns a <code>false</code>.</p><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/drop-while"><code>drop-while</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(DropWhile(x -&gt; x &lt; 3), [1:5; 1:2])
5-element Array{Int64,1}:
 3
 4
 5
 1
 2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/cf022153885234294a31fb835ac4cb4976ed9ebc/src/library.jl#LL332-L352">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.Filter" href="#Transducers.Filter"><code>Transducers.Filter</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Filter(pred)</code></pre><p>Skip items for which <code>pred</code> is evaluated to <code>false</code>.</p><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/filter"><code>filter</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(Filter(iseven), 1:3)
1-element Array{Int64,1}:
 2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/cf022153885234294a31fb835ac4cb4976ed9ebc/src/library.jl#LL117-L132">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.GetIndex" href="#Transducers.GetIndex"><code>Transducers.GetIndex</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">GetIndex(array)
GetIndex{inbounds}(array)</code></pre><p>Transform an integer input <code>i</code> to <code>array[i]</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(GetIndex(1:10), [2, 3, 4])
3-element Array{Int64,1}:
 2
 3
 4

julia&gt; collect(GetIndex{true}(1:10), [2, 3, 4])
3-element Array{Int64,1}:
 2
 3
 4</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/cf022153885234294a31fb835ac4cb4976ed9ebc/src/library.jl#LL845-L867">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.Interpose" href="#Transducers.Interpose"><code>Transducers.Interpose</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Interpose(sep)</code></pre><p>Interleave input items with a <code>sep</code>.</p><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/interpose"><code>interpose</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(Interpose(missing), 1:3)
5-element Array{Union{Missing, Int64},1}:
 1
  missing
 2
  missing
 3</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/cf022153885234294a31fb835ac4cb4976ed9ebc/src/library.jl#LL628-L647">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.Keep" href="#Transducers.Keep"><code>Transducers.Keep</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Keep(f)</code></pre><p>Pass non-<code>nothing</code> output of <code>f</code> to the inner reducing step.</p><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/keep"><code>keep</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; xf = Keep() do x
           if x &lt; 3
               x + 1
           end
       end;

julia&gt; collect(xf, 1:5)
2-element Array{Int64,1}:
 2
 3</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/cf022153885234294a31fb835ac4cb4976ed9ebc/src/library.jl#LL551-L573">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.Map" href="#Transducers.Map"><code>Transducers.Map</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Map(f)</code></pre><p>Apply unary function <code>f</code> to each input and pass the result to the inner reducing step.</p><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/map"><code>map</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(Map(x -&gt; 2x), 1:3)
3-element Array{Int64,1}:
 2
 4
 6</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/cf022153885234294a31fb835ac4cb4976ed9ebc/src/library.jl#LL10-L28">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.MapCat" href="#Transducers.MapCat"><code>Transducers.MapCat</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">MapCat(f)</code></pre><p>Concatenate output of <code>f</code> which is expected to return an iterable.</p><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/mapcat"><code>mapcat</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(MapCat(x -&gt; 1:x), 1:3)
6-element Array{Int64,1}:
 1
 1
 2
 1
 2
 3</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/cf022153885234294a31fb835ac4cb4976ed9ebc/src/library.jl#LL90-L110">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.PartitionBy" href="#Transducers.PartitionBy"><code>Transducers.PartitionBy</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">PartitionBy(f)</code></pre><p>Group input sequence into chunks in which <code>f</code> returns a same value consecutively.</p><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>The vector passed to the inner reducing function is valid only during its <em>immediate</em> reduction step.  It must be reduced immediately <em>or</em> copied.</p></div></div><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/partition-by"><code>partition-by</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(PartitionBy(x -&gt; (x + 1) ÷ 3) |&gt; Map(copy), 1:9)
4-element Array{Array{Int64,1},1}:
 [1]
 [2, 3, 4]
 [5, 6, 7]
 [8, 9]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/cf022153885234294a31fb835ac4cb4976ed9ebc/src/library.jl#LL492-L513">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.Replace" href="#Transducers.Replace"><code>Transducers.Replace</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Replace(dict)</code></pre><p>Replace each input with the value in the dictionary <code>dict</code> if it matches with a key.  Otherwise output the input as-is.</p><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/replace"><code>replace</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(Replace(Dict(&#39;a&#39; =&gt; &#39;A&#39;)), &quot;abc&quot;)
3-element Array{Char,1}:
 &#39;A&#39;
 &#39;b&#39;
 &#39;c&#39;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/cf022153885234294a31fb835ac4cb4976ed9ebc/src/library.jl#LL38-L56">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.Scan" href="#Transducers.Scan"><code>Transducers.Scan</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Scan(f, [init])</code></pre><p>Accumulate input with binary function <code>f</code> and pass the accumulated result so far to the inner reduction step.</p><p>The inner reducing step receives the sequence <code>y₁, y₂, y₃, ..., yₙ, ...</code> when the sequence <code>x₁, x₂, x₃, ..., xₙ, ...</code> is fed to <code>Scan(f)</code>.</p><pre><code class="language-none">y₁ = f(x₁, init)
y₂ = f(x₂, y₁)
y₃ = f(x₃, y₂)
...
yₙ = f(xₙ, yₙ₋₁)</code></pre><p>This is a generalized version of the <a href="https://en.wikipedia.org/wiki/Prefix_sum"><em>prefix sum</em></a> also known as <em>cumulative sum</em>, <em>inclusive scan</em>, or <em>scan</em>.</p><p>Note that the associativity of <code>f</code> is not required when the transducer is used in a process that gurantee an order, such as <a href="#Base.mapfoldl"><code>mapfoldl</code></a>.</p><p>Unless <code>f</code> is a function with known identity element such as <code>+</code>, <code>*</code>, <code>min</code>, <code>max</code>, and <code>append!</code>, the initial state <code>init</code> must be provided.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(Scan(*), 1:3)
3-element Array{Int64,1}:
 1
 2
 6

julia&gt; collect(Map(x -&gt; x + im) |&gt; Scan(*), 1:3)
3-element Array{Complex{Int64},1}:
 1 + 1im
 1 + 3im
 0 + 10im

julia&gt; collect(Scan(*, 10), 1:3)
3-element Array{Int64,1}:
 10
 20
 60</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/cf022153885234294a31fb835ac4cb4976ed9ebc/src/library.jl#LL700-L748">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.SetIndex" href="#Transducers.SetIndex"><code>Transducers.SetIndex</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SetIndex(array)
SetIndex{inbounds}(array)</code></pre><p>Perform <code>array[i] = v</code> for each input pair <code>(i, v)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; ys = zeros(3);

julia&gt; mapfoldl(SetIndex(ys), first ∘ tuple, nothing, [(1, 11.1), (3, 33.3)])

julia&gt; ys
3-element Array{Float64,1}:
 11.1
  0.0
 33.3</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/cf022153885234294a31fb835ac4cb4976ed9ebc/src/library.jl#LL884-L904">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.Take" href="#Transducers.Take"><code>Transducers.Take</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Take(n)</code></pre><p>Take <code>n</code> items from the input sequence.</p><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/take"><code>take</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(Take(2), 1:10)
2-element Array{Int64,1}:
 1
 2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/cf022153885234294a31fb835ac4cb4976ed9ebc/src/library.jl#LL142-L158">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.TakeNth" href="#Transducers.TakeNth"><code>Transducers.TakeNth</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">TakeNth(n)</code></pre><p>Output every <code>n</code> item to the inner reducing step.</p><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/take-nth"><code>take-nth</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(TakeNth(3), 1:9)
3-element Array{Int64,1}:
 1
 4
 7</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/cf022153885234294a31fb835ac4cb4976ed9ebc/src/library.jl#LL206-L223">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.TakeWhile" href="#Transducers.TakeWhile"><code>Transducers.TakeWhile</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">TakeWhile(pred)</code></pre><p>Take items while <code>pred</code> returns <code>true</code>.  Abort the transducible process when <code>pred</code> returns <code>false</code> for the first time.</p><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/take-while"><code>take-while</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(TakeWhile(x -&gt; x &lt; 3), 1:10)
2-element Array{Int64,1}:
 1
 2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/cf022153885234294a31fb835ac4cb4976ed9ebc/src/library.jl#LL179-L196">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.TeeZip" href="#Transducers.TeeZip"><code>Transducers.TeeZip</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">TeeZip(xform::Transducer)</code></pre><p>Branch input into two &quot;flows&quot;, inject one into <code>xform</code> and then merge the output of <code>xform</code> with the original input.</p><p>To illustrate how it works, consider the following usage</p><pre><code class="language-none">xf0 |&gt; TeeZip(xf1) |&gt; xf2</code></pre><p>where <code>xf0</code>, <code>xf1</code>, and <code>xf2</code> are some transducers.  Schematically, the output <code>yn</code> from <code>xfn</code> flows as follows:</p><pre><code class="language-text">xf0      xf1                       xf2
---- y0 ------ y1 ---.-- (y0, y1) -----&gt;
      |              |
       `-------------&#39;
    &quot;Tee&quot;          &quot;Zip&quot;</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(TeeZip(Filter(isodd) |&gt; Map(x -&gt; x + 1)), 1:5)
3-element Array{Tuple{Int64,Int64},1}:
 (1, 2)
 (3, 4)
 (5, 6)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/cf022153885234294a31fb835ac4cb4976ed9ebc/src/library.jl#LL778-L811">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.Window" href="#Transducers.Window"><code>Transducers.Window</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Window(size, step = size, flush = false)
Window(size; step = size, flush = false)</code></pre><p>Sliding window of width <code>size</code> and interval <code>step</code>.</p><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>The vector passed to the inner reducing function is valid only during its <em>immediate</em> reduction step.  It must be reduced immediately <em>or</em> copied.</p></div></div><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/partition-all"><code>partition-all</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(Window(3) |&gt; Map(copy), 1:8)
2-element Array{Array{Int64,1},1}:
 [1, 2, 3]
 [4, 5, 6]

julia&gt; collect(Window(3; flush=true) |&gt; Map(copy), 1:8)
3-element Array{Array{Int64,1},1}:
 [1, 2, 3]
 [4, 5, 6]
 [7, 8]

julia&gt; collect(Window(3; step=1) |&gt; Map(copy), 1:8)
6-element Array{Array{Int64,1},1}:
 [1, 2, 3]
 [2, 3, 4]
 [3, 4, 5]
 [4, 5, 6]
 [5, 6, 7]
 [6, 7, 8]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/cf022153885234294a31fb835ac4cb4976ed9ebc/src/library.jl#LL370-L404">source</a></section><h2><a class="nav-anchor" id="Miscellaneous-1" href="#Miscellaneous-1">Miscellaneous</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.Completing" href="#Transducers.Completing"><code>Transducers.Completing</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Completing(function)</code></pre><p>Wrap a <code>function</code> to add a no-op <a href="../interface/#Transducers.complete"><code>complete</code></a> protocol.  Use it when passing a <code>function</code> without 1-argument arity to <a href="#Transducers.transduce"><code>transduce</code></a> etc.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/cf022153885234294a31fb835ac4cb4976ed9ebc/src/core.jl#LL187-L193">source</a></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../interface/"><span class="direction">Next</span><span class="title">Interface</span></a></footer></article></body></html>
