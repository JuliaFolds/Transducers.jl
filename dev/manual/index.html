<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Manual · Transducers.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Transducers.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li class="current"><a class="toctext" href>Manual</a><ul class="internal"><li><a class="toctext" href="#Transducible-processes-1">Transducible processes</a></li><li><a class="toctext" href="#Transducers-1">Transducers</a></li><li><a class="toctext" href="#Early-termination-1">Early termination</a></li><li><a class="toctext" href="#Miscellaneous-1">Miscellaneous</a></li></ul></li><li><a class="toctext" href="../interface/">Interface</a></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../examples/tutorial_missings/">Tutorial: Missing values</a></li><li><a class="toctext" href="../examples/empty_result_handling/">Empty result handling</a></li><li><a class="toctext" href="../examples/words/">Parallel word count</a></li><li><a class="toctext" href="../examples/transducers/">Writing transducers</a></li><li><a class="toctext" href="../examples/reducibles/">Writing reducibles</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Manual</a></li></ul><a class="edit-page" href="https://github.com/tkf/Transducers.jl/blob/master/docs/src/manual.md#L"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Manual</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Transducers-and-Transducible-processes-1" href="#Transducers-and-Transducible-processes-1">Transducers and Transducible processes</a></h1><ul><li><a href="#Base.append!"><code>Base.append!</code></a></li><li><a href="#Base.collect"><code>Base.collect</code></a></li><li><a href="#Base.copy!"><code>Base.copy!</code></a></li><li><a href="#Base.foldl"><code>Base.foldl</code></a></li><li><a href="#Base.foreach"><code>Base.foreach</code></a></li><li><a href="#Base.map!"><code>Base.map!</code></a></li><li><a href="#Base.mapfoldl"><code>Base.mapfoldl</code></a></li><li><a href="#Base.mapreduce"><code>Base.mapreduce</code></a></li><li><a href="#Base.reduce"><code>Base.reduce</code></a></li><li><a href="#Transducers.Zip-Tuple"><code>Transducers.Zip</code></a></li><li><a href="#Transducers.eduction"><code>Transducers.eduction</code></a></li><li><a href="#Transducers.ifunreduced"><code>Transducers.ifunreduced</code></a></li><li><a href="#Transducers.reduced"><code>Transducers.reduced</code></a></li><li><a href="#Transducers.reducingfunction"><code>Transducers.reducingfunction</code></a></li><li><a href="#Transducers.right"><code>Transducers.right</code></a></li><li><a href="#Transducers.setinput"><code>Transducers.setinput</code></a></li><li><a href="#Transducers.transduce"><code>Transducers.transduce</code></a></li><li><a href="#Transducers.unreduced"><code>Transducers.unreduced</code></a></li><li><a href="#Base.Channel"><code>Base.Channel</code></a></li><li><a href="#Transducers.AdHocFoldable"><code>Transducers.AdHocFoldable</code></a></li><li><a href="#Transducers.Cat"><code>Transducers.Cat</code></a></li><li><a href="#Transducers.Completing"><code>Transducers.Completing</code></a></li><li><a href="#Transducers.CopyInit"><code>Transducers.CopyInit</code></a></li><li><a href="#Transducers.Count"><code>Transducers.Count</code></a></li><li><a href="#Transducers.Dedupe"><code>Transducers.Dedupe</code></a></li><li><a href="#Transducers.Drop"><code>Transducers.Drop</code></a></li><li><a href="#Transducers.DropLast"><code>Transducers.DropLast</code></a></li><li><a href="#Transducers.DropWhile"><code>Transducers.DropWhile</code></a></li><li><a href="#Transducers.Enumerate"><code>Transducers.Enumerate</code></a></li><li><a href="#Transducers.Filter"><code>Transducers.Filter</code></a></li><li><a href="#Transducers.FlagFirst"><code>Transducers.FlagFirst</code></a></li><li><a href="#Transducers.GetIndex"><code>Transducers.GetIndex</code></a></li><li><a href="#Transducers.GroupBy"><code>Transducers.GroupBy</code></a></li><li><a href="#Transducers.Initializer"><code>Transducers.Initializer</code></a></li><li><a href="#Transducers.Inject"><code>Transducers.Inject</code></a></li><li><a href="#Transducers.Interpose"><code>Transducers.Interpose</code></a></li><li><a href="#Transducers.Iterated"><code>Transducers.Iterated</code></a></li><li><a href="#Transducers.Keep"><code>Transducers.Keep</code></a></li><li><a href="#Transducers.Map"><code>Transducers.Map</code></a></li><li><a href="#Transducers.MapCat"><code>Transducers.MapCat</code></a></li><li><a href="#Transducers.MapSplat"><code>Transducers.MapSplat</code></a></li><li><a href="#Transducers.NotA"><code>Transducers.NotA</code></a></li><li><a href="#Transducers.OfType"><code>Transducers.OfType</code></a></li><li><a href="#Transducers.OnInit"><code>Transducers.OnInit</code></a></li><li><a href="#Transducers.Partition"><code>Transducers.Partition</code></a></li><li><a href="#Transducers.PartitionBy"><code>Transducers.PartitionBy</code></a></li><li><a href="#Transducers.ReduceIf"><code>Transducers.ReduceIf</code></a></li><li><a href="#Transducers.Reduced"><code>Transducers.Reduced</code></a></li><li><a href="#Transducers.Replace"><code>Transducers.Replace</code></a></li><li><a href="#Transducers.Scan"><code>Transducers.Scan</code></a></li><li><a href="#Transducers.ScanEmit"><code>Transducers.ScanEmit</code></a></li><li><a href="#Transducers.SetIndex"><code>Transducers.SetIndex</code></a></li><li><a href="#Transducers.Take"><code>Transducers.Take</code></a></li><li><a href="#Transducers.TakeLast"><code>Transducers.TakeLast</code></a></li><li><a href="#Transducers.TakeNth"><code>Transducers.TakeNth</code></a></li><li><a href="#Transducers.TakeWhile"><code>Transducers.TakeWhile</code></a></li><li><a href="#Transducers.TeeZip"><code>Transducers.TeeZip</code></a></li><li><a href="#Transducers.Transducer-Tuple{OnlineStatsBase.OnlineStat}"><code>Transducers.Transducer</code></a></li><li><a href="#Transducers.Transducer-Tuple{Union{Generator, Filter, Flatten}}"><code>Transducers.Transducer</code></a></li><li><a href="#Transducers.Unique"><code>Transducers.Unique</code></a></li></ul><h2><a class="nav-anchor" id="Transducible-processes-1" href="#Transducible-processes-1">Transducible processes</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.mapfoldl" href="#Base.mapfoldl"><code>Base.mapfoldl</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">mapfoldl(xf, step, reducible; init, simd) :: T
transduce(xf, step, init, reducible; simd) :: Union{T, Reduced{T}}</code></pre><p>Compose transducer <code>xf</code> with reducing step function <code>step</code> and reduce <code>itr</code> using it.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p><code>transduce</code> differs from <code>mapfoldl</code> as <code>Reduced{T}</code> is returned if the transducer <code>xf</code> or <code>step</code> aborts the reduction.</p></div></div><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/transduce"><code>transduce</code> in Clojure</a>.</p><p><strong>Arguments</strong></p><ul><li><code>xf::Transducer</code>: A transducer.</li><li><code>step</code>: A callable which accepts 1 and 2 arguments.  If it only accepts 2 arguments, wrap it with <a href="#Transducers.Completing"><code>Completing</code></a> to &quot;add&quot; 1-argument form (i.e., <a href="../interface/#Transducers.complete"><code>complete</code></a> protocol).</li><li><code>reducible</code>: A reducible object (array, dictionary, any iterator, etc.).</li><li><code>init</code>: An initial value fed to the first argument to reducing step function <code>step</code>.  This argument can be omitted for well know binary operations like <code>+</code> or <code>*</code>.  Supported binary operations are listed in InitialValues.jl documentation.  When <code>Init</code> (not the result of <code>Init</code>, such as <code>Init(*)</code>) is given, it is automatically &quot;instantiated&quot; as <code>Init(step)</code> (where <code>step</code> is appropriately unwrapped if <code>step</code> is a <code>Completing</code>).  See <a href="../examples/empty_result_handling/#Empty-result-handling-1">Empty result handling</a> in the manual for more information.</li><li><code>simd</code>: If <code>true</code> or <code>:ivdep</code>, enable SIMD using <code>Base.@simd</code>.  If <code>:ivdep</code>, use <code>@simd ivdep for ... end</code> variant.  Read Julia manual of <code>Base.@simd</code> to understand when it is appropriate to use this option.  For example, <code>simd = :ivdep</code> <em>must not</em> be used with stateful transducer like <a href="#Transducers.Scan"><code>Scan</code></a>.  This option has no effect if <code>false</code> (default).</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; function step_demo(state, input)
           @show state, input
           state + input
       end;

julia&gt; function step_demo(state)
           println(&quot;Finishing with state = &quot;, state)
           state
       end;

julia&gt; mapfoldl(Filter(isodd), step_demo, 1:4, init=0.0)
(state, input) = (0.0, 1)
(state, input) = (1.0, 3)
Finishing with state = 4.0
4.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/processes.jl#LL238-L292">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.transduce" href="#Transducers.transduce"><code>Transducers.transduce</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">transduce(xf, step, init, reducible) :: Union{T, Reduced{T}}</code></pre><p>See <a href="#Base.mapfoldl"><code>mapfoldl</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/processes.jl#LL295-L299">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.foldl" href="#Base.foldl"><code>Base.foldl</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">foldl(step, xf::Transducer, reducible; init, simd)
foldl(step, ed::Eduction; init, simd)</code></pre><p>The first form is a shorthand for <code>mapfoldl(xf, Completing(step), reducible)</code>.  It is intended to be used with a <code>do</code> block.  It is also equivalent to <code>foldl(step, eduction(xf, itr))</code>.</p><p>See: <a href="#Base.mapfoldl"><code>mapfoldl</code></a>, <a href="../examples/empty_result_handling/#Empty-result-handling-1">Empty result handling</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; foldl(Filter(isodd), 1:4, init=0.0) do state, input
           @show state, input
           state + input
       end
(state, input) = (0.0, 1)
(state, input) = (1.0, 3)
4.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/processes.jl#LL771-L793">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.foreach" href="#Base.foreach"><code>Base.foreach</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">foreach(eff, xf::Transducer, reducible; simd)
foreach(eff, ed::Eduction; simd)</code></pre><p>Feed the results of <code>xf</code> processing items in <code>reducible</code> into a unary function <code>eff</code>.  This is useful when the primary computation at the bottom is the side-effect.  It is also equivalent to <code>foreach(eff, eduction(xf, coll))</code>.  Note that</p><pre><code class="language-julia">foreach(eduction(xf, coll)) do x
    ...
end</code></pre><p>can be more efficient than</p><pre><code class="language-julia">for x in eduction(xf, coll)
    ...
end</code></pre><p>as the former does not have to translate the transducer protocol to the iterator protocol.</p><p><code>foreach</code> supports all constructs in the native <code>for</code> loop as well as the enhancements <a href="#footnote-julia_issue_22891">[julia_issue_22891]</a> to <code>break</code> with a value (<code>break D(x)</code> below) and append the <code>else</code> clause (<code>E(x)</code> below).</p><div class="footnote" id="footnote-julia_issue_22891"><a href="#footnote-julia_issue_22891"><strong>[julia_issue_22891]</strong></a><p>See also: <a href="https://github.com/JuliaLang/julia/issues/22891">break with value + loop else clauses (JuliaLang/julia#22891)</a></p></div><p>This native <code>for</code> loop</p><pre><code class="language-julia">ans = for x in xs
    A(x)
    B(x) &amp;&amp; break
    C(x) &amp;&amp; break D(x)
else
    E(x)
end</code></pre><p>can be written as</p><pre><code class="language-julia">ans = foreach(Map(identity), xs) do x
    A(x)
    B(x) &amp;&amp; return reduced()
    C(x) &amp;&amp; return reduced(D(x))
    x  # required for passing `x` to `E(x)` below
end |&gt; ifunreduced() do x
    E(x)
end</code></pre><p>See: <a href="#Base.mapfoldl"><code>mapfoldl</code></a>, <a href="#Transducers.reduced"><code>reduced</code></a>, <a href="#Transducers.ifunreduced"><code>ifunreduced</code></a>.</p><div class="admonition compat"><div class="admonition-title">Transducers.jl 0.3</div><div class="admonition-text"><p><code>foreach</code> is changed to return what the <code>do</code> block (<code>eff</code> function) returns as-is in version 0.3.  This was required for supporting &quot;for-else&quot; (<code>|&gt; ifunreduced</code>).  Previously, it only supported break-with-value and always applied <code>unreduced</code> before it returns.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; foreach(eduction(Filter(isodd), 1:4)) do input
           @show input
       end
input = 1
input = 3
3

julia&gt; foreach(Filter(!ismissing), [1, missing, 2, 3]) do input
           @show input
           if iseven(input)
               return reduced()
           end
       end
input = 1
input = 2
Reduced(nothing)</code></pre><p>It is often useful to append <a href="#Transducers.unreduced"><code>|&gt; unreduced</code></a> to unwrap <code>Reduced</code> in the final result (note that <code>|&gt;</code> here is the standard function application, not the transducer composition).</p><pre><code class="language-julia-repl">julia&gt; foreach(Filter(!ismissing), [1, missing, 2, 3]) do input
           reduced(&quot;got $input&quot;)
       end |&gt; unreduced
&quot;got 1&quot;</code></pre><p>Combination of break-with-value and for-else is useful for triggering action after (e.g.) some kind of membership testing failed:</p><pre><code class="language-julia-repl">julia&gt; has2(xs) = foreach(Filter(!ismissing), xs) do input
           input == 2 &amp;&amp; reduced(true)
       end |&gt; ifunreduced() do input
           @show input
           false
       end;

julia&gt; has2([1, missing, 2, 3])
true

julia&gt; has2([1, missing])
input = false
false</code></pre><p>However, note the output <code>input = false</code> in the last example.  This is because how <code>&amp;&amp;</code> works in Julia</p><pre><code class="language-julia-repl">julia&gt; false &amp;&amp; &quot;otherwise&quot;
false</code></pre><p>Thus, pure membership testing functions like <code>has2</code> above can be written in a more concise manner:</p><pre><code class="language-julia-repl">julia&gt; simpler_has2(xs) = foreach(Filter(!ismissing), xs) do input
           input == 2 &amp;&amp; reduced(true)
       end |&gt; unreduced;

julia&gt; simpler_has2([1, missing, 2, 3])
true

julia&gt; simpler_has2([1, missing])
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/processes.jl#LL808-L950">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.mapreduce" href="#Base.mapreduce"><code>Base.mapreduce</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">mapreduce(xf, step, reducible; init, simd) :: T</code></pre><p>Possibly parallel version of <a href="#Base.mapfoldl"><code>mapfoldl</code></a>.  The &quot;bottom&quot; reduction function <code>step(::T, ::T) :: T</code> must be associative and <code>init</code> must be its identity element.</p><p>Transducers composing <code>xf</code> must be stateless and non-terminating (e.g., <a href="#Transducers.Map"><code>Map</code></a>, <a href="#Transducers.Filter"><code>Filter</code></a>, <a href="#Transducers.Cat"><code>Cat</code></a>, etc.) except for <a href="#Transducers.ScanEmit"><code>ScanEmit</code></a>.  Note that <a href="#Transducers.Scan"><code>Scan</code></a> is not supported (although possible in theory).</p><p>See <a href="#Base.mapfoldl"><code>mapfoldl</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/processes.jl#LL372-L385">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.reduce" href="#Base.reduce"><code>Base.reduce</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">reduce(step, xf, reducible; init, simd)</code></pre><p>Like <a href="#Base.mapreduce"><code>mapreduce</code></a> but <code>step</code> is automatically wrapped by <a href="#Transducers.Completing"><code>Completing</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/processes.jl#LL388-L393">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.eduction" href="#Transducers.eduction"><code>Transducers.eduction</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">eduction(xf::Transducer, coll)</code></pre><p>Create a iterable and reducible object.</p><ul><li><a href="https://docs.julialang.org/en/v1/manual/interfaces/#man-interface-iteration-1">Iterable</a>.</li><li>Reducible; i.e., it can be handled by <a href="#Transducers.transduce"><code>transduce</code></a> efficiently.</li></ul><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/eduction"><code>eduction</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; for x in eduction(Filter(isodd) |&gt; Take(3), 1:1000)
           @show x
       end
x = 1
x = 3
x = 5</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/processes.jl#LL561-L582">source</a><div><div><pre><code class="language-none">eduction(iterator::Iterators.Generator)
eduction(iterator::Iterators.Filter)
eduction(iterator::Iterators.Flatten)</code></pre><p>Convert an <code>iterator</code> to an eduction.  The iterators that are typically used in the generator comprehensions are supported.</p><div class="admonition compat"><div class="admonition-title">Transducers.jl 0.3</div><div class="admonition-text"><p>New in version 0.3.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; iter = (y for x in 1:10 if x % 2 == 0 for y in (x, x + 1));

julia&gt; ed = eduction(iter);

julia&gt; collect(iter) == collect(ed)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/comprehensions.jl#LL7-L30">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.map!" href="#Base.map!"><code>Base.map!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">map!(xf::Transducer, dest, src; simd)</code></pre><p>Feed <code>src</code> to transducer <code>xf</code>, storing the result in <code>dest</code>. Collections <code>dest</code> and <code>src</code> must have the same shape.  Transducer <code>xf</code> may contain filtering transducers.  If some entries <code>src</code> are skipped, the corresponding entries in <code>dest</code> will be unchanged. Transducer <code>xf</code> must not contain any expansive transducers such as <a href="#Transducers.MapCat"><code>MapCat</code></a>.</p><p>See also <a href="#Base.copy!"><code>copy!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; xs = collect(1:5)
       ys = zero(xs)
       map!(Filter(isodd), ys, xs)
5-element Array{Int64,1}:
 1
 0
 3
 0
 5

julia&gt; ans === ys
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/processes.jl#LL680-L709">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.copy!" href="#Base.copy!"><code>Base.copy!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">copy!(xf::Transducer, dest, src)</code></pre><p>Feed <code>src</code> to transducer <code>xf</code>, storing the result in <code>dest</code>. Collections <code>dest</code> and <code>src</code> may have the same shape.  Source <code>src</code> must be iterable.  Destination <code>dest</code> must implement <code>empty!</code> and <code>push!</code>.</p><p>See also <a href="#Base.map!"><code>map!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; copy!(PartitionBy(x -&gt; x ÷ 3) |&gt; Map(sum), Int[], 1:10)
4-element Array{Int64,1}:
  3
 12
 21
 19</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/processes.jl#LL747-L768">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.append!" href="#Base.append!"><code>Base.append!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">append!(xf::Transducer, dest, src)</code></pre><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/into"><code>into</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; append!(Drop(2), [-1, -2], 1:5)
5-element Array{Int64,1}:
 -1
 -2
  3
  4
  5</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/processes.jl#LL623-L640">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.collect" href="#Base.collect"><code>Base.collect</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">collect(xf::Transducer, itr)</code></pre><p>Process an iterable <code>itr</code> using a transducer <code>xf</code> and collect the result into a <code>Vector</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(Interpose(missing), 1:3)
5-element Array{Union{Missing, Int64},1}:
 1
  missing
 2
  missing
 3</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/processes.jl#LL644-L662">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Channel" href="#Base.Channel"><code>Base.Channel</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Channel(xf::Transducer, itr; kwargs...)
Channel(ed::Eduction; kwargs...)</code></pre><p>Pipe items from an iterable <code>itr</code> processed by the transducer <code>xf</code> through a channel.  <code>Channel(xf, itr)</code> and <code>Channel(eduction(xf, itr))</code> are equivalent.  Note that <code>itr</code> itself can be a <code>Channel</code>.</p><p>Keyword arguments are passed to <code>Channel(function; kwargs...)</code>. <code>ctype</code> is inferred from <code>xf</code> if not specified.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; ch1 = Channel(Filter(isodd), 1:5);

julia&gt; ch2 = Channel(Map(x -&gt; 2x - 1), ch1);

julia&gt; ed = eduction(Map(x -&gt; 1:x), ch2);

julia&gt; ch3 = Channel(Cat(), ed);

julia&gt; typeof(ch1) === typeof(ch2) === typeof(ch3) === Channel{Int}
true

julia&gt; foreach(PartitionBy(isequal(1)), ch3) do input
           @show input
       end;
input = [1, 1]
input = [2, 3, 4, 5]
input = [1]
input = [2, 3, 4, 5, 6, 7, 8, 9]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/processes.jl#LL1000-L1034">source</a></section><h2><a class="nav-anchor" id="Transducers-1" href="#Transducers-1">Transducers</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.Cat" href="#Transducers.Cat"><code>Transducers.Cat</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Cat()</code></pre><p>Concatenate/flatten nested iterators.</p><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/cat"><code>cat</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(Cat(), [[1, 2], [3], [4, 5]]) == 1:5
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/library.jl#LL129-L143">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.Count" href="#Transducers.Count"><code>Transducers.Count</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Count([start[, step]])</code></pre><p>Generate a sequence <code>start</code>, <code>start + step</code>, <code>start + step + step</code>, and so on.</p><p>Note that input is ignored.  To use the input in the downstream reduction steps, use <a href="#Transducers.Zip-Tuple"><code>Zip</code></a>.</p><p><code>start</code> defaults to 1 and <code>step</code> defaults to <code>oneunit(start)</code>.</p><p>See also: <a href="https://docs.julialang.org/en/v1/base/iterators/"><code>Iterators.countfrom</code></a>. <a href="#Transducers.Enumerate"><code>Enumerate</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(Zip(Map(identity), Count()), -3:-1)
3-element Array{Tuple{Int64,Int64},1}:
 (-3, 1)
 (-2, 2)
 (-1, 3)

julia&gt; using Dates

julia&gt; collect(Zip(Map(identity), Count(Day(1))) |&gt; Map(xs -&gt; *(xs...)), 1:3) ==
       [Day(1), Day(4), Day(9)]
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/library.jl#LL1363-L1393">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.Dedupe" href="#Transducers.Dedupe"><code>Transducers.Dedupe</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Dedupe()</code></pre><p>De-duplicate <em>consecutive</em> items.</p><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/dedupe"><code>dedupe</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(Dedupe(), [1, 1, 2, 1, 3, 3, 2])
5-element Array{Int64,1}:
 1
 2
 1
 3
 2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/library.jl#LL990-L1009">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.Drop" href="#Transducers.Drop"><code>Transducers.Drop</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Drop(n)</code></pre><p>Drop first <code>n</code> items.</p><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/drop"><code>drop</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(Drop(3), 1:5)
2-element Array{Int64,1}:
 4
 5</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/library.jl#LL503-L519">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.DropLast" href="#Transducers.DropLast"><code>Transducers.DropLast</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">DropLast(n)</code></pre><p>Drop last <code>n</code> items.</p><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/drop-last"><code>drop-last</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(DropLast(2), 1:5)
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; collect(DropLast(2), 1:1) == []
true

julia&gt; collect(DropLast(2), 1:0) == []
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/library.jl#LL544-L567">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.DropWhile" href="#Transducers.DropWhile"><code>Transducers.DropWhile</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">DropWhile(pred)</code></pre><p>Drop items while <code>pred</code> returns <code>true</code> consecutively.  It becomes a no-op after <code>pred</code> returns a <code>false</code>.</p><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/drop-while"><code>drop-while</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(DropWhile(x -&gt; x &lt; 3), [1:5; 1:2])
5-element Array{Int64,1}:
 3
 4
 5
 1
 2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/library.jl#LL607-L627">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.Enumerate" href="#Transducers.Enumerate"><code>Transducers.Enumerate</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Enumerate([start[, step]])</code></pre><p>Transducer variant of <code>Base.enumerate</code>. The <code>start</code> and <code>step</code> arguments are optional and have the same meaning as in <a href="#Transducers.Count"><code>Count</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(Enumerate(), [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;])
3-element Array{Tuple{Int64,String},1}:
 (1, &quot;A&quot;)
 (2, &quot;B&quot;)
 (3, &quot;C&quot;)

julia&gt; start=2; step=3;

julia&gt; collect(Enumerate(start, step), [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;])
3-element Array{Tuple{Int64,String},1}:
 (2, &quot;A&quot;)
 (5, &quot;B&quot;)
 (8, &quot;C&quot;)
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/library.jl#LL1783-L1808">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.Filter" href="#Transducers.Filter"><code>Transducers.Filter</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Filter(pred)</code></pre><p>Skip items for which <code>pred</code> is evaluated to <code>false</code>.</p><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/filter"><code>filter</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(Filter(iseven), 1:3)
1-element Array{Int64,1}:
 2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/library.jl#LL180-L195">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.FlagFirst" href="#Transducers.FlagFirst"><code>Transducers.FlagFirst</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">FlagFirst()</code></pre><p>Output <code>(isfirst, input)</code> where <code>isfirst::Bool</code> is <code>true</code> only for the first iteration and <code>input</code> is the original input.</p><p>See also: <a href="https://juliacollections.github.io/IterTools.jl/latest/#flagfirst(xs)-1"><code>IterTools.flagfirst</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(FlagFirst(), 1:3)
3-element Array{Tuple{Bool,Int64},1}:
 (true, 1)
 (false, 2)
 (false, 3)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/library.jl#LL644-L664">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.GroupBy" href="#Transducers.GroupBy"><code>Transducers.GroupBy</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">GroupBy(key, rf, [init])
GroupBy(key, xf::Transducer, [step = right, [init]])</code></pre><p>Group the input stream by a function <code>key</code> and then fan-out each group of key-value pairs to the reducing function <code>rf</code>.  For example, if <code>GroupBy</code> is composed as follows</p><pre><code class="language-none">Map(upstream) |&gt; GroupBy(key, rf, init) |&gt; Map(downstream)</code></pre><p>then the &quot;function signatures&quot; would be:</p><pre><code class="language-none">upstream(_) :: V
key(::V) :: K
rf(::Y, ::Pair{K, V}) ::Y
downstream(::Dict{K, Y})</code></pre><p>That is to say,</p><ul><li><p>Ouput of the <code>upstream</code> is fed into the function <code>key</code> that produces the group key (of type <code>K</code>).</p></li><li><p>For each new group key, a new transducible process is started with the initial state <code>init :: Y</code> (which is shared by all transducible processes).</p></li><li><p>After one &quot;nested&quot; reducing function <code>rf</code> is called, the intermediate result dictionary (of type <code>Dict{K, Y}</code>) accumulating the previous results is then fed into the <code>downstream</code>.</p></li></ul><p>See also <code>groupreduce</code> in <a href="https://github.com/JuliaData/SplitApplyCombine.jl">SplitApplyCombine.jl</a>.</p><div class="admonition compat"><div class="admonition-title">Transducers.jl 0.3</div><div class="admonition-text"><p>New in version 0.3.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers
       using BangBang  # for `push!!`

julia&gt; foldl(right, GroupBy(string, Map(last), push!!), [1, 2, 1, 2, 3])
Dict{String,Array{Int64,1}} with 3 entries:
  &quot;1&quot; =&gt; [1, 1]
  &quot;2&quot; =&gt; [2, 2]
  &quot;3&quot; =&gt; [3]</code></pre><p>Note that the reduction stops if one of the group returns a <a href="#Transducers.reduced"><code>reduced</code></a>.  This can be used, for example, to find if there is a group with a sum grater than 3 and stop the computation as soon as it is find:</p><pre><code class="language-julia-repl">julia&gt; result = transduce(
           GroupBy(
               string,
               Map(last) |&gt; Scan(+) |&gt; ReduceIf(x -&gt; x &gt; 3),
           ),
           right,
           nothing,
           [1, 2, 1, 2, 3],
       );

julia&gt; result isa Reduced
true

julia&gt; unreduced(result)
Dict{String,Int64} with 2 entries:
  &quot;1&quot; =&gt; 2
  &quot;2&quot; =&gt; 4</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/library.jl#LL1827-L1900">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.Interpose" href="#Transducers.Interpose"><code>Transducers.Interpose</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Interpose(sep)</code></pre><p>Interleave input items with a <code>sep</code>.</p><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/interpose"><code>interpose</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(Interpose(missing), 1:3)
5-element Array{Union{Missing, Int64},1}:
 1
  missing
 2
  missing
 3</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/library.jl#LL951-L970">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.Iterated" href="#Transducers.Iterated"><code>Transducers.Iterated</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Iterated(f, init[, T::Type])</code></pre><p>Generate a sequence <code>init</code>, <code>f(init)</code>, <code>f(f(init))</code>, <code>f(f(f(init)))</code>, and so on.</p><p>Note that input is ignored.  To use the input in the downstream reduction steps, use <a href="#Transducers.Zip-Tuple"><code>Zip</code></a>.</p><p>Use the third argument <code>T</code> to specify the output type of <code>f</code>.</p><p>Pass <a href="#Transducers.OnInit"><code>OnInit</code></a> or <a href="#Transducers.CopyInit"><code>CopyInit</code></a> object to <code>init</code> for creating a dedicated (possibly mutable) state for each fold.</p><p>See also: <a href="#Transducers.Scan"><code>Scan</code></a>, <a href="#Transducers.ScanEmit"><code>ScanEmit</code></a>.</p><p>The idea is taken from <a href="https://juliacollections.github.io/IterTools.jl/latest/#IterTools.iterated"><code>IterTools.iterated</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(Iterated(x -&gt; 2x, 1), 1:5)
5-element Array{Int64,1}:
  1
  2
  4
  8
 16

julia&gt; collect(Zip(Map(identity), Iterated(x -&gt; 2x, 1)), 1:5)
5-element Array{Tuple{Int64,Int64},1}:
 (1, 1)
 (2, 2)
 (3, 4)
 (4, 8)
 (5, 16)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/library.jl#LL1297-L1334">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.Keep" href="#Transducers.Keep"><code>Transducers.Keep</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Keep(f)</code></pre><p>Pass non-<code>nothing</code> output of <code>f</code> to the inner reducing step.</p><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/keep"><code>keep</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; xf = Keep() do x
           if x &lt; 3
               x + 1
           end
       end;

julia&gt; collect(xf, 1:5)
2-element Array{Int64,1}:
 2
 3</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/library.jl#LL871-L893">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.Map" href="#Transducers.Map"><code>Transducers.Map</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Map(f)</code></pre><p>Apply unary function <code>f</code> to each input and pass the result to the inner reducing step.</p><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/map"><code>map</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(Map(x -&gt; 2x), 1:3)
3-element Array{Int64,1}:
 2
 4
 6</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/library.jl#LL27-L45">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.MapCat" href="#Transducers.MapCat"><code>Transducers.MapCat</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">MapCat(f)</code></pre><p>Concatenate output of <code>f</code> which is expected to return an iterable.</p><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/mapcat"><code>mapcat</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(MapCat(x -&gt; 1:x), 1:3)
6-element Array{Int64,1}:
 1
 1
 2
 1
 2
 3</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/library.jl#LL153-L173">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.MapSplat" href="#Transducers.MapSplat"><code>Transducers.MapSplat</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">MapSplat(f)</code></pre><p>Like <code>Map(f)</code> but calls <code>f(input...)</code> for each <code>input</code> and then pass the result to the inner reducing step.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(MapSplat(*), zip(1:3, 10:10:30))
3-element Array{Int64,1}:
 10
 40
 90</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/library.jl#LL54-L70">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.NotA" href="#Transducers.NotA"><code>Transducers.NotA</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">NotA(T)</code></pre><p>Skip items of type <code>T</code>.  Unlike <code>Filter(!ismissing)</code>, downstream transducers can have a correct type information for <code>NotA(Missing)</code>.</p><p>See also: <a href="#Transducers.OfType"><code>OfType</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(NotA(Missing), [1, missing, 2])
2-element Array{Int64,1}:
 1
 2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/library.jl#LL203-L220">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.OfType" href="#Transducers.OfType"><code>Transducers.OfType</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">OfType(T)</code></pre><p>Include only items of type <code>T</code>.</p><p>See also: <a href="#Transducers.NotA"><code>NotA</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(OfType(Int), [1, missing, 2])
2-element Array{Int64,1}:
 1
 2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/library.jl#LL237-L253">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.Partition" href="#Transducers.Partition"><code>Transducers.Partition</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Partition(size, step = size, flush = false)
Partition(size; step = size, flush = false)</code></pre><p>Sliding window of width <code>size</code> and interval <code>step</code>.</p><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>The vector passed to the inner reducing function is valid only during its <em>immediate</em> reduction step.  It must be reduced immediately <em>or</em> copied.</p></div></div><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/partition-all"><code>partition-all</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(Partition(3) |&gt; Map(copy), 1:8)
2-element Array{Array{Int64,1},1}:
 [1, 2, 3]
 [4, 5, 6]

julia&gt; collect(Partition(3; flush=true) |&gt; Map(copy), 1:8)
3-element Array{Array{Int64,1},1}:
 [1, 2, 3]
 [4, 5, 6]
 [7, 8]

julia&gt; collect(Partition(3; step=1) |&gt; Map(copy), 1:8)
6-element Array{Array{Int64,1},1}:
 [1, 2, 3]
 [2, 3, 4]
 [3, 4, 5]
 [4, 5, 6]
 [5, 6, 7]
 [6, 7, 8]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/library.jl#LL681-L715">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.PartitionBy" href="#Transducers.PartitionBy"><code>Transducers.PartitionBy</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">PartitionBy(f)</code></pre><p>Group input sequence into chunks in which <code>f</code> returns a same value consecutively.</p><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>The vector passed to the inner reducing function is valid only during its <em>immediate</em> reduction step.  It must be reduced immediately <em>or</em> copied.</p></div></div><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/partition-by"><code>partition-by</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(PartitionBy(x -&gt; (x + 1) ÷ 3) |&gt; Map(copy), 1:9)
4-element Array{Array{Int64,1},1}:
 [1]
 [2, 3, 4]
 [5, 6, 7]
 [8, 9]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/library.jl#LL809-L830">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.ReduceIf" href="#Transducers.ReduceIf"><code>Transducers.ReduceIf</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ReduceIf(pred)</code></pre><p>Stop fold when <code>pred(x)</code> returns <code>true</code> for the output <code>x</code> of the upstream transducer.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; foldl(right, ReduceIf(x -&gt; x == 3), 1:10)
3</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/library.jl#LL1979-L1992">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.Replace" href="#Transducers.Replace"><code>Transducers.Replace</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Replace(assoc)</code></pre><p>Replace each input with the value in the associative container <code>assoc</code> (e.g., a dictionary, array, string) if it matches with a key/index. Otherwise output the input as-is.</p><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/replace"><code>replace</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(Replace(Dict(&#39;a&#39; =&gt; &#39;A&#39;)), &quot;abc&quot;)
3-element Array{Char,1}:
 &#39;A&#39;
 &#39;b&#39;
 &#39;c&#39;

julia&gt; collect(Replace([:a, :b, :c]), 0:4)
5-element Array{Any,1}:
 0
  :a
  :b
  :c
 4

julia&gt; collect(Replace(&quot;abc&quot;), 0:4)
5-element Array{Any,1}:
 0
  &#39;a&#39;
  &#39;b&#39;
  &#39;c&#39;
 4</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/library.jl#LL82-L117">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.Scan" href="#Transducers.Scan"><code>Transducers.Scan</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Scan(f, [init = Init])</code></pre><p>Accumulate input with binary function <code>f</code> and pass the accumulated result so far to the inner reduction step.</p><p>The inner reducing step receives the sequence <code>y₁, y₂, y₃, ..., yₙ, ...</code> when the sequence <code>x₁, x₂, x₃, ..., xₙ, ...</code> is fed to <code>Scan(f)</code>.</p><pre><code class="language-none">y₁ = f(init, x₁)
y₂ = f(y₁, x₂)
y₃ = f(y₂, x₃)
...
yₙ = f(yₙ₋₁, xₙ)</code></pre><p>This is a generalized version of the <a href="https://en.wikipedia.org/wiki/Prefix_sum"><em>prefix sum</em></a> also known as <em>cumulative sum</em>, <em>inclusive scan</em>, or <em>scan</em>.</p><p>Note that the associativity of <code>f</code> is not required when the transducer is used in a process that gurantee an order, such as <a href="#Base.mapfoldl"><code>mapfoldl</code></a>.</p><p>Unless <code>f</code> is a function with known identity element such as <code>+</code>, <code>*</code>, <code>min</code>, <code>max</code>, and <code>append!</code>, the initial state <code>init</code> must be provided.</p><p>Pass <a href="#Transducers.OnInit"><code>OnInit</code></a> or <a href="#Transducers.CopyInit"><code>CopyInit</code></a> object to <code>init</code> for creating a dedicated (possibly mutable) state for each fold.</p><p>See also: <a href="#Transducers.ScanEmit"><code>ScanEmit</code></a>, <a href="#Transducers.Iterated"><code>Iterated</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(Scan(*), 1:3)
3-element Array{Int64,1}:
 1
 2
 6

julia&gt; collect(Map(x -&gt; x + im) |&gt; Scan(*), 1:3)
3-element Array{Complex{Int64},1}:
 1 + 1im
 1 + 3im
 0 + 10im

julia&gt; collect(Scan(*, 10), 1:3)
3-element Array{Int64,1}:
 10
 20
 60</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/library.jl#LL1025-L1077">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.ScanEmit" href="#Transducers.ScanEmit"><code>Transducers.ScanEmit</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ScanEmit(f, init[, onlast])</code></pre><p>Accumulate input <code>x</code> with a function <code>f</code> with the call signature <code>(u, x) -&gt; (y, u)</code> and pass the result <code>y</code> to the inner reduction step.</p><p>The inner reducing step receives the sequence <code>y₁, y₂, y₃, ..., yₙ, ...</code> computed as follows</p><pre><code class="language-none">u₀ = init
y₁, u₁ = f(u₀, x₁)
y₂, u₂ = f(u₁, x₂)
y₃, u₃ = f(u₂, x₃)
...
yₙ, uₙ = f(uₙ₋₁, xₙ)
...
yₒₒ = onlast(uₒₒ)</code></pre><p>when the sequence <code>x₁, x₂, x₃, ..., xₙ, ...</code> is fed to <code>ScanEmit(f)</code>.</p><p>Pass <a href="#Transducers.OnInit"><code>OnInit</code></a> or <a href="#Transducers.CopyInit"><code>CopyInit</code></a> object to <code>init</code> for creating a dedicated (possibly mutable) state for each fold.</p><p>See also: <a href="#Transducers.ScanEmit"><code>ScanEmit</code></a>, <a href="#Transducers.Iterated"><code>Iterated</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(ScanEmit(tuple, 0), 1:3)
3-element Array{Int64,1}:
 0
 1
 2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/library.jl#LL1117-L1151">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.Take" href="#Transducers.Take"><code>Transducers.Take</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Take(n)</code></pre><p>Take <code>n</code> items from the input sequence.</p><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/take"><code>take</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(Take(2), 1:10)
2-element Array{Int64,1}:
 1
 2

julia&gt; collect(Take(5), 1:2)
2-element Array{Int64,1}:
 1
 2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/library.jl#LL316-L337">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.TakeLast" href="#Transducers.TakeLast"><code>Transducers.TakeLast</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">TakeLast(n)</code></pre><p>Take last <code>n</code> items from the input sequence.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(TakeLast(2), 1:10)
2-element Array{Int64,1}:
  9
 10

julia&gt; collect(TakeLast(5), 1:2)
2-element Array{Int64,1}:
 1
 2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/library.jl#LL362-L381">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.TakeNth" href="#Transducers.TakeNth"><code>Transducers.TakeNth</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">TakeNth(n)</code></pre><p>Output every <code>n</code> item to the inner reducing step.</p><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/take-nth"><code>take-nth</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(TakeNth(3), 1:9)
3-element Array{Int64,1}:
 1
 4
 7</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/library.jl#LL460-L477">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.TakeWhile" href="#Transducers.TakeWhile"><code>Transducers.TakeWhile</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">TakeWhile(pred)</code></pre><p>Take items while <code>pred</code> returns <code>true</code>.  Abort the reduction when <code>pred</code> returns <code>false</code> for the first time.</p><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/take-while"><code>take-while</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(TakeWhile(x -&gt; x &lt; 3), [1, 2, 3, 1, 2])
2-element Array{Int64,1}:
 1
 2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/library.jl#LL429-L446">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.Unique" href="#Transducers.Unique"><code>Transducers.Unique</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Unique()</code></pre><p>Pass only unseen item to the inner reducing step.</p><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/distinct"><code>distinct</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(Unique(), [1, 1, 2, 1, 3, 3, 2])
3-element Array{Int64,1}:
 1
 2
 3</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/library.jl#LL910-L927">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.Zip-Tuple" href="#Transducers.Zip-Tuple"><code>Transducers.Zip</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Zip(xforms...)</code></pre><p>Zip outputs of transducers <code>xforms</code> in a tuple and pass it to the inner reduction step.</p><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>Head transducers drive tail transducers.  Be careful when using it with transducers other than <a href="#Transducers.Map"><code>Map</code></a>, especially the contractive ones like <a href="#Transducers.PartitionBy"><code>PartitionBy</code></a> and the expansive ones like <a href="#Transducers.MapCat"><code>MapCat</code></a>.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; collect(Zip(Map(identity), Map(x -&gt; 10x), Map(x -&gt; 100x)), 1:3)
3-element Array{Tuple{Int64,Int64,Int64},1}:
 (1, 10, 100)
 (2, 20, 200)
 (3, 30, 300)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/library.jl#LL1594-L1616">source</a></section><h3><a class="nav-anchor" id="Experimental-1" href="#Experimental-1">Experimental</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.TeeZip" href="#Transducers.TeeZip"><code>Transducers.TeeZip</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">TeeZip(xform::Transducer)</code></pre><p>Branch input into two &quot;flows&quot;, inject one into <code>xform</code> and then merge the output of <code>xform</code> with the original input.</p><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>This API is experimental.  Backward incompatible change, including the removal of this API, is more likely to occur than other parts of this package.</p></div></div><p>To illustrate how it works, consider the following usage</p><pre><code class="language-none">xf0 |&gt; TeeZip(xf1) |&gt; xf2</code></pre><p>where <code>xf0</code>, <code>xf1</code>, and <code>xf2</code> are some transducers.  Schematically, the output <code>yn</code> from <code>xfn</code> flows as follows:</p><pre><code class="language-text">xf0      xf1                       xf2
---- y0 ------ y1 ---.-- (y0, y1) -----&gt;
      |              |
       `-------------&#39;
    &quot;Tee&quot;          &quot;Zip&quot;</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers
       using Transducers: TeeZip

julia&gt; collect(TeeZip(Filter(isodd) |&gt; Map(x -&gt; x + 1)), 1:5)
3-element Array{Tuple{Int64,Int64},1}:
 (1, 2)
 (3, 4)
 (5, 6)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/library.jl#LL1410-L1446">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.GetIndex" href="#Transducers.GetIndex"><code>Transducers.GetIndex</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">GetIndex(array)
GetIndex{inbounds}(array)</code></pre><p>Transform an integer input <code>i</code> to <code>array[i]</code>.</p><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>This API is experimental.  Backward incompatible change, including the removal of this API, is more likely to occur than other parts of this package.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers
       using Transducers: GetIndex

julia&gt; collect(GetIndex(1:10), [2, 3, 4])
3-element Array{Int64,1}:
 2
 3
 4

julia&gt; collect(GetIndex{true}(1:10), [2, 3, 4])
3-element Array{Int64,1}:
 2
 3
 4</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/library.jl#LL1629-L1654">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.SetIndex" href="#Transducers.SetIndex"><code>Transducers.SetIndex</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SetIndex(array)
SetIndex{inbounds}(array)</code></pre><p>Perform <code>array[i] = v</code> for each input pair <code>(i, v)</code>.</p><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>This API is experimental.  Backward incompatible change, including the removal of this API, is more likely to occur than other parts of this package.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers
       using Transducers: SetIndex

julia&gt; ys = zeros(3);

julia&gt; mapfoldl(SetIndex(ys), first ∘ tuple, [(1, 11.1), (3, 33.3)], init=nothing)

julia&gt; ys
3-element Array{Float64,1}:
 11.1
  0.0
 33.3</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/library.jl#LL1676-L1699">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.Inject" href="#Transducers.Inject"><code>Transducers.Inject</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Inject(iterator)</code></pre><p>Inject the output from <code>iterator</code> to the stream processed by the inner reduction step.</p><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>This API is experimental.  Backward incompatible change, including the removal of this API, is more likely to occur than other parts of this package.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers
       using Transducers: Inject

julia&gt; collect(Inject(Iterators.cycle(&quot;hello&quot;)), 1:8)
8-element Array{Tuple{Int64,Char},1}:
 (1, &#39;h&#39;)
 (2, &#39;e&#39;)
 (3, &#39;l&#39;)
 (4, &#39;l&#39;)
 (5, &#39;o&#39;)
 (6, &#39;h&#39;)
 (7, &#39;e&#39;)
 (8, &#39;l&#39;)

julia&gt; collect(Inject(Iterators.repeated([1 2])), 1:4)
4-element Array{Tuple{Int64,Array{Int64,2}},1}:
 (1, [1 2])
 (2, [1 2])
 (3, [1 2])
 (4, [1 2])

julia&gt; collect(Inject(Iterators.product(1:2, 3:5)), 1:100)
6-element Array{Tuple{Int64,Tuple{Int64,Int64}},1}:
 (1, (1, 3))
 (2, (2, 3))
 (3, (1, 4))
 (4, (2, 4))
 (5, (1, 5))
 (6, (2, 5))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/library.jl#LL1724-L1764">source</a></section><h2><a class="nav-anchor" id="Early-termination-1" href="#Early-termination-1">Early termination</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.Reduced" href="#Transducers.Reduced"><code>Transducers.Reduced</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Reduced</code></pre><p>The type signaling transducible processes to abort.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Call <a href="#Transducers.reduced"><code>reduced</code></a> function for aborting the transducible process since <a href="#Transducers.reduced"><code>reduced</code></a> makes sure <code>x</code> is not doubly wrapped.  <code>Reduced</code> is meant to be used as <code>x isa Reduced</code> for checking if the result from <a href="#Transducers.transduce"><code>transduce</code></a> is due to early termination.</p></div></div><p>See <a href="#Transducers.reduced"><code>reduced</code></a>, <a href="#Transducers.unreduced"><code>unreduced</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; function step_demo(y, x)
           if x &gt; 5
               return reduced(y)
           else
               return y + x
           end
       end;

julia&gt; result = transduce(Map(identity), Completing(step_demo), 0, 1:10)
Reduced(15)

julia&gt; result isa Reduced
true

julia&gt; unreduced(result)
15

julia&gt; result = transduce(Map(identity), Completing(step_demo), 0, 1:4)
10

julia&gt; result isa Reduced
false

julia&gt; unreduced(result)
10</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/core.jl#LL3-L47">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.reduced" href="#Transducers.reduced"><code>Transducers.reduced</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">reduced([x = nothing])</code></pre><p>Stop transducible process with the final value <code>x</code> (default: <code>nothing</code>).  Return <code>x</code> as-is if it already is a <code>reduced</code> value.</p><p>See <a href="#Transducers.Reduced"><code>Reduced</code></a>, <a href="#Transducers.unreduced"><code>unreduced</code></a>.</p><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/ensure-reduced"><code>ensure-reduced</code> in Clojure</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; foldl(Enumerate(), &quot;abcdef&quot;; init=0) do y, (i, x)
           if x == &#39;d&#39;
               return reduced(y)
           end
           return y + i
       end
6

julia&gt; foreach(Enumerate(), &quot;abc&quot;) do (i, x)
           println(i, &#39; &#39;, x)
           if x == &#39;b&#39;
               return reduced()
           end
       end;
1 a
2 b</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/core.jl#LL60-L91">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.unreduced" href="#Transducers.unreduced"><code>Transducers.unreduced</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">unreduced(x)</code></pre><p>Unwrap <code>x</code> if it is a <code>Reduced</code>; do nothing otherwise.</p><p>See <a href="#Transducers.Reduced"><code>Reduced</code></a>, <a href="#Transducers.reduced"><code>reduced</code></a>.</p><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/unreduced"><code>unreduced</code> in Clojure</a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/core.jl#LL96-L104">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.ifunreduced" href="#Transducers.ifunreduced"><code>Transducers.ifunreduced</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">ifunreduced(f, [x])</code></pre><p>Equivalent to <a href="#Transducers.unreduced"><code>unreduced(x)</code></a> if <code>x</code> is a <a href="#Transducers.Reduced"><code>Reduced</code></a>; otherwise run <code>f(x)</code>.  Return a curried version if <code>x</code> is not provided.</p><p>See: <a href="#Base.foreach"><code>foreach</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; 1 |&gt; ifunreduced() do x
           println(&quot;called with x = &quot;, x)
       end
called with x = 1

julia&gt; reduced(1) |&gt; ifunreduced() do x
           println(&quot;called with x = &quot;, x)
       end
1</code></pre><p>Notice that nothing is printed in the last example.</p><p><strong>Implementation</strong></p><pre><code class="language-julia">ifunreduced(f) = x -&gt; ifunreduced(f, x)
ifunreduced(f, x::Reduced) = unreduced(x)
ifunreduced(f, x) = f(x)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/processes.jl#LL961-L994">source</a></section><h2><a class="nav-anchor" id="Miscellaneous-1" href="#Miscellaneous-1">Miscellaneous</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.Transducer-Tuple{Union{Generator, Filter, Flatten}}" href="#Transducers.Transducer-Tuple{Union{Generator, Filter, Flatten}}"><code>Transducers.Transducer</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Transducer(iterator::Iterators.Generator)
Transducer(iterator::Iterators.Filter)
Transducer(iterator::Iterators.Flatten)</code></pre><p>Extract &quot;processing&quot; part of an <code>iterator</code> as a <code>Transducer</code>.  The &quot;data source&quot; iterator (i.e., <code>xs</code> in <code>(f(x) for x in xs)</code>) is ignored and <code>nothing</code> must be used as a place holder (i.e., <code>(f(x) for x in nothing)</code>).</p><p>See also <a href="#Transducers.eduction"><code>eduction</code></a>.</p><div class="admonition compat"><div class="admonition-title">Transducers.jl 0.3</div><div class="admonition-text"><p>New in version 0.3.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; xf1 = Transducer(2x for x in nothing if x % 2 == 0);

julia&gt; xf2 = Filter(x -&gt; x % 2 == 0) |&gt; Map(x -&gt; 2x);  # equivalent

julia&gt; xs = 1:10
       collect(xf1, xs) == collect(xf2, xs)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/comprehensions.jl#LL33-L61">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.Transducer-Tuple{OnlineStatsBase.OnlineStat}" href="#Transducers.Transducer-Tuple{OnlineStatsBase.OnlineStat}"><code>Transducers.Transducer</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Transducer(o::OnlineStat)</code></pre><p>Use an <code>OnlineStat</code> as a stateful transducer.</p><p>It is implemented as:</p><pre><code class="language-julia">Scan(fit!, CopyInit(o)) |&gt; Map(value)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers
       using OnlineStats: Mean

julia&gt; collect(Transducer(Mean()), 1:4)
4-element Array{Float64,1}:
 1.0
 1.5
 2.0
 2.5</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/interop/onlinestats.jl#LL1-L24">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.reducingfunction" href="#Transducers.reducingfunction"><code>Transducers.reducingfunction</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">reducingfunction(xf, step; simd)</code></pre><p>Apply transducer <code>xf</code> to the reducing function <code>step</code> to create a new reducing function.</p><div class="admonition compat"><div class="admonition-title">Transducers.jl 0.3</div><div class="admonition-text"><p>New in version 0.3.</p></div></div><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>Be careful using <code>reducingfunction</code> with stateful transducers like <a href="#Transducers.Scan"><code>Scan</code></a> with mutable <code>init</code> (e.g., <code>Scan(push!, [])</code>).  See more in Examples below.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>xf::Transducer</code>: A transducer.</li><li><code>step</code>: A callable which accepts 1 and 2 arguments.  If it only accepts 2 arguments, wrap it with <a href="#Transducers.Completing"><code>Completing</code></a> to &quot;add&quot; 1-argument form (i.e., <a href="../interface/#Transducers.complete"><code>complete</code></a> protocol).</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>simd</code>: <code>false</code>, <code>true</code>, or <code>:ivdep</code>. See <a href="../internals/#Transducers.maybe_usesimd-Tuple{Transducers.AbstractReduction,Union{Val{true}, Val{false}, Val{:ivdep}, Bool, Symbol}}"><code>maybe_usesimd</code></a>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; rf = reducingfunction(Map(x -&gt; x + 1), *);

julia&gt; rf(10, 2) === 10 * (2 + 1)
true</code></pre><p><strong>Warning: Be careful when using <code>reducingfunction</code> with stateful transducers</strong></p><p>Stateful <code>Transducer</code>s themselves in Transducers.jl are not inherently broken with <code>reducingfunction</code>.  However, it can produce incorrect results when combined with mutable states:</p><pre><code class="language-julia-repl">julia&gt; scan_state = [];

julia&gt; rf_bad = reducingfunction(Scan(push!, scan_state) |&gt; Cat(), string);

julia&gt; transduce(rf_bad, &quot;&quot;, 1:3)
&quot;112123&quot;</code></pre><p>The first run works.  However, observe that the vector <code>scan_state</code> is not empty anymore:</p><pre><code class="language-julia-repl">julia&gt; scan_state
3-element Array{Any,1}:
 1
 2
 3</code></pre><p>Thus, the second run produces an incorrect result:</p><pre><code class="language-julia-repl">julia&gt; transduce(rf_bad, &quot;&quot;, 1:3)
&quot;123112312123123&quot;</code></pre><p>One way to solve this issue is to use <a href="#Transducers.CopyInit"><code>CopyInit</code></a> or <a href="#Transducers.Initializer"><code>Initializer</code></a>.</p><pre><code class="language-julia-repl">julia&gt; scan_state = CopyInit([])
CopyInit(Any[])

julia&gt; rf_good = reducingfunction(Scan(push!, scan_state) |&gt; Cat(), string);

julia&gt; transduce(rf_good, &quot;&quot;, 1:3)
&quot;112123&quot;

julia&gt; scan_state
CopyInit(Any[])

julia&gt; transduce(rf_good, &quot;&quot;, 1:3)
&quot;112123&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/processes.jl#LL3-L89">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.Completing" href="#Transducers.Completing"><code>Transducers.Completing</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Completing(function)</code></pre><p>Wrap a <code>function</code> to add a no-op <a href="../interface/#Transducers.complete"><code>complete</code></a> protocol.  Use it when passing a <code>function</code> without 1-argument arity to <a href="#Transducers.transduce"><code>transduce</code></a> etc.</p><p>This API is modeled after <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/completing"><code>completing</code> in Clojure</a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/core.jl#LL653-L661">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.OnInit" href="#Transducers.OnInit"><code>Transducers.OnInit</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">OnInit(f)</code></pre><p>Call a callable <code>f</code> to create an initial value.</p><p>See also <a href="#Transducers.CopyInit"><code>CopyInit</code></a>.</p><p><code>OnInit</code> or <code>CopyInit</code> must be used whenever using in-place reduction with <a href="#Base.mapreduce"><code>mapreduce</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; xf1 = Scan(push!, [])
Scan(push!, Any[])

julia&gt; mapfoldl(xf1, right, 1:3)
3-element Array{Any,1}:
 1
 2
 3

julia&gt; xf1
Scan(push!, Any[1, 2, 3])</code></pre><p>Notice that the array is stored in <code>xf1</code> and mutated in-place.  As a result, second run of <code>mapfoldl</code> contains the results from the first run:</p><pre><code class="language-julia-repl">julia&gt; mapfoldl(xf1, right, 10:11)
5-element Array{Any,1}:
  1
  2
  3
 10
 11</code></pre><p>This may not be desired.  To avoid this behavior, create an <code>OnInit</code> object which takes a factory function to create a new initial value.</p><pre><code class="language-julia-repl">julia&gt; xf2 = Scan(push!, OnInit(() -&gt; []))
Scan(push!, OnInit(##9#10()))

julia&gt; mapfoldl(xf2, right, 1:3)
3-element Array{Any,1}:
 1
 2
 3

julia&gt; mapfoldl(xf2, right, [10.0, 11.0])
2-element Array{Any,1}:
 10.0
 11.0</code></pre><p>Keyword argument <code>init</code> for transducible processes also accept an <code>OnInit</code>:</p><pre><code class="language-julia-repl">julia&gt; foldl(push!, Map(identity), &quot;abc&quot;; init=OnInit(() -&gt; []))
3-element Array{Any,1}:
 &#39;a&#39;
 &#39;b&#39;
 &#39;c&#39;</code></pre><p>To create a copy of a mutable object, <a href="#Transducers.CopyInit"><code>CopyInit</code></a> is easier to use.</p><p>However, more powerful and generic pattern is to use <code>push!!</code> from BangBang.jl and initialize <code>init</code> with <code>Union{}[]</code> so that it automatically finds the minimal element type.</p><pre><code class="language-julia-repl">julia&gt; using BangBang

julia&gt; foldl(push!!, Map(identity), &quot;abc&quot;; init=Union{}[])
3-element Array{Char,1}:
 &#39;a&#39;
 &#39;b&#39;
 &#39;c&#39;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/core.jl#LL777-L864">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.CopyInit" href="#Transducers.CopyInit"><code>Transducers.CopyInit</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">CopyInit(value)</code></pre><p>This is equivalent to <code>OnInit(() -&gt; deepcopy(value))</code>.</p><p>See <a href="#Transducers.Initializer"><code>Initializer</code></a>.</p><div class="admonition compat"><div class="admonition-title">Transducers.jl 0.3</div><div class="admonition-text"><p>New in version 0.3.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; init = CopyInit([]);

julia&gt; foldl(push!, Map(identity), 1:3; init=init)
3-element Array{Any,1}:
 1
 2
 3

julia&gt; foldl(push!, Map(identity), 1:3; init=init)  # `init` can be reused
3-element Array{Any,1}:
 1
 2
 3</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/core.jl#LL874-L903">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.Initializer" href="#Transducers.Initializer"><code>Transducers.Initializer</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Initializer(f)</code></pre><p>Wrap a factory function to create an initial value for transducible processes (e.g., <a href="#Base.mapfoldl"><code>mapfoldl</code></a>) and &quot;stateful&quot; transducers (e.g., <a href="#Transducers.Scan"><code>Scan</code></a>).  Factory function <code>f</code> takes the input type to the transducer or the reducing function.</p><div class="admonition compat"><div class="admonition-title">Transducers.jl 0.3</div><div class="admonition-text"><p><code>Initializer</code> is deprecated since Transducers 0.3.  Please use <a href="#Transducers.OnInit"><code>OnInit</code></a>.</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/core.jl#LL733-L745">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.right" href="#Transducers.right"><code>Transducers.right</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">right([l, ]r) -&gt; r</code></pre><p>It is simply defined as</p><pre><code class="language-julia">right(l, r) = r
right(r) = r</code></pre><p>This function is meant to be used as <code>step</code> argument for <a href="#Base.mapfoldl"><code>mapfoldl</code></a> etc. for extracting the last output of the transducers.</p><div class="admonition compat"><div class="admonition-title">Transducers.jl 0.3</div><div class="admonition-text"><p>Initial value must be manually specified.  In 0.2, it was automatically set to <code>nothing</code>.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; mapfoldl(Take(5), right, 1:10)
5

julia&gt; mapfoldl(Drop(5), right, 1:3; init=0)  # using `init` as the default value
0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/core.jl#LL689-L718">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.setinput" href="#Transducers.setinput"><code>Transducers.setinput</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">setinput(ed::Eduction, coll)</code></pre><p>Set input collection of eduction <code>ed</code> to <code>coll</code>.</p><div class="admonition compat"><div class="admonition-title">Transducers.jl 0.3</div><div class="admonition-text"><p>Previously, <code>setinput</code> combined with <code>eduction</code> was a recommended way to use transducers in a type stable manner.  As of v0.3, all the <code>foldl</code>-like functions and <code>eduction</code> are type stable for many cases.  This workaround is no more necessary.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers

julia&gt; ed = eduction(Map(x -&gt; 2x), Float64[]);

julia&gt; xs = ones(2, 3);

julia&gt; foldl(+, setinput(ed, xs))
12.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/processes.jl#LL593-L616">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Transducers.AdHocFoldable" href="#Transducers.AdHocFoldable"><code>Transducers.AdHocFoldable</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AdHocFoldable(foldl, [collection = nothing])</code></pre><p>Provide a different way to fold <code>collection</code> without creating a wrapper type.</p><p><strong>Arguments</strong></p><ul><li><code>foldl::Function</code>: a function that implements <a href="../interface/#Transducers.__foldl__"><code>__foldl__</code></a>.</li><li><code>collection</code>: a collection passed to the last argument of <code>foldl</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Transducers
       using Transducers: @next, complete
       using ArgCheck

julia&gt; function uppertriangle(A::AbstractMatrix)
           @argcheck !Base.has_offset_axes(A)
           return AdHocFoldable(A) do rf, acc, A
               for j in 1:size(A, 2), i in 1:min(j, size(A, 1))
                   acc = @next(rf, acc, @inbounds A[i, j])
               end
               return complete(rf, acc)
           end
       end;

julia&gt; A = reshape(1:6, (3, 2))
3×2 reshape(::UnitRange{Int64}, 3, 2) with eltype Int64:
 1  4
 2  5
 3  6

julia&gt; collect(Map(identity), uppertriangle(A))
3-element Array{Int64,1}:
 1
 4
 5

julia&gt; function circularwindows(xs::AbstractVector, h::Integer)
           @argcheck !Base.has_offset_axes(xs)
           @argcheck h &gt;= 0
           @argcheck 2 * h + 1 &lt;= length(xs)
           return AdHocFoldable(xs) do rf, acc, xs
               buffer = similar(xs, 2 * h + 1)
               @inbounds for i in 1:h
                   buffer[1:h - i + 1] .= @view xs[end - h + i:end]
                   buffer[h - i + 2:end] .= @view xs[1:h + i]
                   acc = @next(rf, acc, buffer)
               end
               for i in h + 1:length(xs) - h
                   acc = @next(rf, acc, @inbounds @view xs[i - h:i + h])
               end
               @inbounds for i in 1:h
                   buffer[1:end - i] .= @view xs[end - 2 * h + i:end]
                   buffer[end - i + 1:end] .= @view xs[1:i]
                   acc = @next(rf, acc, buffer)
               end
               return complete(rf, acc)
           end
       end;

julia&gt; collect(Map(collect), circularwindows(1:9, 2))
9-element Array{Array{Int64,1},1}:
 [8, 9, 1, 2, 3]
 [9, 1, 2, 3, 4]
 [1, 2, 3, 4, 5]
 [2, 3, 4, 5, 6]
 [3, 4, 5, 6, 7]
 [4, 5, 6, 7, 8]
 [5, 6, 7, 8, 9]
 [6, 7, 8, 9, 1]
 [7, 8, 9, 1, 2]

julia&gt; expressions(str::AbstractString; kwargs...) =
           AdHocFoldable(str) do rf, val, str
               pos = 1
               while true
                   expr, pos = Meta.parse(str, pos;
                                          raise = false,
                                          depwarn = false,
                                          kwargs...)
                   expr === nothing &amp;&amp; break
                   val = @next(rf, val, expr)
               end
               return complete(rf, val)
           end;

julia&gt; collect(Map(identity), expressions(&quot;&quot;&quot;
       x = 1
       y = 2
       &quot;&quot;&quot;))
2-element Array{Expr,1}:
 :(x = 1)
 :(y = 2)

julia&gt; counting = AdHocFoldable() do rf, acc, _
           i = 0
           while true
               i += 1
               acc = @next(rf, acc, i)
           end
       end;

julia&gt; foreach(counting) do i
           @show i;
           i == 3 &amp;&amp; return reduced()
       end;
i = 1
i = 2
i = 3</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/Transducers.jl/blob/5cb27a1d4b26e98872ccf7c1507bb3d02d49d56d/src/processes.jl#LL1062-L1174">source</a></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../interface/"><span class="direction">Next</span><span class="title">Interface</span></a></footer></article></body></html>
