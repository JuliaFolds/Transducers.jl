# Transducers for Julia

```@meta
DocTestSetup = quote
    using Transducers
end
```

[Transducers](https://clojure.org/reference/transducers) are
transformations of "sequence" of input that can be composed very
efficiently.  The interface used by transducers naturally describes a
wide range of processes that is expressible as a succession of steps.
Furthermore, transducers can be defined without specifying the details
of the input and output (collections, streams, channels, etc.)  and
therefore achieves a full reusability.  Transducers are introduced by
Rich Hickey, the creator of the Clojure language.
[His Strange Loop talk](https://www.youtube.com/watch?v=6mTbuzafcII)
is a great introduction to the idea of transducers.

Transducers.jl is an implementation of the transducers in Julia.
Aiming to satisfy high-performance needs of Julia users,
Transducers.jl uses a formulation that is _pure_ [^pure] and aiding
type-stability.

## Installation

```
]add Transducers
```

## Examples

If you are familiar with
[iterators](https://en.wikipedia.org/wiki/Iterator) (see also
[`Base.Iterators`](https://docs.julialang.org/en/v1/base/iterators/)
and [IterTools.jl](https://github.com/JuliaCollections/IterTools.jl))
it would look very familiar to you:

```jldoctest
julia> using Transducers

julia> collect(Map(x -> 2x), 1:3)  # double each element
3-element Array{Int64,1}:
 2
 4
 6

julia> collect(Filter(iseven), 1:6)  # collect only evens
3-element Array{Int64,1}:
 2
 4
 6

julia> collect(MapCat(x -> 1:x), 1:3)  # concatenate mapped results
6-element Array{Int64,1}:
 1
 1
 2
 1
 2
 3

```

Transducers can be composed (without, unlike iterators, referring to
the input):

```jldoctest filter-map
julia> xf = Filter(iseven) |> Map(x -> 2x)
       collect(xf, 1:6)
3-element Array{Int64,1}:
  4
  8
 12
```

An efficient way to use transducers is combination with
[`foldl`](@ref).  This computation is done without creating any
intermediate lazy object and compiles to a single loop:

```jldoctest filter-map
julia> foldl(+, xf, 1:6)
24
```

## Difference to iterators

How `foldl` is used illustrates the difference between
iterators and transducers.  Implementation of the above computation in
iterator would be:

```julia
f(x) = 2x
imap = Base.Iterators.Generator  # like `map`, but returns an iterator
mapfoldl(f, +, filter(iseven, input), init=0)
foldl(+, imap(f, filter(iseven, input)))  # equivalent
#        ______________________________
#        composition occurs at input part
```

Compare it to how transducers are used:

```julia
foldl(+, Filter(iseven) |> Map(f), input, init=0)
#        ________________________
#        composition occurs at computation part
```

Although this is just a syntactic difference, it is reflected in the
actual code generated by those two frameworks.  The code for iterator
would be lowered to:

```jldoctest manual-composition; output = false
function map_filter_iterators(xs, init)
    ret = iterate(xs)
    ret === nothing && return init
    acc = init
    @goto filter
    local state, x
    while true
        while true                                    # input
            ret = iterate(xs, state)                  #
            ret === nothing && return acc             #
            @label filter                             #
            x, state = ret                            #
            iseven(x) && break             # filter   :
        end                                #          :
        y = 2x              # imap         :          :
        acc += y    # +     :              :          :
    end             # :     :              :          :
    #                 + <-- imap <-------- filter <-- input
end

# output

map_filter_iterators (generic function with 1 method)
```

Notice that the iteration of `input` is the _inner_ most block,
followed by `filter`, `imap`, and then finally `+`.  Iterators are
described as _pull-based_; an outer iterator (say `imap`) has to
"pull" an item from the inner iterator (`filter` in above example).
It is reflected in the lowered code above.

On the other hand, the code using transducers is lowered to:

```jldoctest manual-composition; output = false
function map_filter_transducers(xs, init)
    acc = init
    #              input -> Filter --> Map --> +
    for x in xs  # input    :          :       :
        if iseven(x)  #     Filter     :       :
            y = 2x    #                Map     :
            acc += y  #                        +
        end
    end
    return acc
end

xs = [6, 8, 1, 4, 5, 6, 6, 7, 9, 9, 7, 8, 6, 8, 2, 5, 2, 4, 3, 7]
@assert map_filter_iterators(xs, 0) == map_filter_transducers(xs, 0)

# output

```

Notice that the iteration of `input` is at the _outer_ most block
while `+` is in the inner most block.  Transducers passed to
`foldl` appears in the block between them in the order they are
composed.  An outer transducer (say `Filter`) "pushes" _arbitrary_
number of items to the inner transducer (`Map` in above example).
Note that `Filter` can choose to _not_ push an item (i.e., push zero
item) when the predicate returns `false`.  This _push-based_ nature of
the transducers allows the generation of very natural and efficient
code.  To put it another way, the transducers and
[transducible processes](@ref Glossary) _own_ the loop.

As a consequence, computations requiring to expand an item into a
sequence can be processed efficiently.  Consider the following
example:

```jldoctest map-filter-cat
julia> xf = Map(x -> 1:x) |> Filter(iseven ∘ sum) |> Cat()
       foldl(*, xf, 1:10)
29262643200
```

This is lowered to a nested `for` loops:

```jldoctest map-filter-cat; output = false
function map_filter_cat_transducers(xs, init)
    acc = init
    for x in xs
        y1 = 1:x                # Map
        if iseven(sum(y1))      # Filter
            for y2 in y1        # Cat
                acc *= y2       # *
            end
        end
    end
    return acc
end

@assert foldl(*, xf, 1:10) == map_filter_cat_transducers(1:10, 1)
# output

```

It is not straightforward to implement an iterator like `Cat` that can
output more than one items at a time.  Such an iterator has to track
the state of the inner (`y1` in above) and outer (`xs` in above)
iterators and conditionally invoke the outer iterator once the inner
iterator terminates.  This generates a complicated code and the
compiler would have hard time optimizing it.


## List of transducers

Here is the list of pre-defined transducers:

```@eval
import Markdown
import Transducers
Markdown.MD(Transducers.TransducerLister())
```

## Glossary

```julia
foldl(step, xf, input, init=...)
#  |   |    |     |
#  |   |    |     `-- reducible
#  |   |    |
#  |   |    `-- transducer
#  |   |
#  |   `-- "bottom" (inner most) reducing function
#  |
#  `-- transducible process
```

* **Reducing function** or **Reducing step (function)**: A reducing
  function combines result-so-far with the input.  It in a narrow
  sense is a "callable" `op` of the signature `op(::X, ::Y) :: X` (or
  `op(::X, ::X) :: X` in case for [`reduce`](@ref)) or
  schematically:

  ```math
  (\text{result-so-far}, \text{input}) \mapsto \text{result-so-far}
  ```

  It is the function that can be passed to the classic
  (non-Transducers.jl) `Base.foldl` or `Base.reduce`.  It is sometimes
  referred to as a `step` or `op`.  In Transducers.jl,
  [`next(rf, ::X, ::Y) :: X`](@ref Transducers.next) is used instead
  of a "bare" callable.  Furthermore, a reducing function in a loose
  sense also includes other interfaces such as [`start(rf, ::X)`](@ref
  Transducers.start) and [`complete(rf, ::X)`](@ref
  Transducers.complete).

* **Transducer**: A transducer transforms a reducing function into a
  new reducing function.  It is sometimes referred to as a `xf` or
  `xform`.  A transducer can be composed of many sub-transducers; the
  syntax in Transducers.jl is `xf = xf₁ |> xf₂ |> ... |> xfₙ`.  The
  composed transducers are applied to the "bottom" reducing function
  from right to left, i.e., schematically, a new reducing function
  ``\mathrm{rf}`` is obtained from the "bottom" reducing function
  ``\mathrm{step}`` by

  ```math
  \mathrm{rf} =
  \mathrm{xf}_1(\mathrm{xf}_2(...(\mathrm{xf}_{n}(\mathrm{step}))))
  ```

  Given a composition `xf₁ |> xf₂`, transducer `xf₂` is said to be the
  _inner transducer_ of `xf₁ |> xf₂`.  Likewise,
  ``\mathrm{xf}_2(\mathrm{rf}')`` is an _inner reducing function_ of
  ``\mathrm{xf}_1(\mathrm{xf}_2(\mathrm{rf}'))``.

* **Reducible collection** (or just **Reducible**): Any object that
  can be passed to [`foldl`](@ref) and alike is reducible.  A
  reducible collection knows how to apply reducing function to its
  elements.  Iterators are automatically reducible as this is the
  canonical fallback implementation.

* **Transducible process**: A function that can reduce reducible
  collections using transducers is a transducible process.  Examples
  are [`foldl`](@ref) and [`reduce`](@ref).  Find more in
  [Transducible processes](@ref).


## Links

* ["Transducers" by Rich Hickey - YouTube](https://www.youtube.com/watch?v=6mTbuzafcII)
* [Rich Hickey - Inside Transducers - YouTube](https://www.youtube.com/watch?v=4KqUvG8HPYo)
* [CppCon 2015: Juan Pedro Bolívar Puente “Transducers: from Clojure to C++" - YouTube](https://www.youtube.com/watch?v=vohGJjGxtJQ)


---

[^pure]: ...although not pure in the strong sense as `Base.@pure`.
