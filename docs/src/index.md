# Transducers for Julia

!!! warning
    This is a work in progress!

```@meta
DocTestSetup = quote
    using Transducers
end
```

[Transducers](https://clojure.org/reference/transducers) are
composable transformations which can be implemented very efficiently
and useful in both compute- and I/O-bound contexts.  The interface
used by transducers can naturally describe a wide range of processes
that can be expressed as a succession of steps.  Furthermore,
transducers can be defined without specifying the details of the input
and output (collections, streams, channels, etc.) and therefore
achieves a full reusability.  Transducers are introduced by Rich
Hickey, the creator of the Clojure language.
[His Strange Loop talk](https://www.youtube.com/watch?v=6mTbuzafcII)
is a great introduction to the idea of transducers.

Transducers.jl is an implementation of the transducer framework in
Julia.  Aiming to satisfy high-performance needs of Julia users,
Transducers.jl uses a formulation that is _pure_ [^pure] and aiding
type-stability.

[^pure]: ...although not pure in the strong sense as `Base.@pure`.

## Examples

If you are familiar with
[iterators](https://en.wikipedia.org/wiki/Iterator) (see also
[`Base.Iterators`](https://docs.julialang.org/en/v1/base/iterators/)
and [IterTools.jl](https://github.com/JuliaCollections/IterTools.jl))
it would look very familiar to you:

```jldoctest
julia> using Transducers

julia> collect(Map(x -> 2x), 1:3)  # double each element
3-element Array{Int64,1}:
 2
 4
 6

julia> collect(Filter(iseven), 1:6)  # collect only evens
3-element Array{Int64,1}:
 2
 4
 6

julia> collect(MapCat(x -> 1:x), 1:3)  # concatenate mapped results
6-element Array{Int64,1}:
 1
 1
 2
 1
 2
 3

```

Transducers can be composed (without, unlike iterators, referring to
the input):

```jldoctest filter-map
julia> xf = Filter(iseven) |> Map(x -> 2x)
       collect(xf, 1:6)
3-element Array{Int64,1}:
  4
  8
 12
```

An efficient way to use transducers is combination with
[`mapfoldl`](@ref).  This computation is done without creating any
intermediate lazy object and compiles to a single loop:

```jldoctest filter-map
julia> mapfoldl(xf, +, 1:6, init=0)
24
```

## Difference to iterators

Usages of `mapfoldl` (or `foldl`) illustrate the difference between
iterators and transducers.  Implementation of the above computation in
iterator would be:

```julia
f(x) = 2x
imap = Base.Iterators.Generator  # like `map`, but returns an iterator
mapfoldl(f, +, filter(iseven, input), init=0)
foldl(+, imap(f, filter(iseven, input)))  # equivalent
#        ______________________________
#        composition occurs at input part
```

Compare it to how transducers are used:

```julia
mapfoldl(Filter(iseven) |> Map(f), +, input, init=0)
#        ________________________
#        composition occurs at computation part
```

Although these are just a syntactic difference, it is reflected in the
actual code generated by those two frameworks.  The code for iterator
would be lowered to:

```jldoctest manual-composition; output = false
function map_filter_iterators(xs, init)
    ret = iterate(xs)
    ret === nothing && return
    acc = init
    @goto filter
    local state, x
    while true
        while true                                    # input
            ret = iterate(xs, state)                  #
            ret === nothing && return acc             #
            @label filter                             #
            state, x = ret                            #
            iseven(x) && break             # filter   :
        end                                #          :
        y = 2x              # imap         :          :
        acc += y    # +     :              :          :
    end             # :     :              :          :
    #                 + <-- imap <-------- filter <-- input
    return acc
end

# output

map_filter_iterators (generic function with 1 method)
```

Notice that the iteration of `input` is the _inner_ most block,
followed by `filter`, `imap`, and then finally `+`.  Iterators are
described as _pull-based_; an outer iterator (say `imap`) has to
"pull" an item from the inner iterator (`filter` in above example).
It is reflected in the lowered code above.

On the other hand, the code using transducers is lowered to:

```jldoctest manual-composition; output = false
function map_filter_transducers(xs, init)
    acc = init
    #              input -> Filter --> Map --> +
    for x in xs  # input    :          :       :
        if iseven(x)  #     Filter     :       :
            y = 2x    #                Map     :
            acc += y  #                        +
        end
    end
    return acc
end

@assert map_filter_iterators(1:10, 0) == map_filter_transducers(1:10, 0)
# output

```

Notice that the `input` is the _outer_ most block while `+` is in the
inner most block.  Transducers passed to `mapfoldl` appears in the
block between them in the order they are composed.  An outer
transducer (say `Filter`) "pushes" _arbitrary_ number of items to the
inner transducer (`Map` in above example).  Note that `Filter` can
choose to _not_ push an item (i.e., push zero item) when the predicate
returns `false`.  This _push-based_ nature of the transducers allows
the generation of very natural and efficient code.  In other words,
the transducers and transducible processes _own_ the loop.

As a consequence, computations requiring to expand an item into a
sequence can be processed efficiently.  Consider the following
example:

```jldoctest map-filter-cat; output = false, filter = r"Map\(.*?\)"
xf = Map(x -> 1:x) |> Filter(iseven ∘ sum) |> Cat()

# output

Map(Main.λ❓) |>
    Filter(Base.λ❓) |>
    Cat()
```

This is lowered to a nested `for` loops:

```jldoctest map-filter-cat; output = false
function map_filter_cat_transducers(xs, init)
    acc = init
    for x in xs
        y1 = 1:x                # Map
        if iseven(sum(y1))      # Filter
            for y2 in y1        # Cat
                acc += y2       # +
            end
        end
    end
    return acc
end

@assert mapfoldl(xf, +, 1:10, init=0) == map_filter_cat_transducers(1:10, 0)
# output

```

It is not straightforward to implement an iterator like `Cat` that can
output more than one items at a time.  Such an iterator has to track
the state of the inner (`y1` in above) and outer (`xs` in above)
iterators and conditionally invoke the outer iterator once the inner
iterator terminates.  This generates a complicated code and the
compiler would have hard time optimizing it.


## List of transducers

Here is the list of pre-defined transducers:

```@eval
import Markdown
import Transducers
Markdown.MD(Transducers.TransducerLister())
```

## Links

* ["Transducers" by Rich Hickey - YouTube](https://www.youtube.com/watch?v=6mTbuzafcII)
* [Rich Hickey - Inside Transducers - YouTube](https://www.youtube.com/watch?v=4KqUvG8HPYo)
* [CppCon 2015: Juan Pedro Bolívar Puente “Transducers: from Clojure to C++" - YouTube](https://www.youtube.com/watch?v=vohGJjGxtJQ)
